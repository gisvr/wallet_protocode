// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: coinwallet.proto

package pbcoinwallet

import (
	context "context"
	fmt "fmt"
	bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time "github.com/gisvr/golib/time"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CoinInfo struct {
	Cid          int64  `protobuf:"varint,1,opt,name=Cid,proto3" json:"Cid,string"`
	Chain        string `protobuf:"bytes,2,opt,name=Chain,proto3" json:"Chain,omitempty"`
	Symbol       string `protobuf:"bytes,3,opt,name=Symbol,proto3" json:"Symbol,omitempty"`
	Description  string `protobuf:"bytes,4,opt,name=Description,proto3" json:"Description,omitempty"`
	CoinAddr     string `protobuf:"bytes,5,opt,name=CoinAddr,proto3" json:"CoinAddr,omitempty"`
	Decimal      int32  `protobuf:"varint,6,opt,name=Decimal,proto3" json:"Decimal,omitempty"`
	ValidDecimal int32  `protobuf:"varint,7,opt,name=ValidDecimal,proto3" json:"ValidDecimal,omitempty"`
}

func (m *CoinInfo) Reset()         { *m = CoinInfo{} }
func (m *CoinInfo) String() string { return proto.CompactTextString(m) }
func (*CoinInfo) ProtoMessage()    {}
func (*CoinInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{0}
}
func (m *CoinInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinInfo.Merge(m, src)
}
func (m *CoinInfo) XXX_Size() int {
	return m.Size()
}
func (m *CoinInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CoinInfo proto.InternalMessageInfo

func (m *CoinInfo) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *CoinInfo) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *CoinInfo) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CoinInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CoinInfo) GetCoinAddr() string {
	if m != nil {
		return m.CoinAddr
	}
	return ""
}

func (m *CoinInfo) GetDecimal() int32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

func (m *CoinInfo) GetValidDecimal() int32 {
	if m != nil {
		return m.ValidDecimal
	}
	return 0
}

type GetTxinfoRequest struct {
	BlockHash string `protobuf:"bytes,1,opt,name=BlockHash,proto3" json:"BlockHash,omitempty"`
	Txid      string `protobuf:"bytes,2,opt,name=Txid,proto3" json:"Txid,omitempty"`
	Address   string `protobuf:"bytes,3,opt,name=Address,proto3" json:"Address,omitempty"`
}

func (m *GetTxinfoRequest) Reset()         { *m = GetTxinfoRequest{} }
func (m *GetTxinfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetTxinfoRequest) ProtoMessage()    {}
func (*GetTxinfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{1}
}
func (m *GetTxinfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxinfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxinfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxinfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxinfoRequest.Merge(m, src)
}
func (m *GetTxinfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTxinfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxinfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxinfoRequest proto.InternalMessageInfo

func (m *GetTxinfoRequest) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *GetTxinfoRequest) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *GetTxinfoRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type TxInfo struct {
	Coin        *CoinInfo                                                  `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Txid        string                                                     `protobuf:"bytes,2,opt,name=Txid,proto3" json:"Txid,omitempty"`
	FromAddress string                                                     `protobuf:"bytes,3,opt,name=FromAddress,proto3" json:"FromAddress,omitempty"`
	ToAddress   string                                                     `protobuf:"bytes,4,opt,name=ToAddress,proto3" json:"ToAddress,omitempty"`
	Memo        string                                                     `protobuf:"bytes,5,opt,name=Memo,proto3" json:"Memo,omitempty"`
	OutN        int64                                                      `protobuf:"varint,6,opt,name=OutN,proto3" json:",string"`
	Amount      string                                                     `protobuf:"bytes,7,opt,name=Amount,proto3" json:"Amount,omitempty"`
	Comment     string                                                     `protobuf:"bytes,8,opt,name=Comment,proto3" json:"Comment,omitempty"`
	OutNum      int32                                                      `protobuf:"varint,9,opt,name=OutNum,proto3" json:"OutNum,omitempty"`
	Fee         string                                                     `protobuf:"bytes,10,opt,name=Fee,proto3" json:"Fee,omitempty"`
	FeeCoin     *CoinInfo                                                  `protobuf:"bytes,11,opt,name=FeeCoin,proto3" json:"FeeCoin,omitempty"`
	BlockHash   string                                                     `protobuf:"bytes,12,opt,name=BlockHash,proto3" json:"BlockHash,omitempty"`
	BlockNum    int64                                                      `protobuf:"varint,13,opt,name=BlockNum,proto3" json:"BlockNum,string"`
	BlockTime   bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,14,opt,name=BlockTime,proto3,casttype=github.com/gisvr/golib/time.Time" json:"BlockTime,string" gorm:"type:datetime;"`
	Confirm     int32                                                      `protobuf:"varint,15,opt,name=Confirm,proto3" json:"Confirm,omitempty"`
	Side        string                                                     `protobuf:"bytes,16,opt,name=Side,proto3" json:"Side,omitempty"`
}

func (m *TxInfo) Reset()         { *m = TxInfo{} }
func (m *TxInfo) String() string { return proto.CompactTextString(m) }
func (*TxInfo) ProtoMessage()    {}
func (*TxInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{2}
}
func (m *TxInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxInfo.Merge(m, src)
}
func (m *TxInfo) XXX_Size() int {
	return m.Size()
}
func (m *TxInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TxInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TxInfo proto.InternalMessageInfo

func (m *TxInfo) GetCoin() *CoinInfo {
	if m != nil {
		return m.Coin
	}
	return nil
}

func (m *TxInfo) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *TxInfo) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *TxInfo) GetToAddress() string {
	if m != nil {
		return m.ToAddress
	}
	return ""
}

func (m *TxInfo) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *TxInfo) GetOutN() int64 {
	if m != nil {
		return m.OutN
	}
	return 0
}

func (m *TxInfo) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *TxInfo) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *TxInfo) GetOutNum() int32 {
	if m != nil {
		return m.OutNum
	}
	return 0
}

func (m *TxInfo) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

func (m *TxInfo) GetFeeCoin() *CoinInfo {
	if m != nil {
		return m.FeeCoin
	}
	return nil
}

func (m *TxInfo) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *TxInfo) GetBlockNum() int64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *TxInfo) GetBlockTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *TxInfo) GetConfirm() int32 {
	if m != nil {
		return m.Confirm
	}
	return 0
}

func (m *TxInfo) GetSide() string {
	if m != nil {
		return m.Side
	}
	return ""
}

type GetTxinfoResult struct {
	Tx []*TxInfo `protobuf:"bytes,1,rep,name=Tx,proto3" json:"Tx,omitempty"`
}

func (m *GetTxinfoResult) Reset()         { *m = GetTxinfoResult{} }
func (m *GetTxinfoResult) String() string { return proto.CompactTextString(m) }
func (*GetTxinfoResult) ProtoMessage()    {}
func (*GetTxinfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{3}
}
func (m *GetTxinfoResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxinfoResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxinfoResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxinfoResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxinfoResult.Merge(m, src)
}
func (m *GetTxinfoResult) XXX_Size() int {
	return m.Size()
}
func (m *GetTxinfoResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxinfoResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxinfoResult proto.InternalMessageInfo

func (m *GetTxinfoResult) GetTx() []*TxInfo {
	if m != nil {
		return m.Tx
	}
	return nil
}

type GetTxinfoResponse struct {
	ErrNo  string             `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string             `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*GetTxinfoResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *GetTxinfoResponse) Reset()         { *m = GetTxinfoResponse{} }
func (m *GetTxinfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetTxinfoResponse) ProtoMessage()    {}
func (*GetTxinfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{4}
}
func (m *GetTxinfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxinfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxinfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxinfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxinfoResponse.Merge(m, src)
}
func (m *GetTxinfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTxinfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxinfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxinfoResponse proto.InternalMessageInfo

func (m *GetTxinfoResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *GetTxinfoResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *GetTxinfoResponse) GetResult() []*GetTxinfoResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type GetNewAddressRequest struct {
	HdPath string `protobuf:"bytes,1,opt,name=HdPath,proto3" json:"HdPath,omitempty"`
	Label  string `protobuf:"bytes,2,opt,name=Label,proto3" json:"Label,omitempty"`
}

func (m *GetNewAddressRequest) Reset()         { *m = GetNewAddressRequest{} }
func (m *GetNewAddressRequest) String() string { return proto.CompactTextString(m) }
func (*GetNewAddressRequest) ProtoMessage()    {}
func (*GetNewAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{5}
}
func (m *GetNewAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNewAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNewAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNewAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNewAddressRequest.Merge(m, src)
}
func (m *GetNewAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetNewAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNewAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetNewAddressRequest proto.InternalMessageInfo

func (m *GetNewAddressRequest) GetHdPath() string {
	if m != nil {
		return m.HdPath
	}
	return ""
}

func (m *GetNewAddressRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type GetNewAddressResult struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	PubKey  string `protobuf:"bytes,2,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	Memo    string `protobuf:"bytes,3,opt,name=Memo,proto3" json:"Memo,omitempty"`
}

func (m *GetNewAddressResult) Reset()         { *m = GetNewAddressResult{} }
func (m *GetNewAddressResult) String() string { return proto.CompactTextString(m) }
func (*GetNewAddressResult) ProtoMessage()    {}
func (*GetNewAddressResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{6}
}
func (m *GetNewAddressResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNewAddressResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNewAddressResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNewAddressResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNewAddressResult.Merge(m, src)
}
func (m *GetNewAddressResult) XXX_Size() int {
	return m.Size()
}
func (m *GetNewAddressResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNewAddressResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetNewAddressResult proto.InternalMessageInfo

func (m *GetNewAddressResult) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GetNewAddressResult) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *GetNewAddressResult) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

type GetNewAddressResponse struct {
	ErrNo  string                 `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string                 `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*GetNewAddressResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *GetNewAddressResponse) Reset()         { *m = GetNewAddressResponse{} }
func (m *GetNewAddressResponse) String() string { return proto.CompactTextString(m) }
func (*GetNewAddressResponse) ProtoMessage()    {}
func (*GetNewAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{7}
}
func (m *GetNewAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNewAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNewAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNewAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNewAddressResponse.Merge(m, src)
}
func (m *GetNewAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetNewAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNewAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetNewAddressResponse proto.InternalMessageInfo

func (m *GetNewAddressResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *GetNewAddressResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *GetNewAddressResponse) GetResult() []*GetNewAddressResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type ValidateAddressRequest struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
}

func (m *ValidateAddressRequest) Reset()         { *m = ValidateAddressRequest{} }
func (m *ValidateAddressRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateAddressRequest) ProtoMessage()    {}
func (*ValidateAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{8}
}
func (m *ValidateAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAddressRequest.Merge(m, src)
}
func (m *ValidateAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAddressRequest proto.InternalMessageInfo

func (m *ValidateAddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ValidateAddressResult struct {
	IsValidate bool `protobuf:"varint,1,opt,name=IsValidate,proto3" json:"IsValidate,omitempty"`
}

func (m *ValidateAddressResult) Reset()         { *m = ValidateAddressResult{} }
func (m *ValidateAddressResult) String() string { return proto.CompactTextString(m) }
func (*ValidateAddressResult) ProtoMessage()    {}
func (*ValidateAddressResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{9}
}
func (m *ValidateAddressResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAddressResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAddressResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAddressResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAddressResult.Merge(m, src)
}
func (m *ValidateAddressResult) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAddressResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAddressResult.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAddressResult proto.InternalMessageInfo

func (m *ValidateAddressResult) GetIsValidate() bool {
	if m != nil {
		return m.IsValidate
	}
	return false
}

type ValidateAddressResponse struct {
	ErrNo  string                   `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string                   `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*ValidateAddressResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *ValidateAddressResponse) Reset()         { *m = ValidateAddressResponse{} }
func (m *ValidateAddressResponse) String() string { return proto.CompactTextString(m) }
func (*ValidateAddressResponse) ProtoMessage()    {}
func (*ValidateAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{10}
}
func (m *ValidateAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAddressResponse.Merge(m, src)
}
func (m *ValidateAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAddressResponse proto.InternalMessageInfo

func (m *ValidateAddressResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *ValidateAddressResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *ValidateAddressResponse) GetResult() []*ValidateAddressResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type SendToRequest struct {
	Coin    *CoinInfo `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Address string    `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
	Amount  string    `protobuf:"bytes,3,opt,name=Amount,proto3" json:"Amount,omitempty"`
	Fee     string    `protobuf:"bytes,4,opt,name=Fee,proto3" json:"Fee,omitempty"`
	FeeCoin *CoinInfo `protobuf:"bytes,5,opt,name=FeeCoin,proto3" json:"FeeCoin,omitempty"`
	Pool    []string  `protobuf:"bytes,6,rep,name=Pool,proto3" json:"Pool,omitempty"`
}

func (m *SendToRequest) Reset()         { *m = SendToRequest{} }
func (m *SendToRequest) String() string { return proto.CompactTextString(m) }
func (*SendToRequest) ProtoMessage()    {}
func (*SendToRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{11}
}
func (m *SendToRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendToRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendToRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendToRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendToRequest.Merge(m, src)
}
func (m *SendToRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendToRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendToRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendToRequest proto.InternalMessageInfo

func (m *SendToRequest) GetCoin() *CoinInfo {
	if m != nil {
		return m.Coin
	}
	return nil
}

func (m *SendToRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *SendToRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SendToRequest) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

func (m *SendToRequest) GetFeeCoin() *CoinInfo {
	if m != nil {
		return m.FeeCoin
	}
	return nil
}

func (m *SendToRequest) GetPool() []string {
	if m != nil {
		return m.Pool
	}
	return nil
}

type SendToResult struct {
	Txid string `protobuf:"bytes,1,opt,name=Txid,proto3" json:"Txid,omitempty"`
}

func (m *SendToResult) Reset()         { *m = SendToResult{} }
func (m *SendToResult) String() string { return proto.CompactTextString(m) }
func (*SendToResult) ProtoMessage()    {}
func (*SendToResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{12}
}
func (m *SendToResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendToResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendToResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendToResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendToResult.Merge(m, src)
}
func (m *SendToResult) XXX_Size() int {
	return m.Size()
}
func (m *SendToResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SendToResult.DiscardUnknown(m)
}

var xxx_messageInfo_SendToResult proto.InternalMessageInfo

func (m *SendToResult) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

type SendToResponse struct {
	ErrNo  string          `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string          `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*SendToResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *SendToResponse) Reset()         { *m = SendToResponse{} }
func (m *SendToResponse) String() string { return proto.CompactTextString(m) }
func (*SendToResponse) ProtoMessage()    {}
func (*SendToResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{13}
}
func (m *SendToResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendToResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendToResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendToResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendToResponse.Merge(m, src)
}
func (m *SendToResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendToResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendToResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendToResponse proto.InternalMessageInfo

func (m *SendToResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *SendToResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *SendToResponse) GetResult() []*SendToResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type AAReq struct {
	Address  string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Memo     string `protobuf:"bytes,2,opt,name=Memo,proto3" json:"Memo,omitempty"`
	Amount   string `protobuf:"bytes,3,opt,name=Amount,proto3" json:"Amount,omitempty"`
	FeeRate  string `protobuf:"bytes,4,opt,name=FeeRate,proto3" json:"FeeRate,omitempty"`
	Fee      string `protobuf:"bytes,5,opt,name=Fee,proto3" json:"Fee,omitempty"`
	FeeLimit string `protobuf:"bytes,6,opt,name=FeeLimit,proto3" json:"FeeLimit,omitempty"`
}

func (m *AAReq) Reset()         { *m = AAReq{} }
func (m *AAReq) String() string { return proto.CompactTextString(m) }
func (*AAReq) ProtoMessage()    {}
func (*AAReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{14}
}
func (m *AAReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AAReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AAReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AAReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AAReq.Merge(m, src)
}
func (m *AAReq) XXX_Size() int {
	return m.Size()
}
func (m *AAReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AAReq.DiscardUnknown(m)
}

var xxx_messageInfo_AAReq proto.InternalMessageInfo

func (m *AAReq) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AAReq) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *AAReq) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *AAReq) GetFeeRate() string {
	if m != nil {
		return m.FeeRate
	}
	return ""
}

func (m *AAReq) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

func (m *AAReq) GetFeeLimit() string {
	if m != nil {
		return m.FeeLimit
	}
	return ""
}

type AARep struct {
	Address     string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Txid        string `protobuf:"bytes,2,opt,name=Txid,proto3" json:"Txid,omitempty"`
	FromAddress string `protobuf:"bytes,3,opt,name=FromAddress,proto3" json:"FromAddress,omitempty"`
}

func (m *AARep) Reset()         { *m = AARep{} }
func (m *AARep) String() string { return proto.CompactTextString(m) }
func (*AARep) ProtoMessage()    {}
func (*AARep) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{15}
}
func (m *AARep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AARep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AARep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AARep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AARep.Merge(m, src)
}
func (m *AARep) XXX_Size() int {
	return m.Size()
}
func (m *AARep) XXX_DiscardUnknown() {
	xxx_messageInfo_AARep.DiscardUnknown(m)
}

var xxx_messageInfo_AARep proto.InternalMessageInfo

func (m *AARep) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AARep) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *AARep) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

type SendToManyRequest struct {
	Coin          *CoinInfo `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Obj           []*AAReq  `protobuf:"bytes,2,rep,name=Obj,proto3" json:"Obj,omitempty"`
	ChangeAddress string    `protobuf:"bytes,3,opt,name=ChangeAddress,proto3" json:"ChangeAddress,omitempty"`
	FeeCoin       *CoinInfo `protobuf:"bytes,5,opt,name=FeeCoin,proto3" json:"FeeCoin,omitempty"`
	Pool          []string  `protobuf:"bytes,6,rep,name=Pool,proto3" json:"Pool,omitempty"`
}

func (m *SendToManyRequest) Reset()         { *m = SendToManyRequest{} }
func (m *SendToManyRequest) String() string { return proto.CompactTextString(m) }
func (*SendToManyRequest) ProtoMessage()    {}
func (*SendToManyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{16}
}
func (m *SendToManyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendToManyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendToManyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendToManyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendToManyRequest.Merge(m, src)
}
func (m *SendToManyRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendToManyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendToManyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendToManyRequest proto.InternalMessageInfo

func (m *SendToManyRequest) GetCoin() *CoinInfo {
	if m != nil {
		return m.Coin
	}
	return nil
}

func (m *SendToManyRequest) GetObj() []*AAReq {
	if m != nil {
		return m.Obj
	}
	return nil
}

func (m *SendToManyRequest) GetChangeAddress() string {
	if m != nil {
		return m.ChangeAddress
	}
	return ""
}

func (m *SendToManyRequest) GetFeeCoin() *CoinInfo {
	if m != nil {
		return m.FeeCoin
	}
	return nil
}

func (m *SendToManyRequest) GetPool() []string {
	if m != nil {
		return m.Pool
	}
	return nil
}

type SendToManyResult struct {
	Obj []*AARep `protobuf:"bytes,1,rep,name=Obj,proto3" json:"Obj,omitempty"`
}

func (m *SendToManyResult) Reset()         { *m = SendToManyResult{} }
func (m *SendToManyResult) String() string { return proto.CompactTextString(m) }
func (*SendToManyResult) ProtoMessage()    {}
func (*SendToManyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{17}
}
func (m *SendToManyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendToManyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendToManyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendToManyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendToManyResult.Merge(m, src)
}
func (m *SendToManyResult) XXX_Size() int {
	return m.Size()
}
func (m *SendToManyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SendToManyResult.DiscardUnknown(m)
}

var xxx_messageInfo_SendToManyResult proto.InternalMessageInfo

func (m *SendToManyResult) GetObj() []*AARep {
	if m != nil {
		return m.Obj
	}
	return nil
}

type SendToManyResponse struct {
	ErrNo  string              `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string              `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*SendToManyResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *SendToManyResponse) Reset()         { *m = SendToManyResponse{} }
func (m *SendToManyResponse) String() string { return proto.CompactTextString(m) }
func (*SendToManyResponse) ProtoMessage()    {}
func (*SendToManyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{18}
}
func (m *SendToManyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendToManyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendToManyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendToManyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendToManyResponse.Merge(m, src)
}
func (m *SendToManyResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendToManyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendToManyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendToManyResponse proto.InternalMessageInfo

func (m *SendToManyResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *SendToManyResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *SendToManyResponse) GetResult() []*SendToManyResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type BlockHead struct {
	Coin      *CoinInfo                                                  `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	BlockNum  int64                                                      `protobuf:"varint,2,opt,name=BlockNum,proto3" json:"BlockNum,string"`
	BlockTime bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,3,opt,name=BlockTime,proto3,casttype=github.com/gisvr/golib/time.Time" json:"BlockTime,string" gorm:"type:datetime;"`
	Hash      string                                                     `protobuf:"bytes,4,opt,name=Hash,proto3" json:"Hash,omitempty"`
}

func (m *BlockHead) Reset()         { *m = BlockHead{} }
func (m *BlockHead) String() string { return proto.CompactTextString(m) }
func (*BlockHead) ProtoMessage()    {}
func (*BlockHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{19}
}
func (m *BlockHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHead.Merge(m, src)
}
func (m *BlockHead) XXX_Size() int {
	return m.Size()
}
func (m *BlockHead) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHead.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHead proto.InternalMessageInfo

func (m *BlockHead) GetCoin() *CoinInfo {
	if m != nil {
		return m.Coin
	}
	return nil
}

func (m *BlockHead) GetBlockNum() int64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *BlockHead) GetBlockTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *BlockHead) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type GetBlockInfoRequest struct {
	BlockNumOrHash string `protobuf:"bytes,1,opt,name=BlockNumOrHash,proto3" json:"BlockNumOrHash,omitempty"`
}

func (m *GetBlockInfoRequest) Reset()         { *m = GetBlockInfoRequest{} }
func (m *GetBlockInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockInfoRequest) ProtoMessage()    {}
func (*GetBlockInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{20}
}
func (m *GetBlockInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockInfoRequest.Merge(m, src)
}
func (m *GetBlockInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockInfoRequest proto.InternalMessageInfo

func (m *GetBlockInfoRequest) GetBlockNumOrHash() string {
	if m != nil {
		return m.BlockNumOrHash
	}
	return ""
}

type GetBlockInfoResult struct {
	Info *BlockHead `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
}

func (m *GetBlockInfoResult) Reset()         { *m = GetBlockInfoResult{} }
func (m *GetBlockInfoResult) String() string { return proto.CompactTextString(m) }
func (*GetBlockInfoResult) ProtoMessage()    {}
func (*GetBlockInfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{21}
}
func (m *GetBlockInfoResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockInfoResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockInfoResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockInfoResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockInfoResult.Merge(m, src)
}
func (m *GetBlockInfoResult) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockInfoResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockInfoResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockInfoResult proto.InternalMessageInfo

func (m *GetBlockInfoResult) GetInfo() *BlockHead {
	if m != nil {
		return m.Info
	}
	return nil
}

type GetBlockInfoResponse struct {
	ErrNo  string                `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string                `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*GetBlockInfoResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *GetBlockInfoResponse) Reset()         { *m = GetBlockInfoResponse{} }
func (m *GetBlockInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetBlockInfoResponse) ProtoMessage()    {}
func (*GetBlockInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{22}
}
func (m *GetBlockInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockInfoResponse.Merge(m, src)
}
func (m *GetBlockInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockInfoResponse proto.InternalMessageInfo

func (m *GetBlockInfoResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *GetBlockInfoResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *GetBlockInfoResponse) GetResult() []*GetBlockInfoResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type GetBalanceByAddressRequest struct {
	Coins          []*CoinInfo `protobuf:"bytes,1,rep,name=Coins,proto3" json:"Coins,omitempty"`
	Address        string      `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
	SafeConfirmNum int32       `protobuf:"varint,3,opt,name=SafeConfirmNum,proto3" json:"SafeConfirmNum,omitempty"`
}

func (m *GetBalanceByAddressRequest) Reset()         { *m = GetBalanceByAddressRequest{} }
func (m *GetBalanceByAddressRequest) String() string { return proto.CompactTextString(m) }
func (*GetBalanceByAddressRequest) ProtoMessage()    {}
func (*GetBalanceByAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{23}
}
func (m *GetBalanceByAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceByAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceByAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceByAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceByAddressRequest.Merge(m, src)
}
func (m *GetBalanceByAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceByAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceByAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceByAddressRequest proto.InternalMessageInfo

func (m *GetBalanceByAddressRequest) GetCoins() []*CoinInfo {
	if m != nil {
		return m.Coins
	}
	return nil
}

func (m *GetBalanceByAddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GetBalanceByAddressRequest) GetSafeConfirmNum() int32 {
	if m != nil {
		return m.SafeConfirmNum
	}
	return 0
}

type GetBalanceByAddressResult struct {
	Coin   *CoinInfo `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Amount string    `protobuf:"bytes,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
}

func (m *GetBalanceByAddressResult) Reset()         { *m = GetBalanceByAddressResult{} }
func (m *GetBalanceByAddressResult) String() string { return proto.CompactTextString(m) }
func (*GetBalanceByAddressResult) ProtoMessage()    {}
func (*GetBalanceByAddressResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{24}
}
func (m *GetBalanceByAddressResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceByAddressResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceByAddressResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceByAddressResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceByAddressResult.Merge(m, src)
}
func (m *GetBalanceByAddressResult) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceByAddressResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceByAddressResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceByAddressResult proto.InternalMessageInfo

func (m *GetBalanceByAddressResult) GetCoin() *CoinInfo {
	if m != nil {
		return m.Coin
	}
	return nil
}

func (m *GetBalanceByAddressResult) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type GetBalanceByAddressResponse struct {
	ErrNo  string                       `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string                       `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*GetBalanceByAddressResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *GetBalanceByAddressResponse) Reset()         { *m = GetBalanceByAddressResponse{} }
func (m *GetBalanceByAddressResponse) String() string { return proto.CompactTextString(m) }
func (*GetBalanceByAddressResponse) ProtoMessage()    {}
func (*GetBalanceByAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{25}
}
func (m *GetBalanceByAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceByAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceByAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceByAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceByAddressResponse.Merge(m, src)
}
func (m *GetBalanceByAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceByAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceByAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceByAddressResponse proto.InternalMessageInfo

func (m *GetBalanceByAddressResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *GetBalanceByAddressResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *GetBalanceByAddressResponse) GetResult() []*GetBalanceByAddressResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type GetBalanceRequest struct {
	Coins          []*CoinInfo `protobuf:"bytes,1,rep,name=Coins,proto3" json:"Coins,omitempty"`
	SafeConfirmNum int32       `protobuf:"varint,2,opt,name=SafeConfirmNum,proto3" json:"SafeConfirmNum,omitempty"`
}

func (m *GetBalanceRequest) Reset()         { *m = GetBalanceRequest{} }
func (m *GetBalanceRequest) String() string { return proto.CompactTextString(m) }
func (*GetBalanceRequest) ProtoMessage()    {}
func (*GetBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{26}
}
func (m *GetBalanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceRequest.Merge(m, src)
}
func (m *GetBalanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceRequest proto.InternalMessageInfo

func (m *GetBalanceRequest) GetCoins() []*CoinInfo {
	if m != nil {
		return m.Coins
	}
	return nil
}

func (m *GetBalanceRequest) GetSafeConfirmNum() int32 {
	if m != nil {
		return m.SafeConfirmNum
	}
	return 0
}

type GetBalanceResult struct {
	Coin   *CoinInfo `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Amount string    `protobuf:"bytes,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
}

func (m *GetBalanceResult) Reset()         { *m = GetBalanceResult{} }
func (m *GetBalanceResult) String() string { return proto.CompactTextString(m) }
func (*GetBalanceResult) ProtoMessage()    {}
func (*GetBalanceResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{27}
}
func (m *GetBalanceResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceResult.Merge(m, src)
}
func (m *GetBalanceResult) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceResult proto.InternalMessageInfo

func (m *GetBalanceResult) GetCoin() *CoinInfo {
	if m != nil {
		return m.Coin
	}
	return nil
}

func (m *GetBalanceResult) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type GetBalanceResponse struct {
	ErrNo  string              `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string              `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*GetBalanceResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *GetBalanceResponse) Reset()         { *m = GetBalanceResponse{} }
func (m *GetBalanceResponse) String() string { return proto.CompactTextString(m) }
func (*GetBalanceResponse) ProtoMessage()    {}
func (*GetBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{28}
}
func (m *GetBalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceResponse.Merge(m, src)
}
func (m *GetBalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceResponse proto.InternalMessageInfo

func (m *GetBalanceResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *GetBalanceResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *GetBalanceResponse) GetResult() []*GetBalanceResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type AddMonitorAddressRequest struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
}

func (m *AddMonitorAddressRequest) Reset()         { *m = AddMonitorAddressRequest{} }
func (m *AddMonitorAddressRequest) String() string { return proto.CompactTextString(m) }
func (*AddMonitorAddressRequest) ProtoMessage()    {}
func (*AddMonitorAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{29}
}
func (m *AddMonitorAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMonitorAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMonitorAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMonitorAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMonitorAddressRequest.Merge(m, src)
}
func (m *AddMonitorAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddMonitorAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMonitorAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddMonitorAddressRequest proto.InternalMessageInfo

func (m *AddMonitorAddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type AddMonitorAddressResponse struct {
	ErrNo  string `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
}

func (m *AddMonitorAddressResponse) Reset()         { *m = AddMonitorAddressResponse{} }
func (m *AddMonitorAddressResponse) String() string { return proto.CompactTextString(m) }
func (*AddMonitorAddressResponse) ProtoMessage()    {}
func (*AddMonitorAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{30}
}
func (m *AddMonitorAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMonitorAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMonitorAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMonitorAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMonitorAddressResponse.Merge(m, src)
}
func (m *AddMonitorAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddMonitorAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMonitorAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddMonitorAddressResponse proto.InternalMessageInfo

func (m *AddMonitorAddressResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *AddMonitorAddressResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type RemoveMonitorAddressRequest struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
}

func (m *RemoveMonitorAddressRequest) Reset()         { *m = RemoveMonitorAddressRequest{} }
func (m *RemoveMonitorAddressRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveMonitorAddressRequest) ProtoMessage()    {}
func (*RemoveMonitorAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{31}
}
func (m *RemoveMonitorAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveMonitorAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveMonitorAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveMonitorAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveMonitorAddressRequest.Merge(m, src)
}
func (m *RemoveMonitorAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveMonitorAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveMonitorAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveMonitorAddressRequest proto.InternalMessageInfo

func (m *RemoveMonitorAddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type RemoveMonitorAddressResponse struct {
	ErrNo  string `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
}

func (m *RemoveMonitorAddressResponse) Reset()         { *m = RemoveMonitorAddressResponse{} }
func (m *RemoveMonitorAddressResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveMonitorAddressResponse) ProtoMessage()    {}
func (*RemoveMonitorAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{32}
}
func (m *RemoveMonitorAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveMonitorAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveMonitorAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveMonitorAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveMonitorAddressResponse.Merge(m, src)
}
func (m *RemoveMonitorAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoveMonitorAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveMonitorAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveMonitorAddressResponse proto.InternalMessageInfo

func (m *RemoveMonitorAddressResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *RemoveMonitorAddressResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type SetCallbackRequest struct {
	Event string `protobuf:"bytes,1,opt,name=Event,proto3" json:"Event,omitempty"`
	Url   string `protobuf:"bytes,2,opt,name=Url,proto3" json:"Url,omitempty"`
}

func (m *SetCallbackRequest) Reset()         { *m = SetCallbackRequest{} }
func (m *SetCallbackRequest) String() string { return proto.CompactTextString(m) }
func (*SetCallbackRequest) ProtoMessage()    {}
func (*SetCallbackRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{33}
}
func (m *SetCallbackRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCallbackRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCallbackRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCallbackRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCallbackRequest.Merge(m, src)
}
func (m *SetCallbackRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetCallbackRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCallbackRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetCallbackRequest proto.InternalMessageInfo

func (m *SetCallbackRequest) GetEvent() string {
	if m != nil {
		return m.Event
	}
	return ""
}

func (m *SetCallbackRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type SetCallbackResponse struct {
	ErrNo  string `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
}

func (m *SetCallbackResponse) Reset()         { *m = SetCallbackResponse{} }
func (m *SetCallbackResponse) String() string { return proto.CompactTextString(m) }
func (*SetCallbackResponse) ProtoMessage()    {}
func (*SetCallbackResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{34}
}
func (m *SetCallbackResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCallbackResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCallbackResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCallbackResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCallbackResponse.Merge(m, src)
}
func (m *SetCallbackResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetCallbackResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCallbackResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetCallbackResponse proto.InternalMessageInfo

func (m *SetCallbackResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *SetCallbackResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

//给定一组ConfirmTarget，返回每个ConfirmTarget对应的费率
type GetEstimateFeeRequest struct {
	ConfirmTargets []int32 `protobuf:"varint,1,rep,packed,name=ConfirmTargets,proto3" json:"ConfirmTargets,omitempty"`
}

func (m *GetEstimateFeeRequest) Reset()         { *m = GetEstimateFeeRequest{} }
func (m *GetEstimateFeeRequest) String() string { return proto.CompactTextString(m) }
func (*GetEstimateFeeRequest) ProtoMessage()    {}
func (*GetEstimateFeeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{35}
}
func (m *GetEstimateFeeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEstimateFeeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEstimateFeeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEstimateFeeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEstimateFeeRequest.Merge(m, src)
}
func (m *GetEstimateFeeRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetEstimateFeeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEstimateFeeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetEstimateFeeRequest proto.InternalMessageInfo

func (m *GetEstimateFeeRequest) GetConfirmTargets() []int32 {
	if m != nil {
		return m.ConfirmTargets
	}
	return nil
}

type FeeRate struct {
	UnitPrice     string `protobuf:"bytes,1,opt,name=UnitPrice,proto3" json:"UnitPrice,omitempty"`
	ConfirmTarget int32  `protobuf:"varint,2,opt,name=ConfirmTarget,proto3" json:"ConfirmTarget,omitempty"`
}

func (m *FeeRate) Reset()         { *m = FeeRate{} }
func (m *FeeRate) String() string { return proto.CompactTextString(m) }
func (*FeeRate) ProtoMessage()    {}
func (*FeeRate) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{36}
}
func (m *FeeRate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeRate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeRate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeRate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeRate.Merge(m, src)
}
func (m *FeeRate) XXX_Size() int {
	return m.Size()
}
func (m *FeeRate) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeRate.DiscardUnknown(m)
}

var xxx_messageInfo_FeeRate proto.InternalMessageInfo

func (m *FeeRate) GetUnitPrice() string {
	if m != nil {
		return m.UnitPrice
	}
	return ""
}

func (m *FeeRate) GetConfirmTarget() int32 {
	if m != nil {
		return m.ConfirmTarget
	}
	return 0
}

type GetEstimateFeeResult struct {
	Fee     []*FeeRate `protobuf:"bytes,1,rep,name=Fee,proto3" json:"Fee,omitempty"`
	FeeCoin *CoinInfo  `protobuf:"bytes,2,opt,name=FeeCoin,proto3" json:"FeeCoin,omitempty"`
}

func (m *GetEstimateFeeResult) Reset()         { *m = GetEstimateFeeResult{} }
func (m *GetEstimateFeeResult) String() string { return proto.CompactTextString(m) }
func (*GetEstimateFeeResult) ProtoMessage()    {}
func (*GetEstimateFeeResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{37}
}
func (m *GetEstimateFeeResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEstimateFeeResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEstimateFeeResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEstimateFeeResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEstimateFeeResult.Merge(m, src)
}
func (m *GetEstimateFeeResult) XXX_Size() int {
	return m.Size()
}
func (m *GetEstimateFeeResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEstimateFeeResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetEstimateFeeResult proto.InternalMessageInfo

func (m *GetEstimateFeeResult) GetFee() []*FeeRate {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *GetEstimateFeeResult) GetFeeCoin() *CoinInfo {
	if m != nil {
		return m.FeeCoin
	}
	return nil
}

type GetEstimateFeeResponse struct {
	ErrNo  string                  `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string                  `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*GetEstimateFeeResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *GetEstimateFeeResponse) Reset()         { *m = GetEstimateFeeResponse{} }
func (m *GetEstimateFeeResponse) String() string { return proto.CompactTextString(m) }
func (*GetEstimateFeeResponse) ProtoMessage()    {}
func (*GetEstimateFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{38}
}
func (m *GetEstimateFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEstimateFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEstimateFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEstimateFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEstimateFeeResponse.Merge(m, src)
}
func (m *GetEstimateFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetEstimateFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEstimateFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetEstimateFeeResponse proto.InternalMessageInfo

func (m *GetEstimateFeeResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *GetEstimateFeeResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *GetEstimateFeeResponse) GetResult() []*GetEstimateFeeResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type GetMnemonicFingerprintingRequest struct {
}

func (m *GetMnemonicFingerprintingRequest) Reset()         { *m = GetMnemonicFingerprintingRequest{} }
func (m *GetMnemonicFingerprintingRequest) String() string { return proto.CompactTextString(m) }
func (*GetMnemonicFingerprintingRequest) ProtoMessage()    {}
func (*GetMnemonicFingerprintingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{39}
}
func (m *GetMnemonicFingerprintingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMnemonicFingerprintingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMnemonicFingerprintingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMnemonicFingerprintingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMnemonicFingerprintingRequest.Merge(m, src)
}
func (m *GetMnemonicFingerprintingRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMnemonicFingerprintingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMnemonicFingerprintingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMnemonicFingerprintingRequest proto.InternalMessageInfo

type GetMnemonicFingerprintingResult struct {
	Fingerprinting string `protobuf:"bytes,1,opt,name=Fingerprinting,proto3" json:"Fingerprinting,omitempty"`
}

func (m *GetMnemonicFingerprintingResult) Reset()         { *m = GetMnemonicFingerprintingResult{} }
func (m *GetMnemonicFingerprintingResult) String() string { return proto.CompactTextString(m) }
func (*GetMnemonicFingerprintingResult) ProtoMessage()    {}
func (*GetMnemonicFingerprintingResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{40}
}
func (m *GetMnemonicFingerprintingResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMnemonicFingerprintingResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMnemonicFingerprintingResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMnemonicFingerprintingResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMnemonicFingerprintingResult.Merge(m, src)
}
func (m *GetMnemonicFingerprintingResult) XXX_Size() int {
	return m.Size()
}
func (m *GetMnemonicFingerprintingResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMnemonicFingerprintingResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetMnemonicFingerprintingResult proto.InternalMessageInfo

func (m *GetMnemonicFingerprintingResult) GetFingerprinting() string {
	if m != nil {
		return m.Fingerprinting
	}
	return ""
}

type GetMnemonicFingerprintingResponse struct {
	ErrNo  string                             `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string                             `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*GetMnemonicFingerprintingResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *GetMnemonicFingerprintingResponse) Reset()         { *m = GetMnemonicFingerprintingResponse{} }
func (m *GetMnemonicFingerprintingResponse) String() string { return proto.CompactTextString(m) }
func (*GetMnemonicFingerprintingResponse) ProtoMessage()    {}
func (*GetMnemonicFingerprintingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{41}
}
func (m *GetMnemonicFingerprintingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMnemonicFingerprintingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMnemonicFingerprintingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMnemonicFingerprintingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMnemonicFingerprintingResponse.Merge(m, src)
}
func (m *GetMnemonicFingerprintingResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMnemonicFingerprintingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMnemonicFingerprintingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMnemonicFingerprintingResponse proto.InternalMessageInfo

func (m *GetMnemonicFingerprintingResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *GetMnemonicFingerprintingResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *GetMnemonicFingerprintingResponse) GetResult() []*GetMnemonicFingerprintingResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type ImportPrivateKeyRequest struct {
	HdPath string `protobuf:"bytes,1,opt,name=HdPath,proto3" json:"HdPath,omitempty"`
	Label  string `protobuf:"bytes,2,opt,name=Label,proto3" json:"Label,omitempty"`
}

func (m *ImportPrivateKeyRequest) Reset()         { *m = ImportPrivateKeyRequest{} }
func (m *ImportPrivateKeyRequest) String() string { return proto.CompactTextString(m) }
func (*ImportPrivateKeyRequest) ProtoMessage()    {}
func (*ImportPrivateKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{42}
}
func (m *ImportPrivateKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportPrivateKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportPrivateKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportPrivateKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportPrivateKeyRequest.Merge(m, src)
}
func (m *ImportPrivateKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *ImportPrivateKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportPrivateKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImportPrivateKeyRequest proto.InternalMessageInfo

func (m *ImportPrivateKeyRequest) GetHdPath() string {
	if m != nil {
		return m.HdPath
	}
	return ""
}

func (m *ImportPrivateKeyRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type ImportPrivateKeyResult struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	PubKey  string `protobuf:"bytes,2,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	Memo    string `protobuf:"bytes,3,opt,name=Memo,proto3" json:"Memo,omitempty"`
}

func (m *ImportPrivateKeyResult) Reset()         { *m = ImportPrivateKeyResult{} }
func (m *ImportPrivateKeyResult) String() string { return proto.CompactTextString(m) }
func (*ImportPrivateKeyResult) ProtoMessage()    {}
func (*ImportPrivateKeyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{43}
}
func (m *ImportPrivateKeyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportPrivateKeyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportPrivateKeyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportPrivateKeyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportPrivateKeyResult.Merge(m, src)
}
func (m *ImportPrivateKeyResult) XXX_Size() int {
	return m.Size()
}
func (m *ImportPrivateKeyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportPrivateKeyResult.DiscardUnknown(m)
}

var xxx_messageInfo_ImportPrivateKeyResult proto.InternalMessageInfo

func (m *ImportPrivateKeyResult) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ImportPrivateKeyResult) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *ImportPrivateKeyResult) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

type ImportPrivateKeyResponse struct {
	ErrNo  string                    `protobuf:"bytes,1,opt,name=ErrNo,proto3" json:"ErrNo,omitempty"`
	ErrMsg string                    `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
	Result []*ImportPrivateKeyResult `protobuf:"bytes,3,rep,name=Result,proto3" json:"Result,omitempty"`
}

func (m *ImportPrivateKeyResponse) Reset()         { *m = ImportPrivateKeyResponse{} }
func (m *ImportPrivateKeyResponse) String() string { return proto.CompactTextString(m) }
func (*ImportPrivateKeyResponse) ProtoMessage()    {}
func (*ImportPrivateKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{44}
}
func (m *ImportPrivateKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportPrivateKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportPrivateKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportPrivateKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportPrivateKeyResponse.Merge(m, src)
}
func (m *ImportPrivateKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *ImportPrivateKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportPrivateKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ImportPrivateKeyResponse proto.InternalMessageInfo

func (m *ImportPrivateKeyResponse) GetErrNo() string {
	if m != nil {
		return m.ErrNo
	}
	return ""
}

func (m *ImportPrivateKeyResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *ImportPrivateKeyResponse) GetResult() []*ImportPrivateKeyResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type EventBlock struct {
	BlockHead []*BlockHead `protobuf:"bytes,1,rep,name=BlockHead,proto3" json:"BlockHead,omitempty"`
}

func (m *EventBlock) Reset()         { *m = EventBlock{} }
func (m *EventBlock) String() string { return proto.CompactTextString(m) }
func (*EventBlock) ProtoMessage()    {}
func (*EventBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{45}
}
func (m *EventBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBlock.Merge(m, src)
}
func (m *EventBlock) XXX_Size() int {
	return m.Size()
}
func (m *EventBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBlock.DiscardUnknown(m)
}

var xxx_messageInfo_EventBlock proto.InternalMessageInfo

func (m *EventBlock) GetBlockHead() []*BlockHead {
	if m != nil {
		return m.BlockHead
	}
	return nil
}

type EventTx struct {
	Txs []*TxInfo `protobuf:"bytes,1,rep,name=Txs,proto3" json:"Txs,omitempty"`
}

func (m *EventTx) Reset()         { *m = EventTx{} }
func (m *EventTx) String() string { return proto.CompactTextString(m) }
func (*EventTx) ProtoMessage()    {}
func (*EventTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_650aeceb05fff575, []int{46}
}
func (m *EventTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTx.Merge(m, src)
}
func (m *EventTx) XXX_Size() int {
	return m.Size()
}
func (m *EventTx) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTx.DiscardUnknown(m)
}

var xxx_messageInfo_EventTx proto.InternalMessageInfo

func (m *EventTx) GetTxs() []*TxInfo {
	if m != nil {
		return m.Txs
	}
	return nil
}

func init() {
	proto.RegisterType((*CoinInfo)(nil), "coinwallet.api.CoinInfo")
	proto.RegisterType((*GetTxinfoRequest)(nil), "coinwallet.api.GetTxinfoRequest")
	proto.RegisterType((*TxInfo)(nil), "coinwallet.api.TxInfo")
	proto.RegisterType((*GetTxinfoResult)(nil), "coinwallet.api.GetTxinfoResult")
	proto.RegisterType((*GetTxinfoResponse)(nil), "coinwallet.api.GetTxinfoResponse")
	proto.RegisterType((*GetNewAddressRequest)(nil), "coinwallet.api.GetNewAddressRequest")
	proto.RegisterType((*GetNewAddressResult)(nil), "coinwallet.api.GetNewAddressResult")
	proto.RegisterType((*GetNewAddressResponse)(nil), "coinwallet.api.GetNewAddressResponse")
	proto.RegisterType((*ValidateAddressRequest)(nil), "coinwallet.api.ValidateAddressRequest")
	proto.RegisterType((*ValidateAddressResult)(nil), "coinwallet.api.ValidateAddressResult")
	proto.RegisterType((*ValidateAddressResponse)(nil), "coinwallet.api.ValidateAddressResponse")
	proto.RegisterType((*SendToRequest)(nil), "coinwallet.api.SendToRequest")
	proto.RegisterType((*SendToResult)(nil), "coinwallet.api.SendToResult")
	proto.RegisterType((*SendToResponse)(nil), "coinwallet.api.SendToResponse")
	proto.RegisterType((*AAReq)(nil), "coinwallet.api.AAReq")
	proto.RegisterType((*AARep)(nil), "coinwallet.api.AARep")
	proto.RegisterType((*SendToManyRequest)(nil), "coinwallet.api.SendToManyRequest")
	proto.RegisterType((*SendToManyResult)(nil), "coinwallet.api.SendToManyResult")
	proto.RegisterType((*SendToManyResponse)(nil), "coinwallet.api.SendToManyResponse")
	proto.RegisterType((*BlockHead)(nil), "coinwallet.api.BlockHead")
	proto.RegisterType((*GetBlockInfoRequest)(nil), "coinwallet.api.GetBlockInfoRequest")
	proto.RegisterType((*GetBlockInfoResult)(nil), "coinwallet.api.GetBlockInfoResult")
	proto.RegisterType((*GetBlockInfoResponse)(nil), "coinwallet.api.GetBlockInfoResponse")
	proto.RegisterType((*GetBalanceByAddressRequest)(nil), "coinwallet.api.GetBalanceByAddressRequest")
	proto.RegisterType((*GetBalanceByAddressResult)(nil), "coinwallet.api.GetBalanceByAddressResult")
	proto.RegisterType((*GetBalanceByAddressResponse)(nil), "coinwallet.api.GetBalanceByAddressResponse")
	proto.RegisterType((*GetBalanceRequest)(nil), "coinwallet.api.GetBalanceRequest")
	proto.RegisterType((*GetBalanceResult)(nil), "coinwallet.api.GetBalanceResult")
	proto.RegisterType((*GetBalanceResponse)(nil), "coinwallet.api.GetBalanceResponse")
	proto.RegisterType((*AddMonitorAddressRequest)(nil), "coinwallet.api.AddMonitorAddressRequest")
	proto.RegisterType((*AddMonitorAddressResponse)(nil), "coinwallet.api.AddMonitorAddressResponse")
	proto.RegisterType((*RemoveMonitorAddressRequest)(nil), "coinwallet.api.RemoveMonitorAddressRequest")
	proto.RegisterType((*RemoveMonitorAddressResponse)(nil), "coinwallet.api.RemoveMonitorAddressResponse")
	proto.RegisterType((*SetCallbackRequest)(nil), "coinwallet.api.SetCallbackRequest")
	proto.RegisterType((*SetCallbackResponse)(nil), "coinwallet.api.SetCallbackResponse")
	proto.RegisterType((*GetEstimateFeeRequest)(nil), "coinwallet.api.GetEstimateFeeRequest")
	proto.RegisterType((*FeeRate)(nil), "coinwallet.api.FeeRate")
	proto.RegisterType((*GetEstimateFeeResult)(nil), "coinwallet.api.GetEstimateFeeResult")
	proto.RegisterType((*GetEstimateFeeResponse)(nil), "coinwallet.api.GetEstimateFeeResponse")
	proto.RegisterType((*GetMnemonicFingerprintingRequest)(nil), "coinwallet.api.GetMnemonicFingerprintingRequest")
	proto.RegisterType((*GetMnemonicFingerprintingResult)(nil), "coinwallet.api.GetMnemonicFingerprintingResult")
	proto.RegisterType((*GetMnemonicFingerprintingResponse)(nil), "coinwallet.api.GetMnemonicFingerprintingResponse")
	proto.RegisterType((*ImportPrivateKeyRequest)(nil), "coinwallet.api.ImportPrivateKeyRequest")
	proto.RegisterType((*ImportPrivateKeyResult)(nil), "coinwallet.api.ImportPrivateKeyResult")
	proto.RegisterType((*ImportPrivateKeyResponse)(nil), "coinwallet.api.ImportPrivateKeyResponse")
	proto.RegisterType((*EventBlock)(nil), "coinwallet.api.EventBlock")
	proto.RegisterType((*EventTx)(nil), "coinwallet.api.EventTx")
}

func init() { proto.RegisterFile("coinwallet.proto", fileDescriptor_650aeceb05fff575) }

var fileDescriptor_650aeceb05fff575 = []byte{
	// 1874 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcd, 0x73, 0x13, 0xc9,
	0x15, 0xf7, 0x48, 0xf2, 0xd7, 0x33, 0x18, 0xd3, 0x80, 0x19, 0xb4, 0xc4, 0x12, 0x0d, 0x18, 0x93,
	0x80, 0xc5, 0x7a, 0xa9, 0x22, 0x81, 0xdd, 0xa4, 0x6c, 0x81, 0xbd, 0xce, 0x62, 0xa0, 0x06, 0x91,
	0xdd, 0xca, 0x56, 0x41, 0x8d, 0x34, 0x6d, 0xd1, 0x6b, 0xcd, 0xb4, 0x76, 0x66, 0x04, 0x76, 0x6a,
	0x0f, 0xa9, 0xad, 0x54, 0x2a, 0xc9, 0x21, 0x95, 0x4b, 0x2e, 0xf9, 0x8b, 0x92, 0xdb, 0x9e, 0x52,
	0x9c, 0x5c, 0x29, 0xb8, 0xf9, 0x98, 0x23, 0xa7, 0x54, 0x77, 0x4f, 0x8f, 0x66, 0x5a, 0x63, 0x7d,
	0x15, 0xa9, 0x3d, 0x69, 0x5e, 0xf7, 0xeb, 0xf7, 0xf1, 0xeb, 0xd7, 0xef, 0xbd, 0x6e, 0xc1, 0x42,
	0x83, 0x51, 0xef, 0xb5, 0xdd, 0x6a, 0x91, 0x70, 0xb5, 0xed, 0xb3, 0x90, 0xa1, 0xf9, 0xc4, 0x88,
	0xdd, 0xa6, 0xc5, 0x9b, 0x4d, 0x1a, 0xbe, 0xec, 0xd4, 0x57, 0x1b, 0xcc, 0xad, 0x34, 0x59, 0x93,
	0x55, 0x04, 0x5b, 0xbd, 0xb3, 0x2b, 0x28, 0x41, 0x88, 0x2f, 0xb9, 0xbc, 0x78, 0xb1, 0xc9, 0x58,
	0xb3, 0x45, 0x2a, 0x76, 0x9b, 0x56, 0x6c, 0xcf, 0x63, 0xa1, 0x1d, 0x52, 0xe6, 0x05, 0x72, 0x16,
	0xff, 0xdb, 0x80, 0x99, 0x2a, 0xa3, 0xde, 0xb6, 0xb7, 0xcb, 0x50, 0x19, 0xf2, 0x55, 0xea, 0x98,
	0x46, 0xd9, 0x58, 0xc9, 0x6f, 0xcc, 0x1f, 0x1d, 0x96, 0xa0, 0x4a, 0x9d, 0x1b, 0x41, 0xe8, 0x53,
	0xaf, 0x69, 0xf1, 0x29, 0x74, 0x16, 0x26, 0xab, 0x2f, 0x6d, 0xea, 0x99, 0xb9, 0xb2, 0xb1, 0x32,
	0x6b, 0x49, 0x02, 0x2d, 0xc2, 0xd4, 0xd3, 0x03, 0xb7, 0xce, 0x5a, 0x66, 0x5e, 0x0c, 0x47, 0x14,
	0x2a, 0xc3, 0xdc, 0x7d, 0x12, 0x34, 0x7c, 0xda, 0xe6, 0x2a, 0xcd, 0x82, 0x98, 0x4c, 0x0e, 0xa1,
	0xa2, 0xd4, 0xbe, 0xee, 0x38, 0xbe, 0x39, 0x29, 0xa6, 0x63, 0x1a, 0x99, 0x30, 0x7d, 0x9f, 0x34,
	0xa8, 0x6b, 0xb7, 0xcc, 0xa9, 0xb2, 0xb1, 0x32, 0x69, 0x29, 0x12, 0x61, 0x38, 0xf1, 0x1b, 0xbb,
	0x45, 0x1d, 0x35, 0x3d, 0x2d, 0xa6, 0x53, 0x63, 0xf8, 0x39, 0x2c, 0x6c, 0x91, 0xb0, 0xb6, 0x4f,
	0xbd, 0x5d, 0x66, 0x91, 0x6f, 0x3b, 0x24, 0x08, 0xd1, 0x45, 0x98, 0xdd, 0x68, 0xb1, 0xc6, 0xde,
	0xe7, 0x76, 0xf0, 0x52, 0x78, 0x39, 0x6b, 0x75, 0x07, 0x10, 0x82, 0x42, 0x6d, 0x9f, 0x3a, 0x91,
	0x6b, 0xe2, 0x9b, 0xdb, 0xc0, 0x6d, 0x21, 0x41, 0x10, 0xb9, 0xa6, 0x48, 0xfc, 0xa6, 0x00, 0x53,
	0xb5, 0x7d, 0x01, 0xdb, 0x0d, 0x28, 0x70, 0xa3, 0x85, 0xc4, 0xb9, 0x35, 0x73, 0x35, 0xbd, 0x5f,
	0xab, 0x0a, 0x5e, 0x4b, 0x70, 0x65, 0xaa, 0x29, 0xc3, 0xdc, 0xa6, 0xcf, 0xdc, 0xb4, 0xaa, 0xe4,
	0x10, 0x37, 0xbd, 0xc6, 0xd4, 0xbc, 0x04, 0xb2, 0x3b, 0xc0, 0x65, 0xee, 0x10, 0x97, 0x45, 0x10,
	0x8a, 0x6f, 0x54, 0x82, 0xc2, 0xe3, 0x4e, 0xf8, 0x48, 0x60, 0x97, 0xdf, 0x98, 0x3b, 0x3a, 0x2c,
	0x4d, 0xab, 0xad, 0x14, 0x13, 0x7c, 0xd7, 0xd6, 0x5d, 0xd6, 0xf1, 0x42, 0x81, 0xdf, 0xac, 0x15,
	0x51, 0xdc, 0xe7, 0x2a, 0x73, 0x5d, 0xe2, 0x85, 0xe6, 0x8c, 0xf4, 0x39, 0x22, 0xf9, 0x0a, 0xbe,
	0xb2, 0xe3, 0x9a, 0xb3, 0x02, 0xf1, 0x88, 0x42, 0x0b, 0x90, 0xdf, 0x24, 0xc4, 0x04, 0xc1, 0xcd,
	0x3f, 0xd1, 0x1a, 0x4c, 0x6f, 0x12, 0x22, 0x50, 0x99, 0x1b, 0x80, 0x8a, 0x62, 0x4c, 0xef, 0xce,
	0x09, 0x7d, 0x77, 0x2a, 0x30, 0x23, 0x08, 0xae, 0xfd, 0xa4, 0x70, 0xe9, 0xcc, 0xd1, 0x61, 0xe9,
	0x94, 0x1a, 0x53, 0xae, 0xc5, 0x4c, 0xe8, 0xcf, 0x46, 0x24, 0xaf, 0x46, 0x5d, 0x62, 0xce, 0x8b,
	0x25, 0x7b, 0x47, 0x87, 0xa5, 0x85, 0x78, 0x30, 0x5a, 0xf3, 0xdf, 0xc3, 0xd2, 0xb9, 0x26, 0xf3,
	0xdd, 0xbb, 0x38, 0x3c, 0x68, 0x93, 0xbb, 0x8e, 0x1d, 0x92, 0x90, 0xba, 0xe4, 0x1e, 0x7e, 0x7f,
	0x58, 0xba, 0x5b, 0xa7, 0x61, 0xbd, 0xd3, 0xd8, 0x23, 0xe1, 0x2a, 0xf3, 0x9b, 0x95, 0x3a, 0xa5,
	0x94, 0x9f, 0xa5, 0xe8, 0xf7, 0xc5, 0x6b, 0xfb, 0xd6, 0xad, 0x8f, 0x5f, 0x38, 0xb6, 0x1b, 0x54,
	0x02, 0xbf, 0x51, 0x69, 0xd1, 0x7a, 0x85, 0x2f, 0x5d, 0xe5, 0xd2, 0xad, 0xae, 0x76, 0x09, 0xa9,
	0xb7, 0x4b, 0x7d, 0xd7, 0x3c, 0x25, 0x43, 0x39, 0x22, 0xf9, 0xce, 0x3d, 0xa5, 0x0e, 0x31, 0x17,
	0xe4, 0xce, 0xf1, 0x6f, 0xfc, 0x0b, 0x38, 0x95, 0x08, 0xdd, 0xa0, 0xd3, 0x0a, 0xd1, 0x32, 0xe4,
	0x6a, 0xfb, 0xa6, 0x51, 0xce, 0xaf, 0xcc, 0xad, 0x2d, 0xea, 0x50, 0xca, 0x30, 0xb4, 0x72, 0xb5,
	0x7d, 0xfc, 0x3b, 0x38, 0x9d, 0x5c, 0xda, 0x66, 0x5e, 0x40, 0xf8, 0xa1, 0x7d, 0xe0, 0xfb, 0x8f,
	0x58, 0x14, 0xf2, 0x92, 0xe0, 0x9b, 0xf9, 0xc0, 0xf7, 0x77, 0x82, 0x66, 0x14, 0x89, 0x11, 0x85,
	0xee, 0xc0, 0x94, 0x54, 0x6a, 0xe6, 0x85, 0xba, 0x92, 0xae, 0x4e, 0xb3, 0xcd, 0x8a, 0xd8, 0xf1,
	0x7d, 0x38, 0xbb, 0x45, 0xc2, 0x47, 0xe4, 0x75, 0x14, 0x95, 0xea, 0xd4, 0x2d, 0xc2, 0xd4, 0xe7,
	0xce, 0x13, 0x3b, 0x54, 0x47, 0x2e, 0xa2, 0xb8, 0x59, 0x0f, 0xed, 0x3a, 0x69, 0xa9, 0x5c, 0x22,
	0x08, 0xfc, 0x35, 0x9c, 0xd1, 0xa4, 0x08, 0x00, 0x12, 0x07, 0xd1, 0x48, 0x1d, 0x44, 0x2e, 0xfe,
	0x49, 0xa7, 0xfe, 0x05, 0x39, 0x50, 0x7e, 0x48, 0x2a, 0x3e, 0x13, 0xf9, 0xee, 0x99, 0xc0, 0xdf,
	0x1b, 0x70, 0x4e, 0x97, 0x3e, 0x0e, 0x46, 0xf7, 0x34, 0x8c, 0x2e, 0x67, 0x60, 0xa4, 0xbb, 0x10,
	0xe3, 0xb4, 0x06, 0x8b, 0x22, 0x53, 0xd9, 0x21, 0xd1, 0x90, 0x3a, 0xd6, 0x49, 0x7c, 0x07, 0xce,
	0xf5, 0xac, 0x11, 0xb8, 0x2c, 0x01, 0x6c, 0x07, 0x6a, 0x4a, 0xac, 0x9a, 0xb1, 0x12, 0x23, 0xf8,
	0x8f, 0x06, 0x9c, 0xef, 0x5d, 0x39, 0x8e, 0xcf, 0x9f, 0x69, 0x3e, 0x5f, 0xd5, 0x7d, 0xce, 0x34,
	0x30, 0xf6, 0xfa, 0x5f, 0x06, 0x9c, 0x7c, 0x4a, 0x3c, 0xa7, 0x16, 0x67, 0xe3, 0xd1, 0xd2, 0x66,
	0x02, 0x9b, 0x5c, 0x4f, 0x00, 0x44, 0x79, 0x2c, 0x9f, 0xca, 0x63, 0x51, 0x56, 0x2a, 0x64, 0x66,
	0xa5, 0xc9, 0x61, 0xb3, 0x12, 0x82, 0xc2, 0x13, 0xc6, 0x78, 0x09, 0xca, 0xf3, 0x30, 0xe2, 0xdf,
	0x18, 0xc3, 0x09, 0xe5, 0x8a, 0xd8, 0x04, 0x95, 0xd2, 0x8d, 0x6e, 0x4a, 0xc7, 0x21, 0xcc, 0xc7,
	0x3c, 0xe3, 0xc0, 0x7d, 0x5b, 0x83, 0xfb, 0xa2, 0x6e, 0x6a, 0xd2, 0x82, 0x18, 0xe5, 0xbf, 0x1b,
	0x30, 0xb9, 0xbe, 0x6e, 0x91, 0x6f, 0xfb, 0x1c, 0x18, 0x75, 0x30, 0x72, 0x89, 0x62, 0x71, 0x1c,
	0x86, 0xa6, 0x40, 0xcc, 0xe2, 0xb1, 0x25, 0x71, 0x54, 0xa4, 0x42, 0x77, 0xb2, 0x8b, 0x6e, 0x11,
	0x66, 0x36, 0x09, 0x79, 0x48, 0x5d, 0x1a, 0x8a, 0xa2, 0x33, 0x6b, 0xc5, 0x34, 0xfe, 0x52, 0x9a,
	0xd5, 0xee, 0x6f, 0xd6, 0xe8, 0x75, 0x11, 0xbf, 0x31, 0xe0, 0xb4, 0x44, 0x62, 0xc7, 0xf6, 0x0e,
	0xc6, 0x0b, 0xad, 0x6b, 0x90, 0x7f, 0x5c, 0xff, 0xc6, 0xcc, 0x09, 0x9c, 0xcf, 0xe9, 0xcc, 0x02,
	0x4e, 0x8b, 0x73, 0xa0, 0x2b, 0x70, 0xb2, 0xfa, 0xd2, 0xf6, 0x9a, 0x24, 0x6d, 0x50, 0x7a, 0xf0,
	0x83, 0x45, 0xd9, 0x3d, 0x58, 0x48, 0x7a, 0x26, 0x22, 0x2d, 0x32, 0xd5, 0x38, 0xde, 0xd4, 0xb6,
	0x30, 0x15, 0x7f, 0x07, 0x28, 0xb5, 0x78, 0x9c, 0x10, 0xfc, 0xb9, 0x16, 0x82, 0xe5, 0xec, 0x10,
	0xec, 0x9a, 0x17, 0x87, 0xe1, 0x5f, 0x72, 0xaa, 0x96, 0x13, 0xdb, 0x19, 0x71, 0x37, 0x92, 0x85,
	0x3e, 0x37, 0x7a, 0xa1, 0xcf, 0xff, 0xa8, 0x85, 0x1e, 0x41, 0x41, 0xb4, 0x2f, 0xf2, 0xb0, 0x88,
	0x6f, 0xfc, 0x99, 0xa8, 0x68, 0x82, 0x67, 0x3b, 0xd1, 0x8c, 0x2e, 0xc3, 0xbc, 0x72, 0xe1, 0xb1,
	0x9f, 0xe8, 0x48, 0xb5, 0x51, 0x5c, 0x05, 0x94, 0x5e, 0x2e, 0x02, 0xe1, 0x26, 0x14, 0x38, 0x15,
	0x61, 0x7a, 0x41, 0xc7, 0x34, 0x06, 0xdf, 0x12, 0x6c, 0xf8, 0xf7, 0x86, 0x28, 0xce, 0x49, 0x29,
	0xe3, 0x44, 0xc4, 0x5d, 0x2d, 0x22, 0x70, 0x46, 0xdd, 0xd3, 0x2c, 0x8d, 0x63, 0xe2, 0xaf, 0x06,
	0x14, 0xf9, 0xb4, 0xdd, 0xb2, 0xbd, 0x06, 0xd9, 0x38, 0xd0, 0x6a, 0xdf, 0x2a, 0x4c, 0xf2, 0xed,
	0x0f, 0xa2, 0xd8, 0x3e, 0x3e, 0x4a, 0x24, 0x5b, 0x9f, 0x7a, 0xb0, 0x0c, 0xf3, 0x4f, 0xed, 0x5d,
	0x12, 0x75, 0x58, 0x3c, 0x8c, 0xf2, 0xa2, 0xe7, 0xd2, 0x46, 0xb1, 0x0d, 0x17, 0x32, 0xed, 0x11,
	0xf8, 0x8e, 0x16, 0xb3, 0xdd, 0xf4, 0x99, 0x4b, 0xa6, 0x4f, 0xee, 0xf3, 0x47, 0xd9, 0x3a, 0xc6,
	0x41, 0x7f, 0x5d, 0x43, 0xff, 0x7a, 0x16, 0xfa, 0x99, 0xee, 0xc4, 0x9b, 0xb0, 0x27, 0xfa, 0xc3,
	0x88, 0x69, 0x5c, 0xe8, 0x7b, 0x01, 0xce, 0x65, 0x02, 0xfc, 0x95, 0xb8, 0x82, 0xc5, 0xca, 0x3e,
	0x20, 0xae, 0xdf, 0xc9, 0x33, 0x11, 0x4b, 0xfe, 0xbf, 0x64, 0x37, 0xdd, 0xf6, 0x18, 0xc4, 0xdb,
	0x60, 0xae, 0x3b, 0xce, 0x0e, 0xf3, 0x68, 0xc8, 0xfc, 0xa1, 0x5b, 0xb8, 0x6d, 0xb8, 0x90, 0xb1,
	0x6a, 0x1c, 0xd3, 0xf1, 0x1d, 0xf8, 0xc8, 0x22, 0x2e, 0x7b, 0x45, 0x46, 0xb5, 0xe1, 0x21, 0x5c,
	0xcc, 0x5e, 0x38, 0x96, 0x19, 0x9f, 0xf2, 0x1a, 0x13, 0x56, 0xed, 0x56, 0xab, 0x6e, 0x37, 0xf6,
	0x94, 0x76, 0x2e, 0xe3, 0x15, 0xbf, 0x3c, 0x2a, 0x19, 0x9c, 0xe0, 0xed, 0xc2, 0x33, 0x5f, 0xb5,
	0xfa, 0xfc, 0x13, 0x57, 0xe1, 0x4c, 0x6a, 0xf5, 0x58, 0x26, 0xfc, 0x4a, 0xf4, 0xf3, 0x0f, 0x82,
	0x90, 0xba, 0x76, 0x48, 0x78, 0x6f, 0xd2, 0xcd, 0xae, 0x51, 0x24, 0xd6, 0x6c, 0xbf, 0x49, 0x42,
	0x19, 0xdc, 0x93, 0x96, 0x36, 0x8a, 0x77, 0xe2, 0x06, 0x87, 0xdf, 0x3f, 0x9f, 0x79, 0x34, 0x7c,
	0xe2, 0xd3, 0x06, 0x51, 0xaf, 0x03, 0xf1, 0x80, 0xa8, 0xfd, 0xc9, 0xa5, 0x51, 0xcc, 0xa7, 0x07,
	0x71, 0x47, 0xa4, 0xd9, 0x94, 0x3d, 0x22, 0xec, 0xaf, 0xcb, 0x6e, 0x49, 0x1e, 0xb0, 0xf3, 0x7a,
	0xa4, 0x45, 0x16, 0xf4, 0x34, 0xa9, 0xb9, 0x21, 0xdb, 0x07, 0xfc, 0x07, 0x03, 0x16, 0x7b, 0xf4,
	0x8e, 0x73, 0x28, 0x3e, 0xd5, 0x0e, 0xc5, 0x95, 0x8c, 0x43, 0xd1, 0xe3, 0x5d, 0x7c, 0x30, 0x30,
	0x94, 0xb7, 0x48, 0xb8, 0xe3, 0x11, 0x97, 0x79, 0xb4, 0xb1, 0x49, 0xbd, 0x26, 0xf1, 0xdb, 0x3e,
	0xf5, 0x42, 0x5e, 0xb0, 0xe5, 0xc6, 0xe0, 0x6d, 0x28, 0xf5, 0xe1, 0x89, 0x2e, 0xbb, 0xf3, 0xe9,
	0x71, 0x55, 0x19, 0xd3, 0xa3, 0xf8, 0x1f, 0x06, 0x5c, 0xea, 0x27, 0x6b, 0x1c, 0x00, 0xb6, 0x34,
	0x00, 0x2a, 0x19, 0x00, 0xf4, 0x33, 0x3e, 0xc6, 0x62, 0x0b, 0xce, 0x6f, 0xbb, 0x6d, 0xe6, 0xf3,
	0xf0, 0x79, 0x65, 0x87, 0xe4, 0x0b, 0x72, 0x30, 0xde, 0x85, 0xf8, 0x39, 0x2c, 0xf6, 0x0a, 0xfa,
	0x80, 0x77, 0xe2, 0x3f, 0x19, 0x60, 0x66, 0x28, 0x18, 0x07, 0xbc, 0x5f, 0x6a, 0xe0, 0x2d, 0xeb,
	0xe0, 0x65, 0x3b, 0x12, 0x63, 0xf6, 0x00, 0x40, 0x64, 0x0b, 0xd1, 0x42, 0xa0, 0x3b, 0x89, 0x1e,
	0x32, 0x3a, 0x39, 0x7d, 0xfa, 0x9c, 0x2e, 0x2f, 0xfe, 0x04, 0xa6, 0x85, 0x98, 0xda, 0x3e, 0x5a,
	0x81, 0x7c, 0x6d, 0x3f, 0x18, 0xf0, 0x70, 0xc2, 0x59, 0xd6, 0xde, 0x03, 0x00, 0x3f, 0x4b, 0x5f,
	0x8a, 0x69, 0xf4, 0x35, 0x9c, 0x48, 0xf6, 0x32, 0xe8, 0x72, 0xff, 0x4e, 0x47, 0x6c, 0x6c, 0xf1,
	0xca, 0x80, 0x76, 0x48, 0x60, 0x8a, 0x27, 0x90, 0x05, 0xb3, 0xf1, 0x23, 0x0a, 0x2a, 0xf7, 0x79,
	0x5f, 0x91, 0x62, 0x2f, 0xf5, 0x7b, 0x81, 0x51, 0x32, 0x9f, 0xc3, 0xc9, 0xd4, 0xa3, 0x03, 0xba,
	0x32, 0xe0, 0x4d, 0x42, 0xca, 0xbe, 0x3a, 0xe8, 0xe5, 0x42, 0xc9, 0x77, 0xe0, 0x94, 0x76, 0xc1,
	0x47, 0xcb, 0x03, 0x5f, 0x00, 0xa4, 0x8e, 0x6b, 0x83, 0x5f, 0x0a, 0x94, 0x96, 0x6d, 0x98, 0x92,
	0x97, 0x0a, 0xf4, 0x93, 0xe3, 0xee, 0xbb, 0x52, 0xe6, 0xd2, 0xb1, 0xd7, 0x61, 0x25, 0xea, 0x19,
	0x40, 0xf7, 0x7e, 0x82, 0x2e, 0xf5, 0xbb, 0xbb, 0x48, 0x91, 0xb8, 0xef, 0xf5, 0x46, 0x89, 0x6d,
	0xcb, 0x6e, 0x5e, 0x6b, 0xb3, 0xd0, 0x4f, 0x87, 0xea, 0xc5, 0xa4, 0xa2, 0x9f, 0x0d, 0xd7, 0xb7,
	0x25, 0x1c, 0xe9, 0x32, 0xa0, 0x4b, 0xfd, 0xda, 0x94, 0x63, 0x1c, 0xe9, 0xed, 0x95, 0xf0, 0x04,
	0xfa, 0x06, 0x4e, 0xf7, 0xf4, 0x23, 0x68, 0xa5, 0xe7, 0x4a, 0x79, 0x4c, 0xa3, 0x53, 0xbc, 0x3e,
	0x04, 0x67, 0xac, 0x2b, 0x80, 0xb3, 0x59, 0x7d, 0x07, 0xea, 0x41, 0xa2, 0x4f, 0x5b, 0x53, 0xbc,
	0x31, 0x1c, 0x73, 0xac, 0xf4, 0x2b, 0x98, 0x4b, 0x34, 0x18, 0x28, 0x63, 0x7b, 0xf5, 0xde, 0xa5,
	0x78, 0xb9, 0x2f, 0x4f, 0x2c, 0xd9, 0x86, 0xf9, 0x74, 0x1d, 0x44, 0x57, 0x07, 0xd5, 0x49, 0x29,
	0x7f, 0x79, 0x60, 0x39, 0x55, 0x2a, 0xbe, 0x37, 0xc4, 0xed, 0x24, 0xbb, 0xd4, 0xa0, 0x5b, 0x23,
	0x54, 0x25, 0xa9, 0xf9, 0xe3, 0x51, 0xea, 0x98, 0x32, 0xa2, 0x09, 0x0b, 0x7a, 0xc6, 0x46, 0xd7,
	0x06, 0xe7, 0x74, 0xa9, 0x71, 0x65, 0x88, 0xe4, 0x1f, 0x29, 0xda, 0x70, 0xfe, 0xf9, 0x76, 0xc9,
	0xf8, 0xe1, 0xed, 0x92, 0xf1, 0x9f, 0xb7, 0x4b, 0xc6, 0xdf, 0xde, 0x2d, 0x4d, 0xfc, 0xf0, 0x6e,
	0x69, 0xe2, 0xcd, 0xbb, 0xa5, 0x89, 0xdf, 0xfe, 0x7a, 0xf0, 0xbd, 0xfc, 0xf6, 0x0b, 0xf1, 0x57,
	0x56, 0x83, 0x39, 0xa4, 0xd2, 0x55, 0x79, 0xb3, 0xc9, 0x9a, 0xec, 0x5e, 0xbb, 0xde, 0x1d, 0xa9,
	0x4f, 0x09, 0xbe, 0x4f, 0xfe, 0x17, 0x00, 0x00, 0xff, 0xff, 0x69, 0xd7, 0x64, 0xcf, 0x63, 0x1b,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CoinWalletClient is the client API for CoinWallet service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CoinWalletClient interface {
	//获取最新区块信息
	GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error)
	//获取tx 信息
	GetTxinfo(ctx context.Context, in *GetTxinfoRequest, opts ...grpc.CallOption) (*GetTxinfoResponse, error)
	//生成地址
	GetNewAddress(ctx context.Context, in *GetNewAddressRequest, opts ...grpc.CallOption) (*GetNewAddressResponse, error)
	//验证地址
	ValidateAddress(ctx context.Context, in *ValidateAddressRequest, opts ...grpc.CallOption) (*ValidateAddressResponse, error)
	//发币
	SendTo(ctx context.Context, in *SendToRequest, opts ...grpc.CallOption) (*SendToResponse, error)
	SendToMany(ctx context.Context, in *SendToManyRequest, opts ...grpc.CallOption) (*SendToManyResponse, error)
	//获取地址余额
	GetBalanceByAddress(ctx context.Context, in *GetBalanceByAddressRequest, opts ...grpc.CallOption) (*GetBalanceByAddressResponse, error)
	//获取钱包余额
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	//添加钱包地址监控链上tx
	AddMonitorAddress(ctx context.Context, in *AddMonitorAddressRequest, opts ...grpc.CallOption) (*AddMonitorAddressResponse, error)
	//移除钱包地址监控
	RemoveMonitorAddress(ctx context.Context, in *RemoveMonitorAddressRequest, opts ...grpc.CallOption) (*RemoveMonitorAddressResponse, error)
	//监控事件回调
	SetCallback(ctx context.Context, in *SetCallbackRequest, opts ...grpc.CallOption) (*SetCallbackResponse, error)
	//获取当前预估费率
	GetEstimateFee(ctx context.Context, in *GetEstimateFeeRequest, opts ...grpc.CallOption) (*GetEstimateFeeResponse, error)
	//钱包私钥特征，用于验证钱包内记录账目的地址和链上的地址是一致的
	GetMnemonicFingerprinting(ctx context.Context, in *GetMnemonicFingerprintingRequest, opts ...grpc.CallOption) (*GetMnemonicFingerprintingResponse, error)
	//导入钱包并返回地址信息
	ImportPrivateKey(ctx context.Context, in *ImportPrivateKeyRequest, opts ...grpc.CallOption) (*ImportPrivateKeyResponse, error)
}

type coinWalletClient struct {
	cc *grpc.ClientConn
}

func NewCoinWalletClient(cc *grpc.ClientConn) CoinWalletClient {
	return &coinWalletClient{cc}
}

func (c *coinWalletClient) GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error) {
	out := new(GetBlockInfoResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/GetBlockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) GetTxinfo(ctx context.Context, in *GetTxinfoRequest, opts ...grpc.CallOption) (*GetTxinfoResponse, error) {
	out := new(GetTxinfoResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/GetTxinfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) GetNewAddress(ctx context.Context, in *GetNewAddressRequest, opts ...grpc.CallOption) (*GetNewAddressResponse, error) {
	out := new(GetNewAddressResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/GetNewAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) ValidateAddress(ctx context.Context, in *ValidateAddressRequest, opts ...grpc.CallOption) (*ValidateAddressResponse, error) {
	out := new(ValidateAddressResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/ValidateAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) SendTo(ctx context.Context, in *SendToRequest, opts ...grpc.CallOption) (*SendToResponse, error) {
	out := new(SendToResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/SendTo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) SendToMany(ctx context.Context, in *SendToManyRequest, opts ...grpc.CallOption) (*SendToManyResponse, error) {
	out := new(SendToManyResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/SendToMany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) GetBalanceByAddress(ctx context.Context, in *GetBalanceByAddressRequest, opts ...grpc.CallOption) (*GetBalanceByAddressResponse, error) {
	out := new(GetBalanceByAddressResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/GetBalanceByAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) AddMonitorAddress(ctx context.Context, in *AddMonitorAddressRequest, opts ...grpc.CallOption) (*AddMonitorAddressResponse, error) {
	out := new(AddMonitorAddressResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/AddMonitorAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) RemoveMonitorAddress(ctx context.Context, in *RemoveMonitorAddressRequest, opts ...grpc.CallOption) (*RemoveMonitorAddressResponse, error) {
	out := new(RemoveMonitorAddressResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/RemoveMonitorAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) SetCallback(ctx context.Context, in *SetCallbackRequest, opts ...grpc.CallOption) (*SetCallbackResponse, error) {
	out := new(SetCallbackResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/SetCallback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) GetEstimateFee(ctx context.Context, in *GetEstimateFeeRequest, opts ...grpc.CallOption) (*GetEstimateFeeResponse, error) {
	out := new(GetEstimateFeeResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/GetEstimateFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) GetMnemonicFingerprinting(ctx context.Context, in *GetMnemonicFingerprintingRequest, opts ...grpc.CallOption) (*GetMnemonicFingerprintingResponse, error) {
	out := new(GetMnemonicFingerprintingResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/GetMnemonicFingerprinting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinWalletClient) ImportPrivateKey(ctx context.Context, in *ImportPrivateKeyRequest, opts ...grpc.CallOption) (*ImportPrivateKeyResponse, error) {
	out := new(ImportPrivateKeyResponse)
	err := c.cc.Invoke(ctx, "/coinwallet.api.CoinWallet/ImportPrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoinWalletServer is the server API for CoinWallet service.
type CoinWalletServer interface {
	//获取最新区块信息
	GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoResponse, error)
	//获取tx 信息
	GetTxinfo(context.Context, *GetTxinfoRequest) (*GetTxinfoResponse, error)
	//生成地址
	GetNewAddress(context.Context, *GetNewAddressRequest) (*GetNewAddressResponse, error)
	//验证地址
	ValidateAddress(context.Context, *ValidateAddressRequest) (*ValidateAddressResponse, error)
	//发币
	SendTo(context.Context, *SendToRequest) (*SendToResponse, error)
	SendToMany(context.Context, *SendToManyRequest) (*SendToManyResponse, error)
	//获取地址余额
	GetBalanceByAddress(context.Context, *GetBalanceByAddressRequest) (*GetBalanceByAddressResponse, error)
	//获取钱包余额
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	//添加钱包地址监控链上tx
	AddMonitorAddress(context.Context, *AddMonitorAddressRequest) (*AddMonitorAddressResponse, error)
	//移除钱包地址监控
	RemoveMonitorAddress(context.Context, *RemoveMonitorAddressRequest) (*RemoveMonitorAddressResponse, error)
	//监控事件回调
	SetCallback(context.Context, *SetCallbackRequest) (*SetCallbackResponse, error)
	//获取当前预估费率
	GetEstimateFee(context.Context, *GetEstimateFeeRequest) (*GetEstimateFeeResponse, error)
	//钱包私钥特征，用于验证钱包内记录账目的地址和链上的地址是一致的
	GetMnemonicFingerprinting(context.Context, *GetMnemonicFingerprintingRequest) (*GetMnemonicFingerprintingResponse, error)
	//导入钱包并返回地址信息
	ImportPrivateKey(context.Context, *ImportPrivateKeyRequest) (*ImportPrivateKeyResponse, error)
}

// UnimplementedCoinWalletServer can be embedded to have forward compatible implementations.
type UnimplementedCoinWalletServer struct {
}

func (*UnimplementedCoinWalletServer) GetBlockInfo(ctx context.Context, req *GetBlockInfoRequest) (*GetBlockInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}
func (*UnimplementedCoinWalletServer) GetTxinfo(ctx context.Context, req *GetTxinfoRequest) (*GetTxinfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxinfo not implemented")
}
func (*UnimplementedCoinWalletServer) GetNewAddress(ctx context.Context, req *GetNewAddressRequest) (*GetNewAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNewAddress not implemented")
}
func (*UnimplementedCoinWalletServer) ValidateAddress(ctx context.Context, req *ValidateAddressRequest) (*ValidateAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAddress not implemented")
}
func (*UnimplementedCoinWalletServer) SendTo(ctx context.Context, req *SendToRequest) (*SendToResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTo not implemented")
}
func (*UnimplementedCoinWalletServer) SendToMany(ctx context.Context, req *SendToManyRequest) (*SendToManyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendToMany not implemented")
}
func (*UnimplementedCoinWalletServer) GetBalanceByAddress(ctx context.Context, req *GetBalanceByAddressRequest) (*GetBalanceByAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalanceByAddress not implemented")
}
func (*UnimplementedCoinWalletServer) GetBalance(ctx context.Context, req *GetBalanceRequest) (*GetBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (*UnimplementedCoinWalletServer) AddMonitorAddress(ctx context.Context, req *AddMonitorAddressRequest) (*AddMonitorAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMonitorAddress not implemented")
}
func (*UnimplementedCoinWalletServer) RemoveMonitorAddress(ctx context.Context, req *RemoveMonitorAddressRequest) (*RemoveMonitorAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveMonitorAddress not implemented")
}
func (*UnimplementedCoinWalletServer) SetCallback(ctx context.Context, req *SetCallbackRequest) (*SetCallbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCallback not implemented")
}
func (*UnimplementedCoinWalletServer) GetEstimateFee(ctx context.Context, req *GetEstimateFeeRequest) (*GetEstimateFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEstimateFee not implemented")
}
func (*UnimplementedCoinWalletServer) GetMnemonicFingerprinting(ctx context.Context, req *GetMnemonicFingerprintingRequest) (*GetMnemonicFingerprintingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMnemonicFingerprinting not implemented")
}
func (*UnimplementedCoinWalletServer) ImportPrivateKey(ctx context.Context, req *ImportPrivateKeyRequest) (*ImportPrivateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportPrivateKey not implemented")
}

func RegisterCoinWalletServer(s *grpc.Server, srv CoinWalletServer) {
	s.RegisterService(&_CoinWallet_serviceDesc, srv)
}

func _CoinWallet_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/GetBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).GetBlockInfo(ctx, req.(*GetBlockInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_GetTxinfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxinfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).GetTxinfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/GetTxinfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).GetTxinfo(ctx, req.(*GetTxinfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_GetNewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNewAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).GetNewAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/GetNewAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).GetNewAddress(ctx, req.(*GetNewAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_ValidateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).ValidateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/ValidateAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).ValidateAddress(ctx, req.(*ValidateAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_SendTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendToRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).SendTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/SendTo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).SendTo(ctx, req.(*SendToRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_SendToMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendToManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).SendToMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/SendToMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).SendToMany(ctx, req.(*SendToManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_GetBalanceByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceByAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).GetBalanceByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/GetBalanceByAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).GetBalanceByAddress(ctx, req.(*GetBalanceByAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_AddMonitorAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMonitorAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).AddMonitorAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/AddMonitorAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).AddMonitorAddress(ctx, req.(*AddMonitorAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_RemoveMonitorAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMonitorAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).RemoveMonitorAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/RemoveMonitorAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).RemoveMonitorAddress(ctx, req.(*RemoveMonitorAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_SetCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).SetCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/SetCallback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).SetCallback(ctx, req.(*SetCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_GetEstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEstimateFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).GetEstimateFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/GetEstimateFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).GetEstimateFee(ctx, req.(*GetEstimateFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_GetMnemonicFingerprinting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMnemonicFingerprintingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).GetMnemonicFingerprinting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/GetMnemonicFingerprinting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).GetMnemonicFingerprinting(ctx, req.(*GetMnemonicFingerprintingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoinWallet_ImportPrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportPrivateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinWalletServer).ImportPrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinwallet.api.CoinWallet/ImportPrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinWalletServer).ImportPrivateKey(ctx, req.(*ImportPrivateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CoinWallet_serviceDesc = grpc.ServiceDesc{
	ServiceName: "coinwallet.api.CoinWallet",
	HandlerType: (*CoinWalletServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlockInfo",
			Handler:    _CoinWallet_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetTxinfo",
			Handler:    _CoinWallet_GetTxinfo_Handler,
		},
		{
			MethodName: "GetNewAddress",
			Handler:    _CoinWallet_GetNewAddress_Handler,
		},
		{
			MethodName: "ValidateAddress",
			Handler:    _CoinWallet_ValidateAddress_Handler,
		},
		{
			MethodName: "SendTo",
			Handler:    _CoinWallet_SendTo_Handler,
		},
		{
			MethodName: "SendToMany",
			Handler:    _CoinWallet_SendToMany_Handler,
		},
		{
			MethodName: "GetBalanceByAddress",
			Handler:    _CoinWallet_GetBalanceByAddress_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _CoinWallet_GetBalance_Handler,
		},
		{
			MethodName: "AddMonitorAddress",
			Handler:    _CoinWallet_AddMonitorAddress_Handler,
		},
		{
			MethodName: "RemoveMonitorAddress",
			Handler:    _CoinWallet_RemoveMonitorAddress_Handler,
		},
		{
			MethodName: "SetCallback",
			Handler:    _CoinWallet_SetCallback_Handler,
		},
		{
			MethodName: "GetEstimateFee",
			Handler:    _CoinWallet_GetEstimateFee_Handler,
		},
		{
			MethodName: "GetMnemonicFingerprinting",
			Handler:    _CoinWallet_GetMnemonicFingerprinting_Handler,
		},
		{
			MethodName: "ImportPrivateKey",
			Handler:    _CoinWallet_ImportPrivateKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coinwallet.proto",
}

func (m *CoinInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidDecimal != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.ValidDecimal))
		i--
		dAtA[i] = 0x38
	}
	if m.Decimal != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.Decimal))
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinAddr) > 0 {
		i -= len(m.CoinAddr)
		copy(dAtA[i:], m.CoinAddr)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.CoinAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cid != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTxinfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxinfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxinfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Side) > 0 {
		i -= len(m.Side)
		copy(dAtA[i:], m.Side)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Side)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Confirm != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.Confirm))
		i--
		dAtA[i] = 0x78
	}
	if m.BlockTime != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x70
	}
	if m.BlockNum != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x68
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x62
	}
	if m.FeeCoin != nil {
		{
			size, err := m.FeeCoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Fee) > 0 {
		i -= len(m.Fee)
		copy(dAtA[i:], m.Fee)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Fee)))
		i--
		dAtA[i] = 0x52
	}
	if m.OutNum != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.OutNum))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x3a
	}
	if m.OutN != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.OutN))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Coin != nil {
		{
			size, err := m.Coin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTxinfoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxinfoResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxinfoResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tx) > 0 {
		for iNdEx := len(m.Tx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetTxinfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxinfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxinfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetNewAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNewAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetNewAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HdPath) > 0 {
		i -= len(m.HdPath)
		copy(dAtA[i:], m.HdPath)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.HdPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetNewAddressResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNewAddressResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetNewAddressResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetNewAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNewAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetNewAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAddressResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAddressResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAddressResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsValidate {
		i--
		if m.IsValidate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendToRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendToRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendToRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pool) > 0 {
		for iNdEx := len(m.Pool) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Pool[iNdEx])
			copy(dAtA[i:], m.Pool[iNdEx])
			i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Pool[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.FeeCoin != nil {
		{
			size, err := m.FeeCoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Fee) > 0 {
		i -= len(m.Fee)
		copy(dAtA[i:], m.Fee)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Fee)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.Coin != nil {
		{
			size, err := m.Coin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendToResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendToResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendToResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendToResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendToResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendToResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AAReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AAReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AAReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FeeLimit) > 0 {
		i -= len(m.FeeLimit)
		copy(dAtA[i:], m.FeeLimit)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.FeeLimit)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Fee) > 0 {
		i -= len(m.Fee)
		copy(dAtA[i:], m.Fee)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Fee)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FeeRate) > 0 {
		i -= len(m.FeeRate)
		copy(dAtA[i:], m.FeeRate)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.FeeRate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AARep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AARep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AARep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendToManyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendToManyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendToManyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pool) > 0 {
		for iNdEx := len(m.Pool) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Pool[iNdEx])
			copy(dAtA[i:], m.Pool[iNdEx])
			i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Pool[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.FeeCoin != nil {
		{
			size, err := m.FeeCoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ChangeAddress) > 0 {
		i -= len(m.ChangeAddress)
		copy(dAtA[i:], m.ChangeAddress)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ChangeAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Obj) > 0 {
		for iNdEx := len(m.Obj) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Obj[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Coin != nil {
		{
			size, err := m.Coin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendToManyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendToManyResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendToManyResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Obj) > 0 {
		for iNdEx := len(m.Obj) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Obj[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SendToManyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendToManyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendToManyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if m.BlockTime != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockNum != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Coin != nil {
		{
			size, err := m.Coin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlockNumOrHash) > 0 {
		i -= len(m.BlockNumOrHash)
		copy(dAtA[i:], m.BlockNumOrHash)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.BlockNumOrHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockInfoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockInfoResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockInfoResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceByAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceByAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceByAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SafeConfirmNum != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.SafeConfirmNum))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceByAddressResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceByAddressResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceByAddressResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if m.Coin != nil {
		{
			size, err := m.Coin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceByAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceByAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceByAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SafeConfirmNum != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.SafeConfirmNum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if m.Coin != nil {
		{
			size, err := m.Coin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMonitorAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMonitorAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMonitorAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMonitorAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMonitorAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMonitorAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveMonitorAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveMonitorAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveMonitorAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveMonitorAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveMonitorAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveMonitorAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCallbackRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCallbackRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCallbackRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Event) > 0 {
		i -= len(m.Event)
		copy(dAtA[i:], m.Event)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Event)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCallbackResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCallbackResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCallbackResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetEstimateFeeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEstimateFeeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetEstimateFeeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConfirmTargets) > 0 {
		dAtA12 := make([]byte, len(m.ConfirmTargets)*10)
		var j11 int
		for _, num1 := range m.ConfirmTargets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintCoinwallet(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeeRate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeRate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeRate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfirmTarget != 0 {
		i = encodeVarintCoinwallet(dAtA, i, uint64(m.ConfirmTarget))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UnitPrice) > 0 {
		i -= len(m.UnitPrice)
		copy(dAtA[i:], m.UnitPrice)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.UnitPrice)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetEstimateFeeResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEstimateFeeResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetEstimateFeeResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FeeCoin != nil {
		{
			size, err := m.FeeCoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoinwallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetEstimateFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEstimateFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetEstimateFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMnemonicFingerprintingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMnemonicFingerprintingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMnemonicFingerprintingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetMnemonicFingerprintingResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMnemonicFingerprintingResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMnemonicFingerprintingResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fingerprinting) > 0 {
		i -= len(m.Fingerprinting)
		copy(dAtA[i:], m.Fingerprinting)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Fingerprinting)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMnemonicFingerprintingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMnemonicFingerprintingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMnemonicFingerprintingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImportPrivateKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportPrivateKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportPrivateKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HdPath) > 0 {
		i -= len(m.HdPath)
		copy(dAtA[i:], m.HdPath)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.HdPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImportPrivateKeyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportPrivateKeyResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportPrivateKeyResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImportPrivateKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportPrivateKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportPrivateKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrNo) > 0 {
		i -= len(m.ErrNo)
		copy(dAtA[i:], m.ErrNo)
		i = encodeVarintCoinwallet(dAtA, i, uint64(len(m.ErrNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlockHead) > 0 {
		for iNdEx := len(m.BlockHead) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockHead[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for iNdEx := len(m.Txs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Txs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoinwallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCoinwallet(dAtA []byte, offset int, v uint64) int {
	offset -= sovCoinwallet(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CoinInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cid != 0 {
		n += 1 + sovCoinwallet(uint64(m.Cid))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.CoinAddr)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.Decimal != 0 {
		n += 1 + sovCoinwallet(uint64(m.Decimal))
	}
	if m.ValidDecimal != 0 {
		n += 1 + sovCoinwallet(uint64(m.ValidDecimal))
	}
	return n
}

func (m *GetTxinfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *TxInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != nil {
		l = m.Coin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.OutN != 0 {
		n += 1 + sovCoinwallet(uint64(m.OutN))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.OutNum != 0 {
		n += 1 + sovCoinwallet(uint64(m.OutNum))
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.FeeCoin != nil {
		l = m.FeeCoin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sovCoinwallet(uint64(m.BlockNum))
	}
	if m.BlockTime != 0 {
		n += 1 + sovCoinwallet(uint64(m.BlockTime))
	}
	if m.Confirm != 0 {
		n += 1 + sovCoinwallet(uint64(m.Confirm))
	}
	l = len(m.Side)
	if l > 0 {
		n += 2 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetTxinfoResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tx) > 0 {
		for _, e := range m.Tx {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *GetTxinfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *GetNewAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HdPath)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetNewAddressResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetNewAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *ValidateAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *ValidateAddressResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsValidate {
		n += 2
	}
	return n
}

func (m *ValidateAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *SendToRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != nil {
		l = m.Coin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.FeeCoin != nil {
		l = m.FeeCoin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Pool) > 0 {
		for _, s := range m.Pool {
			l = len(s)
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *SendToResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *SendToResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *AAReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.FeeRate)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.FeeLimit)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *AARep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *SendToManyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != nil {
		l = m.Coin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Obj) > 0 {
		for _, e := range m.Obj {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	l = len(m.ChangeAddress)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.FeeCoin != nil {
		l = m.FeeCoin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Pool) > 0 {
		for _, s := range m.Pool {
			l = len(s)
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *SendToManyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Obj) > 0 {
		for _, e := range m.Obj {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *SendToManyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *BlockHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != nil {
		l = m.Coin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sovCoinwallet(uint64(m.BlockNum))
	}
	if m.BlockTime != 0 {
		n += 1 + sovCoinwallet(uint64(m.BlockTime))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetBlockInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockNumOrHash)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetBlockInfoResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetBlockInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *GetBalanceByAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.SafeConfirmNum != 0 {
		n += 1 + sovCoinwallet(uint64(m.SafeConfirmNum))
	}
	return n
}

func (m *GetBalanceByAddressResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != nil {
		l = m.Coin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetBalanceByAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *GetBalanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	if m.SafeConfirmNum != 0 {
		n += 1 + sovCoinwallet(uint64(m.SafeConfirmNum))
	}
	return n
}

func (m *GetBalanceResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != nil {
		l = m.Coin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetBalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *AddMonitorAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *AddMonitorAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *RemoveMonitorAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *RemoveMonitorAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *SetCallbackRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Event)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *SetCallbackResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetEstimateFeeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConfirmTargets) > 0 {
		l = 0
		for _, e := range m.ConfirmTargets {
			l += sovCoinwallet(uint64(e))
		}
		n += 1 + sovCoinwallet(uint64(l)) + l
	}
	return n
}

func (m *FeeRate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UnitPrice)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if m.ConfirmTarget != 0 {
		n += 1 + sovCoinwallet(uint64(m.ConfirmTarget))
	}
	return n
}

func (m *GetEstimateFeeResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	if m.FeeCoin != nil {
		l = m.FeeCoin.Size()
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetEstimateFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *GetMnemonicFingerprintingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetMnemonicFingerprintingResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fingerprinting)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *GetMnemonicFingerprintingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *ImportPrivateKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HdPath)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *ImportPrivateKeyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	return n
}

func (m *ImportPrivateKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrNo)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoinwallet(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *EventBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BlockHead) > 0 {
		for _, e := range m.BlockHead {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func (m *EventTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovCoinwallet(uint64(l))
		}
	}
	return n
}

func sovCoinwallet(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCoinwallet(x uint64) (n int) {
	return sovCoinwallet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CoinInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidDecimal", wireType)
			}
			m.ValidDecimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidDecimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxinfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxinfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxinfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coin == nil {
				m.Coin = &CoinInfo{}
			}
			if err := m.Coin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutN", wireType)
			}
			m.OutN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutN |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutNum", wireType)
			}
			m.OutNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeCoin == nil {
				m.FeeCoin = &CoinInfo{}
			}
			if err := m.FeeCoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirm", wireType)
			}
			m.Confirm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confirm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Side = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxinfoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxinfoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxinfoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = append(m.Tx, &TxInfo{})
			if err := m.Tx[len(m.Tx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxinfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxinfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxinfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &GetTxinfoResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNewAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNewAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNewAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HdPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HdPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNewAddressResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNewAddressResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNewAddressResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNewAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNewAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNewAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &GetNewAddressResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAddressResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAddressResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAddressResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValidate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValidate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ValidateAddressResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendToRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendToRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendToRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coin == nil {
				m.Coin = &CoinInfo{}
			}
			if err := m.Coin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeCoin == nil {
				m.FeeCoin = &CoinInfo{}
			}
			if err := m.FeeCoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = append(m.Pool, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendToResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendToResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendToResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendToResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendToResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendToResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &SendToResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AAReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AAReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AAReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AARep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AARep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AARep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendToManyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendToManyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendToManyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coin == nil {
				m.Coin = &CoinInfo{}
			}
			if err := m.Coin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Obj = append(m.Obj, &AAReq{})
			if err := m.Obj[len(m.Obj)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeCoin == nil {
				m.FeeCoin = &CoinInfo{}
			}
			if err := m.FeeCoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = append(m.Pool, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendToManyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendToManyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendToManyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Obj = append(m.Obj, &AARep{})
			if err := m.Obj[len(m.Obj)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendToManyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendToManyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendToManyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &SendToManyResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coin == nil {
				m.Coin = &CoinInfo{}
			}
			if err := m.Coin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumOrHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockNumOrHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockInfoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockInfoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockInfoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &BlockHead{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &GetBlockInfoResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceByAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceByAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceByAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, &CoinInfo{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeConfirmNum", wireType)
			}
			m.SafeConfirmNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeConfirmNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceByAddressResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceByAddressResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceByAddressResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coin == nil {
				m.Coin = &CoinInfo{}
			}
			if err := m.Coin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceByAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceByAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceByAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &GetBalanceByAddressResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, &CoinInfo{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeConfirmNum", wireType)
			}
			m.SafeConfirmNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeConfirmNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coin == nil {
				m.Coin = &CoinInfo{}
			}
			if err := m.Coin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &GetBalanceResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMonitorAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMonitorAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMonitorAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMonitorAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMonitorAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMonitorAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveMonitorAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveMonitorAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveMonitorAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveMonitorAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveMonitorAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveMonitorAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCallbackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCallbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCallbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCallbackResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCallbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCallbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEstimateFeeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEstimateFeeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEstimateFeeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoinwallet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ConfirmTargets = append(m.ConfirmTargets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoinwallet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCoinwallet
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCoinwallet
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ConfirmTargets) == 0 {
					m.ConfirmTargets = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCoinwallet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ConfirmTargets = append(m.ConfirmTargets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmTargets", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeRate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeRate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeRate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmTarget", wireType)
			}
			m.ConfirmTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmTarget |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEstimateFeeResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEstimateFeeResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEstimateFeeResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, &FeeRate{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeCoin == nil {
				m.FeeCoin = &CoinInfo{}
			}
			if err := m.FeeCoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEstimateFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEstimateFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEstimateFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &GetEstimateFeeResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMnemonicFingerprintingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMnemonicFingerprintingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMnemonicFingerprintingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMnemonicFingerprintingResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMnemonicFingerprintingResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMnemonicFingerprintingResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprinting", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fingerprinting = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMnemonicFingerprintingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMnemonicFingerprintingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMnemonicFingerprintingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &GetMnemonicFingerprintingResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportPrivateKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportPrivateKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportPrivateKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HdPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HdPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportPrivateKeyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportPrivateKeyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportPrivateKeyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportPrivateKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportPrivateKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportPrivateKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ImportPrivateKeyResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHead = append(m.BlockHead, &BlockHead{})
			if err := m.BlockHead[len(m.BlockHead)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoinwallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, &TxInfo{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoinwallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCoinwallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoinwallet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoinwallet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoinwallet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCoinwallet
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCoinwallet
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCoinwallet
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCoinwallet        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoinwallet          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCoinwallet = fmt.Errorf("proto: unexpected end of group")
)
