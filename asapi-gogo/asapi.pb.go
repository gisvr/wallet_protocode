// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: asapi.proto

package pbasapi

import (
	context "context"
	fmt "fmt"
	bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time "github.com/gisvr/golib/time"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ListAllCoinRequest struct {
}

func (m *ListAllCoinRequest) Reset()         { *m = ListAllCoinRequest{} }
func (m *ListAllCoinRequest) String() string { return proto.CompactTextString(m) }
func (*ListAllCoinRequest) ProtoMessage()    {}
func (*ListAllCoinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{0}
}
func (m *ListAllCoinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllCoinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllCoinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllCoinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllCoinRequest.Merge(m, src)
}
func (m *ListAllCoinRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAllCoinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllCoinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllCoinRequest proto.InternalMessageInfo

type CoinAsset struct {
	Coin                string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	DisplayCode         string `protobuf:"bytes,2,opt,name=display_code,json=displayCode,proto3" json:"display_code,omitempty"`
	Description         string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Decimal             int32  `protobuf:"varint,4,opt,name=decimal,proto3" json:"decimal,omitempty"`
	CanDeposit          bool   `protobuf:"varint,5,opt,name=can_deposit,json=canDeposit,proto3" json:"can_deposit,omitempty"`
	CanWithdraw         bool   `protobuf:"varint,6,opt,name=can_withdraw,json=canWithdraw,proto3" json:"can_withdraw,omitempty"`
	Balance             string `protobuf:"bytes,7,opt,name=balance,proto3" json:"balance,omitempty"`
	AbsBalance          string `protobuf:"bytes,8,opt,name=abs_balance,json=absBalance,proto3" json:"abs_balance,omitempty"`
	FeeCoin             string `protobuf:"bytes,9,opt,name=fee_coin,json=feeCoin,proto3" json:"fee_coin,omitempty"`
	AbsEstimateFee      string `protobuf:"bytes,10,opt,name=abs_estimate_fee,json=absEstimateFee,proto3" json:"abs_estimate_fee,omitempty"`
	ConfirmingThreshold int32  `protobuf:"varint,11,opt,name=confirming_threshold,json=confirmingThreshold,proto3" json:"confirming_threshold,omitempty"`
	DustThreshold       int32  `protobuf:"varint,12,opt,name=dust_threshold,json=dustThreshold,proto3" json:"dust_threshold,omitempty"`
	TokenAddress        string `protobuf:"bytes,13,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
	RequireMemo         string `protobuf:"bytes,14,opt,name=require_memo,json=requireMemo,proto3" json:"require_memo,omitempty"`
}

func (m *CoinAsset) Reset()         { *m = CoinAsset{} }
func (m *CoinAsset) String() string { return proto.CompactTextString(m) }
func (*CoinAsset) ProtoMessage()    {}
func (*CoinAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{1}
}
func (m *CoinAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinAsset.Merge(m, src)
}
func (m *CoinAsset) XXX_Size() int {
	return m.Size()
}
func (m *CoinAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinAsset.DiscardUnknown(m)
}

var xxx_messageInfo_CoinAsset proto.InternalMessageInfo

func (m *CoinAsset) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *CoinAsset) GetDisplayCode() string {
	if m != nil {
		return m.DisplayCode
	}
	return ""
}

func (m *CoinAsset) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CoinAsset) GetDecimal() int32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

func (m *CoinAsset) GetCanDeposit() bool {
	if m != nil {
		return m.CanDeposit
	}
	return false
}

func (m *CoinAsset) GetCanWithdraw() bool {
	if m != nil {
		return m.CanWithdraw
	}
	return false
}

func (m *CoinAsset) GetBalance() string {
	if m != nil {
		return m.Balance
	}
	return ""
}

func (m *CoinAsset) GetAbsBalance() string {
	if m != nil {
		return m.AbsBalance
	}
	return ""
}

func (m *CoinAsset) GetFeeCoin() string {
	if m != nil {
		return m.FeeCoin
	}
	return ""
}

func (m *CoinAsset) GetAbsEstimateFee() string {
	if m != nil {
		return m.AbsEstimateFee
	}
	return ""
}

func (m *CoinAsset) GetConfirmingThreshold() int32 {
	if m != nil {
		return m.ConfirmingThreshold
	}
	return 0
}

func (m *CoinAsset) GetDustThreshold() int32 {
	if m != nil {
		return m.DustThreshold
	}
	return 0
}

func (m *CoinAsset) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

func (m *CoinAsset) GetRequireMemo() string {
	if m != nil {
		return m.RequireMemo
	}
	return ""
}

type ListAllCoinResult struct {
	Name   string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Assets []*CoinAsset `protobuf:"bytes,2,rep,name=assets,proto3" json:"assets,omitempty"`
}

func (m *ListAllCoinResult) Reset()         { *m = ListAllCoinResult{} }
func (m *ListAllCoinResult) String() string { return proto.CompactTextString(m) }
func (*ListAllCoinResult) ProtoMessage()    {}
func (*ListAllCoinResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{2}
}
func (m *ListAllCoinResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllCoinResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllCoinResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllCoinResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllCoinResult.Merge(m, src)
}
func (m *ListAllCoinResult) XXX_Size() int {
	return m.Size()
}
func (m *ListAllCoinResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllCoinResult.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllCoinResult proto.InternalMessageInfo

func (m *ListAllCoinResult) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListAllCoinResult) GetAssets() []*CoinAsset {
	if m != nil {
		return m.Assets
	}
	return nil
}

type ListAllCoinResponse struct {
	Success          bool                 `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32                `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string               `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           []*ListAllCoinResult `protobuf:"bytes,4,rep,name=result,proto3" json:"result"`
}

func (m *ListAllCoinResponse) Reset()         { *m = ListAllCoinResponse{} }
func (m *ListAllCoinResponse) String() string { return proto.CompactTextString(m) }
func (*ListAllCoinResponse) ProtoMessage()    {}
func (*ListAllCoinResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{3}
}
func (m *ListAllCoinResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllCoinResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllCoinResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllCoinResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllCoinResponse.Merge(m, src)
}
func (m *ListAllCoinResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAllCoinResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllCoinResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllCoinResponse proto.InternalMessageInfo

func (m *ListAllCoinResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ListAllCoinResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ListAllCoinResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *ListAllCoinResponse) GetResult() []*ListAllCoinResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type GetCoinInfoRequest struct {
	Coin string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
}

func (m *GetCoinInfoRequest) Reset()         { *m = GetCoinInfoRequest{} }
func (m *GetCoinInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetCoinInfoRequest) ProtoMessage()    {}
func (*GetCoinInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{4}
}
func (m *GetCoinInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCoinInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCoinInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCoinInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCoinInfoRequest.Merge(m, src)
}
func (m *GetCoinInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCoinInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCoinInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCoinInfoRequest proto.InternalMessageInfo

func (m *GetCoinInfoRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

type GetCoinInfoResponse struct {
	Success          bool       `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32      `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string     `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           *CoinAsset `protobuf:"bytes,4,opt,name=result,proto3" json:"result"`
}

func (m *GetCoinInfoResponse) Reset()         { *m = GetCoinInfoResponse{} }
func (m *GetCoinInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetCoinInfoResponse) ProtoMessage()    {}
func (*GetCoinInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{5}
}
func (m *GetCoinInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCoinInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCoinInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCoinInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCoinInfoResponse.Merge(m, src)
}
func (m *GetCoinInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCoinInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCoinInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCoinInfoResponse proto.InternalMessageInfo

func (m *GetCoinInfoResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *GetCoinInfoResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *GetCoinInfoResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *GetCoinInfoResponse) GetResult() *CoinAsset {
	if m != nil {
		return m.Result
	}
	return nil
}

type NewDepositAddressRequest struct {
	Coin string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
}

func (m *NewDepositAddressRequest) Reset()         { *m = NewDepositAddressRequest{} }
func (m *NewDepositAddressRequest) String() string { return proto.CompactTextString(m) }
func (*NewDepositAddressRequest) ProtoMessage()    {}
func (*NewDepositAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{6}
}
func (m *NewDepositAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewDepositAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewDepositAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewDepositAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewDepositAddressRequest.Merge(m, src)
}
func (m *NewDepositAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *NewDepositAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewDepositAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewDepositAddressRequest proto.InternalMessageInfo

func (m *NewDepositAddressRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

type NewDepositAddressResult struct {
	Coin    string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *NewDepositAddressResult) Reset()         { *m = NewDepositAddressResult{} }
func (m *NewDepositAddressResult) String() string { return proto.CompactTextString(m) }
func (*NewDepositAddressResult) ProtoMessage()    {}
func (*NewDepositAddressResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{7}
}
func (m *NewDepositAddressResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewDepositAddressResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewDepositAddressResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewDepositAddressResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewDepositAddressResult.Merge(m, src)
}
func (m *NewDepositAddressResult) XXX_Size() int {
	return m.Size()
}
func (m *NewDepositAddressResult) XXX_DiscardUnknown() {
	xxx_messageInfo_NewDepositAddressResult.DiscardUnknown(m)
}

var xxx_messageInfo_NewDepositAddressResult proto.InternalMessageInfo

func (m *NewDepositAddressResult) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *NewDepositAddressResult) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type NewDepositAddressResponse struct {
	Success          bool                     `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32                    `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string                   `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           *NewDepositAddressResult `protobuf:"bytes,4,opt,name=result,proto3" json:"result"`
}

func (m *NewDepositAddressResponse) Reset()         { *m = NewDepositAddressResponse{} }
func (m *NewDepositAddressResponse) String() string { return proto.CompactTextString(m) }
func (*NewDepositAddressResponse) ProtoMessage()    {}
func (*NewDepositAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{8}
}
func (m *NewDepositAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewDepositAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewDepositAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewDepositAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewDepositAddressResponse.Merge(m, src)
}
func (m *NewDepositAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *NewDepositAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NewDepositAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NewDepositAddressResponse proto.InternalMessageInfo

func (m *NewDepositAddressResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *NewDepositAddressResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *NewDepositAddressResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *NewDepositAddressResponse) GetResult() *NewDepositAddressResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type HasAddressRequest struct {
	Coin    string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *HasAddressRequest) Reset()         { *m = HasAddressRequest{} }
func (m *HasAddressRequest) String() string { return proto.CompactTextString(m) }
func (*HasAddressRequest) ProtoMessage()    {}
func (*HasAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{9}
}
func (m *HasAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasAddressRequest.Merge(m, src)
}
func (m *HasAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *HasAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HasAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HasAddressRequest proto.InternalMessageInfo

func (m *HasAddressRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *HasAddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type HasAddressResult struct {
	Coin    string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *HasAddressResult) Reset()         { *m = HasAddressResult{} }
func (m *HasAddressResult) String() string { return proto.CompactTextString(m) }
func (*HasAddressResult) ProtoMessage()    {}
func (*HasAddressResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{10}
}
func (m *HasAddressResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasAddressResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasAddressResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasAddressResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasAddressResult.Merge(m, src)
}
func (m *HasAddressResult) XXX_Size() int {
	return m.Size()
}
func (m *HasAddressResult) XXX_DiscardUnknown() {
	xxx_messageInfo_HasAddressResult.DiscardUnknown(m)
}

var xxx_messageInfo_HasAddressResult proto.InternalMessageInfo

func (m *HasAddressResult) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *HasAddressResult) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type HasAddressResponse struct {
	Success          bool              `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32             `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string            `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           *HasAddressResult `protobuf:"bytes,4,opt,name=result,proto3" json:"result"`
}

func (m *HasAddressResponse) Reset()         { *m = HasAddressResponse{} }
func (m *HasAddressResponse) String() string { return proto.CompactTextString(m) }
func (*HasAddressResponse) ProtoMessage()    {}
func (*HasAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{11}
}
func (m *HasAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasAddressResponse.Merge(m, src)
}
func (m *HasAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *HasAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HasAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HasAddressResponse proto.InternalMessageInfo

func (m *HasAddressResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *HasAddressResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *HasAddressResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *HasAddressResponse) GetResult() *HasAddressResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type CheckAddressRequest struct {
	Coin    string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *CheckAddressRequest) Reset()         { *m = CheckAddressRequest{} }
func (m *CheckAddressRequest) String() string { return proto.CompactTextString(m) }
func (*CheckAddressRequest) ProtoMessage()    {}
func (*CheckAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{12}
}
func (m *CheckAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckAddressRequest.Merge(m, src)
}
func (m *CheckAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckAddressRequest proto.InternalMessageInfo

func (m *CheckAddressRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *CheckAddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type CheckAddressResponse struct {
	Success          bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           bool   `protobuf:"varint,4,opt,name=result,proto3" json:"result"`
}

func (m *CheckAddressResponse) Reset()         { *m = CheckAddressResponse{} }
func (m *CheckAddressResponse) String() string { return proto.CompactTextString(m) }
func (*CheckAddressResponse) ProtoMessage()    {}
func (*CheckAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{13}
}
func (m *CheckAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckAddressResponse.Merge(m, src)
}
func (m *CheckAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckAddressResponse proto.InternalMessageInfo

func (m *CheckAddressResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CheckAddressResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *CheckAddressResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *CheckAddressResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type ListAllAddressRequest struct {
	Coin string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
}

func (m *ListAllAddressRequest) Reset()         { *m = ListAllAddressRequest{} }
func (m *ListAllAddressRequest) String() string { return proto.CompactTextString(m) }
func (*ListAllAddressRequest) ProtoMessage()    {}
func (*ListAllAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{14}
}
func (m *ListAllAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllAddressRequest.Merge(m, src)
}
func (m *ListAllAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAllAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllAddressRequest proto.InternalMessageInfo

func (m *ListAllAddressRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

type ListAllAddressResult struct {
	Coin    string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *ListAllAddressResult) Reset()         { *m = ListAllAddressResult{} }
func (m *ListAllAddressResult) String() string { return proto.CompactTextString(m) }
func (*ListAllAddressResult) ProtoMessage()    {}
func (*ListAllAddressResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{15}
}
func (m *ListAllAddressResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllAddressResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllAddressResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllAddressResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllAddressResult.Merge(m, src)
}
func (m *ListAllAddressResult) XXX_Size() int {
	return m.Size()
}
func (m *ListAllAddressResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllAddressResult.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllAddressResult proto.InternalMessageInfo

func (m *ListAllAddressResult) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *ListAllAddressResult) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ListAllAddressResponse struct {
	Success          bool                    `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32                   `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string                  `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           []*ListAllAddressResult `protobuf:"bytes,4,rep,name=result,proto3" json:"result"`
}

func (m *ListAllAddressResponse) Reset()         { *m = ListAllAddressResponse{} }
func (m *ListAllAddressResponse) String() string { return proto.CompactTextString(m) }
func (*ListAllAddressResponse) ProtoMessage()    {}
func (*ListAllAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{16}
}
func (m *ListAllAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllAddressResponse.Merge(m, src)
}
func (m *ListAllAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAllAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllAddressResponse proto.InternalMessageInfo

func (m *ListAllAddressResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ListAllAddressResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ListAllAddressResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *ListAllAddressResponse) GetResult() []*ListAllAddressResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type Txinfo struct {
	Coin                string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin"`
	DisplayCode         string `protobuf:"bytes,2,opt,name=display_code,json=displayCode,proto3" json:"display_code"`
	Description         string `protobuf:"bytes,3,opt,name=description,proto3" json:"description"`
	Decimal             int32  `protobuf:"varint,4,opt,name=decimal,proto3" json:"decimal"`
	Address             string `protobuf:"bytes,5,opt,name=address,proto3" json:"address"`
	Memo                string `protobuf:"bytes,6,opt,name=memo,proto3" json:"memo"`
	SourceAddress       string `protobuf:"bytes,7,opt,name=source_address,json=sourceAddress,proto3" json:"source_address"`
	SourceAddressDetail string `protobuf:"bytes,8,opt,name=source_address_detail,json=sourceAddressDetail,proto3" json:"source_address_detail"`
	Side                string `protobuf:"bytes,9,opt,name=side,proto3" json:"side"`
	Amount              string `protobuf:"bytes,10,opt,name=amount,proto3" json:"amount"`
	AbsAmount           string `protobuf:"bytes,11,opt,name=abs_amount,json=absAmount,proto3" json:"abs_amount"`
	AbsPlatformFee      string `protobuf:"bytes,12,opt,name=abs_platform_fee,json=absPlatformFee,proto3" json:"abs_platform_fee"`
	Txid                string `protobuf:"bytes,13,opt,name=txid,proto3" json:"txid"`
	VoutN               int64  `protobuf:"varint,14,opt,name=vout_n,json=voutN,proto3" json:"vout_n"`
	RequestId           string `protobuf:"bytes,15,opt,name=request_id,json=requestId,proto3" json:"request_id"`
	Status              string `protobuf:"bytes,16,opt,name=status,proto3" json:"status"`
	CreateTime          int64  `protobuf:"varint,17,opt,name=create_time,json=createTime,proto3" json:"create_time"`
	LastTime            int64  `protobuf:"varint,18,opt,name=last_time,json=lastTime,proto3" json:"last_time"`
	ConfirmingThreshold int32  `protobuf:"varint,19,opt,name=confirming_threshold,json=confirmingThreshold,proto3" json:"confirming_threshold"`
	ConfirmedNum        int32  `protobuf:"varint,20,opt,name=confirmed_num,json=confirmedNum,proto3" json:"confirmed_num"`
	FeeCoin             string `protobuf:"bytes,21,opt,name=fee_coin,json=feeCoin,proto3" json:"fee_coin"`
	FeeAmount           int64  `protobuf:"varint,22,opt,name=fee_amount,json=feeAmount,proto3" json:"fee_amount"`
	FeeDecimal          int32  `protobuf:"varint,23,opt,name=fee_decimal,json=feeDecimal,proto3" json:"fee_decimal"`
	Type                string `protobuf:"bytes,24,opt,name=type,proto3" json:"type"`
	Id                  string `protobuf:"bytes,25,opt,name=id,proto3" json:"id"`
}

func (m *Txinfo) Reset()         { *m = Txinfo{} }
func (m *Txinfo) String() string { return proto.CompactTextString(m) }
func (*Txinfo) ProtoMessage()    {}
func (*Txinfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{17}
}
func (m *Txinfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Txinfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Txinfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Txinfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Txinfo.Merge(m, src)
}
func (m *Txinfo) XXX_Size() int {
	return m.Size()
}
func (m *Txinfo) XXX_DiscardUnknown() {
	xxx_messageInfo_Txinfo.DiscardUnknown(m)
}

var xxx_messageInfo_Txinfo proto.InternalMessageInfo

func (m *Txinfo) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *Txinfo) GetDisplayCode() string {
	if m != nil {
		return m.DisplayCode
	}
	return ""
}

func (m *Txinfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Txinfo) GetDecimal() int32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

func (m *Txinfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Txinfo) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Txinfo) GetSourceAddress() string {
	if m != nil {
		return m.SourceAddress
	}
	return ""
}

func (m *Txinfo) GetSourceAddressDetail() string {
	if m != nil {
		return m.SourceAddressDetail
	}
	return ""
}

func (m *Txinfo) GetSide() string {
	if m != nil {
		return m.Side
	}
	return ""
}

func (m *Txinfo) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Txinfo) GetAbsAmount() string {
	if m != nil {
		return m.AbsAmount
	}
	return ""
}

func (m *Txinfo) GetAbsPlatformFee() string {
	if m != nil {
		return m.AbsPlatformFee
	}
	return ""
}

func (m *Txinfo) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *Txinfo) GetVoutN() int64 {
	if m != nil {
		return m.VoutN
	}
	return 0
}

func (m *Txinfo) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *Txinfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Txinfo) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Txinfo) GetLastTime() int64 {
	if m != nil {
		return m.LastTime
	}
	return 0
}

func (m *Txinfo) GetConfirmingThreshold() int32 {
	if m != nil {
		return m.ConfirmingThreshold
	}
	return 0
}

func (m *Txinfo) GetConfirmedNum() int32 {
	if m != nil {
		return m.ConfirmedNum
	}
	return 0
}

func (m *Txinfo) GetFeeCoin() string {
	if m != nil {
		return m.FeeCoin
	}
	return ""
}

func (m *Txinfo) GetFeeAmount() int64 {
	if m != nil {
		return m.FeeAmount
	}
	return 0
}

func (m *Txinfo) GetFeeDecimal() int32 {
	if m != nil {
		return m.FeeDecimal
	}
	return 0
}

func (m *Txinfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Txinfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GetConfirmedTxRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetConfirmedTxRequest) Reset()         { *m = GetConfirmedTxRequest{} }
func (m *GetConfirmedTxRequest) String() string { return proto.CompactTextString(m) }
func (*GetConfirmedTxRequest) ProtoMessage()    {}
func (*GetConfirmedTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{18}
}
func (m *GetConfirmedTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfirmedTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfirmedTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfirmedTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfirmedTxRequest.Merge(m, src)
}
func (m *GetConfirmedTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetConfirmedTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfirmedTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfirmedTxRequest proto.InternalMessageInfo

func (m *GetConfirmedTxRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GetConfirmedTxResponse struct {
	Success          bool    `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32   `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string  `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           *Txinfo `protobuf:"bytes,4,opt,name=result,proto3" json:"result"`
}

func (m *GetConfirmedTxResponse) Reset()         { *m = GetConfirmedTxResponse{} }
func (m *GetConfirmedTxResponse) String() string { return proto.CompactTextString(m) }
func (*GetConfirmedTxResponse) ProtoMessage()    {}
func (*GetConfirmedTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{19}
}
func (m *GetConfirmedTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfirmedTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfirmedTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfirmedTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfirmedTxResponse.Merge(m, src)
}
func (m *GetConfirmedTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetConfirmedTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfirmedTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfirmedTxResponse proto.InternalMessageInfo

func (m *GetConfirmedTxResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *GetConfirmedTxResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *GetConfirmedTxResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *GetConfirmedTxResponse) GetResult() *Txinfo {
	if m != nil {
		return m.Result
	}
	return nil
}

type ListConfirmedTxRequest struct {
	Coin      string                                                     `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	Side      string                                                     `protobuf:"bytes,2,opt,name=side,proto3" json:"side,omitempty"`
	Address   string                                                     `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	MaxId     int64                                                      `protobuf:"varint,4,opt,name=max_id,json=maxId,proto3" json:",string"`
	MinId     int64                                                      `protobuf:"varint,5,opt,name=min_id,json=minId,proto3" json:",string"`
	Limit     int32                                                      `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	BeginTime bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,7,opt,name=begin_time,json=beginTime,proto3,casttype=github.com/gisvr/golib/time.Time" json:"begin_time,omitempty"`
}

func (m *ListConfirmedTxRequest) Reset()         { *m = ListConfirmedTxRequest{} }
func (m *ListConfirmedTxRequest) String() string { return proto.CompactTextString(m) }
func (*ListConfirmedTxRequest) ProtoMessage()    {}
func (*ListConfirmedTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{20}
}
func (m *ListConfirmedTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListConfirmedTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListConfirmedTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListConfirmedTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListConfirmedTxRequest.Merge(m, src)
}
func (m *ListConfirmedTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListConfirmedTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListConfirmedTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListConfirmedTxRequest proto.InternalMessageInfo

func (m *ListConfirmedTxRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *ListConfirmedTxRequest) GetSide() string {
	if m != nil {
		return m.Side
	}
	return ""
}

func (m *ListConfirmedTxRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ListConfirmedTxRequest) GetMaxId() int64 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *ListConfirmedTxRequest) GetMinId() int64 {
	if m != nil {
		return m.MinId
	}
	return 0
}

func (m *ListConfirmedTxRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListConfirmedTxRequest) GetBeginTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.BeginTime
	}
	return 0
}

type ListConfirmedTxResponse struct {
	Success          bool      `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32     `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string    `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           []*Txinfo `protobuf:"bytes,4,rep,name=result,proto3" json:"result"`
}

func (m *ListConfirmedTxResponse) Reset()         { *m = ListConfirmedTxResponse{} }
func (m *ListConfirmedTxResponse) String() string { return proto.CompactTextString(m) }
func (*ListConfirmedTxResponse) ProtoMessage()    {}
func (*ListConfirmedTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{21}
}
func (m *ListConfirmedTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListConfirmedTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListConfirmedTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListConfirmedTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListConfirmedTxResponse.Merge(m, src)
}
func (m *ListConfirmedTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListConfirmedTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListConfirmedTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListConfirmedTxResponse proto.InternalMessageInfo

func (m *ListConfirmedTxResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ListConfirmedTxResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ListConfirmedTxResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *ListConfirmedTxResponse) GetResult() []*Txinfo {
	if m != nil {
		return m.Result
	}
	return nil
}

type GetUnConfirmedTxRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetUnConfirmedTxRequest) Reset()         { *m = GetUnConfirmedTxRequest{} }
func (m *GetUnConfirmedTxRequest) String() string { return proto.CompactTextString(m) }
func (*GetUnConfirmedTxRequest) ProtoMessage()    {}
func (*GetUnConfirmedTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{22}
}
func (m *GetUnConfirmedTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUnConfirmedTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUnConfirmedTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUnConfirmedTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUnConfirmedTxRequest.Merge(m, src)
}
func (m *GetUnConfirmedTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUnConfirmedTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUnConfirmedTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUnConfirmedTxRequest proto.InternalMessageInfo

func (m *GetUnConfirmedTxRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GetUnConfirmedTxResponse struct {
	Success          bool    `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32   `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string  `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           *Txinfo `protobuf:"bytes,4,opt,name=result,proto3" json:"result"`
}

func (m *GetUnConfirmedTxResponse) Reset()         { *m = GetUnConfirmedTxResponse{} }
func (m *GetUnConfirmedTxResponse) String() string { return proto.CompactTextString(m) }
func (*GetUnConfirmedTxResponse) ProtoMessage()    {}
func (*GetUnConfirmedTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{23}
}
func (m *GetUnConfirmedTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUnConfirmedTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUnConfirmedTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUnConfirmedTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUnConfirmedTxResponse.Merge(m, src)
}
func (m *GetUnConfirmedTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetUnConfirmedTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUnConfirmedTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetUnConfirmedTxResponse proto.InternalMessageInfo

func (m *GetUnConfirmedTxResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *GetUnConfirmedTxResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *GetUnConfirmedTxResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *GetUnConfirmedTxResponse) GetResult() *Txinfo {
	if m != nil {
		return m.Result
	}
	return nil
}

type ListUnConfirmedTxRequest struct {
	Coin  string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	Side  string `protobuf:"bytes,2,opt,name=side,proto3" json:"side,omitempty"`
	MaxId int64  `protobuf:"varint,3,opt,name=max_id,json=maxId,proto3" json:"max_id,string"`
	MinId int64  `protobuf:"varint,4,opt,name=min_id,json=minId,proto3" json:"min_id,string"`
	Limit int32  `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *ListUnConfirmedTxRequest) Reset()         { *m = ListUnConfirmedTxRequest{} }
func (m *ListUnConfirmedTxRequest) String() string { return proto.CompactTextString(m) }
func (*ListUnConfirmedTxRequest) ProtoMessage()    {}
func (*ListUnConfirmedTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{24}
}
func (m *ListUnConfirmedTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUnConfirmedTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUnConfirmedTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUnConfirmedTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUnConfirmedTxRequest.Merge(m, src)
}
func (m *ListUnConfirmedTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListUnConfirmedTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUnConfirmedTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUnConfirmedTxRequest proto.InternalMessageInfo

func (m *ListUnConfirmedTxRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *ListUnConfirmedTxRequest) GetSide() string {
	if m != nil {
		return m.Side
	}
	return ""
}

func (m *ListUnConfirmedTxRequest) GetMaxId() int64 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *ListUnConfirmedTxRequest) GetMinId() int64 {
	if m != nil {
		return m.MinId
	}
	return 0
}

func (m *ListUnConfirmedTxRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ListUnConfirmedTxResponse struct {
	Success          bool      `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32     `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string    `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           []*Txinfo `protobuf:"bytes,4,rep,name=result,proto3" json:"result"`
}

func (m *ListUnConfirmedTxResponse) Reset()         { *m = ListUnConfirmedTxResponse{} }
func (m *ListUnConfirmedTxResponse) String() string { return proto.CompactTextString(m) }
func (*ListUnConfirmedTxResponse) ProtoMessage()    {}
func (*ListUnConfirmedTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{25}
}
func (m *ListUnConfirmedTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUnConfirmedTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUnConfirmedTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUnConfirmedTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUnConfirmedTxResponse.Merge(m, src)
}
func (m *ListUnConfirmedTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListUnConfirmedTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUnConfirmedTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUnConfirmedTxResponse proto.InternalMessageInfo

func (m *ListUnConfirmedTxResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ListUnConfirmedTxResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ListUnConfirmedTxResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *ListUnConfirmedTxResponse) GetResult() []*Txinfo {
	if m != nil {
		return m.Result
	}
	return nil
}

type NewWithdrawRequest struct {
	Coin          string `protobuf:"bytes,1,opt,name=coin,proto3" json:"coin,omitempty"`
	RequestId     string `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Address       string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	Amount        int64  `protobuf:"varint,4,opt,name=amount,proto3" json:",string"`
	Memo          string `protobuf:"bytes,5,opt,name=memo,proto3" json:"memo,omitempty"`
	ForceExternal bool   `protobuf:"varint,6,opt,name=force_external,json=forceExternal,proto3" json:",string"`
	ForceInternal bool   `protobuf:"varint,7,opt,name=force_internal,json=forceInternal,proto3" json:",string"`
}

func (m *NewWithdrawRequest) Reset()         { *m = NewWithdrawRequest{} }
func (m *NewWithdrawRequest) String() string { return proto.CompactTextString(m) }
func (*NewWithdrawRequest) ProtoMessage()    {}
func (*NewWithdrawRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{26}
}
func (m *NewWithdrawRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewWithdrawRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewWithdrawRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewWithdrawRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewWithdrawRequest.Merge(m, src)
}
func (m *NewWithdrawRequest) XXX_Size() int {
	return m.Size()
}
func (m *NewWithdrawRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewWithdrawRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewWithdrawRequest proto.InternalMessageInfo

func (m *NewWithdrawRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *NewWithdrawRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *NewWithdrawRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NewWithdrawRequest) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *NewWithdrawRequest) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *NewWithdrawRequest) GetForceExternal() bool {
	if m != nil {
		return m.ForceExternal
	}
	return false
}

func (m *NewWithdrawRequest) GetForceInternal() bool {
	if m != nil {
		return m.ForceInternal
	}
	return false
}

type NewWithdrawResponse struct {
	Success          bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           string `protobuf:"bytes,4,opt,name=result,proto3" json:"result"`
}

func (m *NewWithdrawResponse) Reset()         { *m = NewWithdrawResponse{} }
func (m *NewWithdrawResponse) String() string { return proto.CompactTextString(m) }
func (*NewWithdrawResponse) ProtoMessage()    {}
func (*NewWithdrawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{27}
}
func (m *NewWithdrawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewWithdrawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewWithdrawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewWithdrawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewWithdrawResponse.Merge(m, src)
}
func (m *NewWithdrawResponse) XXX_Size() int {
	return m.Size()
}
func (m *NewWithdrawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NewWithdrawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NewWithdrawResponse proto.InternalMessageInfo

func (m *NewWithdrawResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *NewWithdrawResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *NewWithdrawResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *NewWithdrawResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type GetWithdrawDetailRequest struct {
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *GetWithdrawDetailRequest) Reset()         { *m = GetWithdrawDetailRequest{} }
func (m *GetWithdrawDetailRequest) String() string { return proto.CompactTextString(m) }
func (*GetWithdrawDetailRequest) ProtoMessage()    {}
func (*GetWithdrawDetailRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{28}
}
func (m *GetWithdrawDetailRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWithdrawDetailRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWithdrawDetailRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWithdrawDetailRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWithdrawDetailRequest.Merge(m, src)
}
func (m *GetWithdrawDetailRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetWithdrawDetailRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWithdrawDetailRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWithdrawDetailRequest proto.InternalMessageInfo

func (m *GetWithdrawDetailRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

type GetWithdrawDetailResponse struct {
	Success          bool    `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32   `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string  `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           *Txinfo `protobuf:"bytes,4,opt,name=result,proto3" json:"result"`
}

func (m *GetWithdrawDetailResponse) Reset()         { *m = GetWithdrawDetailResponse{} }
func (m *GetWithdrawDetailResponse) String() string { return proto.CompactTextString(m) }
func (*GetWithdrawDetailResponse) ProtoMessage()    {}
func (*GetWithdrawDetailResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{29}
}
func (m *GetWithdrawDetailResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWithdrawDetailResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWithdrawDetailResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWithdrawDetailResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWithdrawDetailResponse.Merge(m, src)
}
func (m *GetWithdrawDetailResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWithdrawDetailResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWithdrawDetailResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWithdrawDetailResponse proto.InternalMessageInfo

func (m *GetWithdrawDetailResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *GetWithdrawDetailResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *GetWithdrawDetailResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *GetWithdrawDetailResponse) GetResult() *Txinfo {
	if m != nil {
		return m.Result
	}
	return nil
}

type CollectCallbackRequest struct {
	Coin        string                                                     `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Txid        string                                                     `protobuf:"bytes,2,opt,name=Txid,proto3" json:"Txid,omitempty"`
	FromAddress string                                                     `protobuf:"bytes,3,opt,name=FromAddress,proto3" json:"FromAddress,omitempty"`
	ToAddress   string                                                     `protobuf:"bytes,4,opt,name=ToAddress,proto3" json:"ToAddress,omitempty"`
	Memo        string                                                     `protobuf:"bytes,5,opt,name=Memo,proto3" json:"Memo,omitempty"`
	OutN        int64                                                      `protobuf:"varint,6,opt,name=OutN,proto3" json:"OutN,omitempty"`
	Amount      string                                                     `protobuf:"bytes,7,opt,name=Amount,proto3" json:"Amount,omitempty"`
	Comment     string                                                     `protobuf:"bytes,8,opt,name=Comment,proto3" json:"Comment,omitempty"`
	OutNum      int32                                                      `protobuf:"varint,9,opt,name=OutNum,proto3" json:"OutNum,omitempty"`
	Fee         string                                                     `protobuf:"bytes,10,opt,name=Fee,proto3" json:"Fee,omitempty"`
	FeeCoin     string                                                     `protobuf:"bytes,11,opt,name=FeeCoin,proto3" json:"FeeCoin,omitempty"`
	BlockHash   string                                                     `protobuf:"bytes,12,opt,name=BlockHash,proto3" json:"BlockHash,omitempty"`
	BlockNum    int64                                                      `protobuf:"varint,13,opt,name=BlockNum,proto3" json:"BlockNum,omitempty"`
	BlockTime   bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,14,opt,name=BlockTime,proto3,casttype=github.com/gisvr/golib/time.Time" json:"BlockTime,string" gorm:"type:datetime;"`
	Confirm     int32                                                      `protobuf:"varint,15,opt,name=Confirm,proto3" json:"Confirm,omitempty"`
	Side        string                                                     `protobuf:"bytes,16,opt,name=Side,proto3" json:"Side,omitempty"`
}

func (m *CollectCallbackRequest) Reset()         { *m = CollectCallbackRequest{} }
func (m *CollectCallbackRequest) String() string { return proto.CompactTextString(m) }
func (*CollectCallbackRequest) ProtoMessage()    {}
func (*CollectCallbackRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{30}
}
func (m *CollectCallbackRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectCallbackRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectCallbackRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectCallbackRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectCallbackRequest.Merge(m, src)
}
func (m *CollectCallbackRequest) XXX_Size() int {
	return m.Size()
}
func (m *CollectCallbackRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectCallbackRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CollectCallbackRequest proto.InternalMessageInfo

func (m *CollectCallbackRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *CollectCallbackRequest) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *CollectCallbackRequest) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *CollectCallbackRequest) GetToAddress() string {
	if m != nil {
		return m.ToAddress
	}
	return ""
}

func (m *CollectCallbackRequest) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *CollectCallbackRequest) GetOutN() int64 {
	if m != nil {
		return m.OutN
	}
	return 0
}

func (m *CollectCallbackRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *CollectCallbackRequest) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *CollectCallbackRequest) GetOutNum() int32 {
	if m != nil {
		return m.OutNum
	}
	return 0
}

func (m *CollectCallbackRequest) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

func (m *CollectCallbackRequest) GetFeeCoin() string {
	if m != nil {
		return m.FeeCoin
	}
	return ""
}

func (m *CollectCallbackRequest) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *CollectCallbackRequest) GetBlockNum() int64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *CollectCallbackRequest) GetBlockTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *CollectCallbackRequest) GetConfirm() int32 {
	if m != nil {
		return m.Confirm
	}
	return 0
}

func (m *CollectCallbackRequest) GetSide() string {
	if m != nil {
		return m.Side
	}
	return ""
}

type CollectCallbackResponse struct {
	Success          bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           string `protobuf:"bytes,4,opt,name=result,proto3" json:"result"`
}

func (m *CollectCallbackResponse) Reset()         { *m = CollectCallbackResponse{} }
func (m *CollectCallbackResponse) String() string { return proto.CompactTextString(m) }
func (*CollectCallbackResponse) ProtoMessage()    {}
func (*CollectCallbackResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{31}
}
func (m *CollectCallbackResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectCallbackResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectCallbackResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectCallbackResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectCallbackResponse.Merge(m, src)
}
func (m *CollectCallbackResponse) XXX_Size() int {
	return m.Size()
}
func (m *CollectCallbackResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectCallbackResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CollectCallbackResponse proto.InternalMessageInfo

func (m *CollectCallbackResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CollectCallbackResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *CollectCallbackResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *CollectCallbackResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type ImportOldAddressRequest struct {
	Coin    string `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
	Memo    string `protobuf:"bytes,3,opt,name=Memo,proto3" json:"Memo,omitempty"`
	Label   string `protobuf:"bytes,4,opt,name=Label,proto3" json:"Label,omitempty"`
}

func (m *ImportOldAddressRequest) Reset()         { *m = ImportOldAddressRequest{} }
func (m *ImportOldAddressRequest) String() string { return proto.CompactTextString(m) }
func (*ImportOldAddressRequest) ProtoMessage()    {}
func (*ImportOldAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{32}
}
func (m *ImportOldAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportOldAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportOldAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportOldAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportOldAddressRequest.Merge(m, src)
}
func (m *ImportOldAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *ImportOldAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportOldAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImportOldAddressRequest proto.InternalMessageInfo

func (m *ImportOldAddressRequest) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *ImportOldAddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ImportOldAddressRequest) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *ImportOldAddressRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type ImportOldAddressResponse struct {
	Success          bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
	ErrorCode        int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code"`
	ErrorDescription string `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description"`
	Result           bool   `protobuf:"varint,4,opt,name=result,proto3" json:"result"`
}

func (m *ImportOldAddressResponse) Reset()         { *m = ImportOldAddressResponse{} }
func (m *ImportOldAddressResponse) String() string { return proto.CompactTextString(m) }
func (*ImportOldAddressResponse) ProtoMessage()    {}
func (*ImportOldAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd29513719ed1653, []int{33}
}
func (m *ImportOldAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportOldAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportOldAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportOldAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportOldAddressResponse.Merge(m, src)
}
func (m *ImportOldAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *ImportOldAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportOldAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ImportOldAddressResponse proto.InternalMessageInfo

func (m *ImportOldAddressResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ImportOldAddressResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ImportOldAddressResponse) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *ImportOldAddressResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func init() {
	proto.RegisterType((*ListAllCoinRequest)(nil), "asapi.api.ListAllCoinRequest")
	proto.RegisterType((*CoinAsset)(nil), "asapi.api.CoinAsset")
	proto.RegisterType((*ListAllCoinResult)(nil), "asapi.api.ListAllCoinResult")
	proto.RegisterType((*ListAllCoinResponse)(nil), "asapi.api.ListAllCoinResponse")
	proto.RegisterType((*GetCoinInfoRequest)(nil), "asapi.api.GetCoinInfoRequest")
	proto.RegisterType((*GetCoinInfoResponse)(nil), "asapi.api.GetCoinInfoResponse")
	proto.RegisterType((*NewDepositAddressRequest)(nil), "asapi.api.NewDepositAddressRequest")
	proto.RegisterType((*NewDepositAddressResult)(nil), "asapi.api.NewDepositAddressResult")
	proto.RegisterType((*NewDepositAddressResponse)(nil), "asapi.api.NewDepositAddressResponse")
	proto.RegisterType((*HasAddressRequest)(nil), "asapi.api.HasAddressRequest")
	proto.RegisterType((*HasAddressResult)(nil), "asapi.api.HasAddressResult")
	proto.RegisterType((*HasAddressResponse)(nil), "asapi.api.HasAddressResponse")
	proto.RegisterType((*CheckAddressRequest)(nil), "asapi.api.CheckAddressRequest")
	proto.RegisterType((*CheckAddressResponse)(nil), "asapi.api.CheckAddressResponse")
	proto.RegisterType((*ListAllAddressRequest)(nil), "asapi.api.ListAllAddressRequest")
	proto.RegisterType((*ListAllAddressResult)(nil), "asapi.api.ListAllAddressResult")
	proto.RegisterType((*ListAllAddressResponse)(nil), "asapi.api.ListAllAddressResponse")
	proto.RegisterType((*Txinfo)(nil), "asapi.api.Txinfo")
	proto.RegisterType((*GetConfirmedTxRequest)(nil), "asapi.api.GetConfirmedTxRequest")
	proto.RegisterType((*GetConfirmedTxResponse)(nil), "asapi.api.GetConfirmedTxResponse")
	proto.RegisterType((*ListConfirmedTxRequest)(nil), "asapi.api.ListConfirmedTxRequest")
	proto.RegisterType((*ListConfirmedTxResponse)(nil), "asapi.api.ListConfirmedTxResponse")
	proto.RegisterType((*GetUnConfirmedTxRequest)(nil), "asapi.api.GetUnConfirmedTxRequest")
	proto.RegisterType((*GetUnConfirmedTxResponse)(nil), "asapi.api.GetUnConfirmedTxResponse")
	proto.RegisterType((*ListUnConfirmedTxRequest)(nil), "asapi.api.ListUnConfirmedTxRequest")
	proto.RegisterType((*ListUnConfirmedTxResponse)(nil), "asapi.api.ListUnConfirmedTxResponse")
	proto.RegisterType((*NewWithdrawRequest)(nil), "asapi.api.NewWithdrawRequest")
	proto.RegisterType((*NewWithdrawResponse)(nil), "asapi.api.NewWithdrawResponse")
	proto.RegisterType((*GetWithdrawDetailRequest)(nil), "asapi.api.GetWithdrawDetailRequest")
	proto.RegisterType((*GetWithdrawDetailResponse)(nil), "asapi.api.GetWithdrawDetailResponse")
	proto.RegisterType((*CollectCallbackRequest)(nil), "asapi.api.CollectCallbackRequest")
	proto.RegisterType((*CollectCallbackResponse)(nil), "asapi.api.CollectCallbackResponse")
	proto.RegisterType((*ImportOldAddressRequest)(nil), "asapi.api.ImportOldAddressRequest")
	proto.RegisterType((*ImportOldAddressResponse)(nil), "asapi.api.ImportOldAddressResponse")
}

func init() { proto.RegisterFile("asapi.proto", fileDescriptor_cd29513719ed1653) }

var fileDescriptor_cd29513719ed1653 = []byte{
	// 2313 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0x41, 0x6f, 0x1b, 0xc7,
	0x15, 0xf6, 0x4a, 0xa2, 0x24, 0x3e, 0x52, 0xb2, 0x38, 0xa2, 0xa4, 0x95, 0x22, 0x8b, 0xf2, 0xda,
	0x46, 0xd4, 0x36, 0x16, 0x6d, 0xa7, 0x2d, 0x1a, 0x07, 0x48, 0x2d, 0xca, 0xb1, 0x23, 0x34, 0x76,
	0x8a, 0xad, 0x82, 0x02, 0x01, 0x8a, 0xcd, 0x72, 0x77, 0x48, 0x4d, 0xb5, 0xbb, 0x43, 0xef, 0x2e,
	0x2d, 0xf9, 0xd0, 0x4b, 0xd0, 0x4b, 0x6f, 0x45, 0x7b, 0xe8, 0x9f, 0xe8, 0x6f, 0xe8, 0xb9, 0xc7,
	0x00, 0x29, 0xd0, 0x9c, 0x88, 0xc2, 0xce, 0x25, 0x6c, 0x80, 0xa2, 0xbd, 0x14, 0x28, 0x50, 0x20,
	0x98, 0x37, 0xb3, 0xe4, 0x2e, 0xb9, 0x94, 0x8d, 0xe4, 0xa2, 0xe8, 0x22, 0xce, 0x7b, 0xf3, 0x66,
	0xde, 0xcc, 0x37, 0xef, 0xcd, 0x7c, 0x33, 0x2b, 0x28, 0xd9, 0x91, 0xdd, 0x61, 0xbb, 0x9d, 0x90,
	0xc7, 0x9c, 0x14, 0xa5, 0x60, 0x77, 0xd8, 0xc6, 0xcd, 0x36, 0x8b, 0x8f, 0xba, 0xcd, 0x5d, 0x87,
	0xfb, 0xf5, 0x36, 0x6f, 0xf3, 0x3a, 0x5a, 0x34, 0xbb, 0x2d, 0x94, 0x50, 0xc0, 0x92, 0x6c, 0xb9,
	0xb1, 0xd9, 0xe6, 0xbc, 0xed, 0xd1, 0xba, 0xdd, 0x61, 0x75, 0x3b, 0x08, 0x78, 0x6c, 0xc7, 0x8c,
	0x07, 0x91, 0xac, 0x35, 0xaa, 0x40, 0xde, 0x67, 0x51, 0xbc, 0xe7, 0x79, 0xfb, 0x9c, 0x05, 0x26,
	0x7d, 0xd2, 0xa5, 0x51, 0x6c, 0x7c, 0x31, 0x0d, 0x45, 0x21, 0xef, 0x45, 0x11, 0x8d, 0x09, 0x81,
	0x19, 0x87, 0xb3, 0x40, 0xd7, 0xb6, 0xb5, 0x9d, 0xa2, 0x89, 0x65, 0x72, 0x15, 0xca, 0x2e, 0x8b,
	0x3a, 0x9e, 0xfd, 0xcc, 0x72, 0xb8, 0x4b, 0xf5, 0x29, 0xac, 0x2b, 0x29, 0xdd, 0x3e, 0x77, 0x29,
	0xd9, 0x86, 0x92, 0x4b, 0x23, 0x27, 0x64, 0x1d, 0xe1, 0x50, 0x9f, 0x56, 0x16, 0x43, 0x15, 0xd1,
	0x61, 0xce, 0xa5, 0x0e, 0xf3, 0x6d, 0x4f, 0x9f, 0xd9, 0xd6, 0x76, 0x0a, 0x66, 0x22, 0x92, 0x1a,
	0x94, 0x1c, 0x3b, 0xb0, 0x5c, 0xda, 0xe1, 0x11, 0x8b, 0xf5, 0xc2, 0xb6, 0xb6, 0x33, 0x6f, 0x82,
	0x63, 0x07, 0xf7, 0xa5, 0x46, 0xf8, 0x17, 0x06, 0x27, 0x2c, 0x3e, 0x72, 0x43, 0xfb, 0x44, 0x9f,
	0x45, 0x0b, 0xd1, 0xe8, 0x97, 0x4a, 0x25, 0x7a, 0x6f, 0xda, 0x9e, 0x1d, 0x38, 0x54, 0x9f, 0x43,
	0xdf, 0x89, 0x28, 0x7a, 0xb7, 0x9b, 0x91, 0x95, 0xd4, 0xce, 0x63, 0x2d, 0xd8, 0xcd, 0xa8, 0xa1,
	0x0c, 0xd6, 0x61, 0xbe, 0x45, 0xa9, 0x85, 0xb3, 0x2e, 0xca, 0xb6, 0x2d, 0x4a, 0x05, 0x22, 0x64,
	0x07, 0x96, 0x44, 0x5b, 0x1a, 0xc5, 0xcc, 0xb7, 0x63, 0x6a, 0xb5, 0x28, 0xd5, 0x01, 0x4d, 0x16,
	0xed, 0x66, 0xf4, 0xae, 0x52, 0x3f, 0xa0, 0x94, 0xdc, 0x86, 0xaa, 0xc3, 0x83, 0x16, 0x0b, 0x7d,
	0x16, 0xb4, 0xad, 0xf8, 0x28, 0xa4, 0xd1, 0x11, 0xf7, 0x5c, 0xbd, 0x84, 0x53, 0x5d, 0x1e, 0xd6,
	0x1d, 0x26, 0x55, 0xe4, 0x06, 0x2c, 0xba, 0xdd, 0x28, 0x4e, 0x19, 0x97, 0xd1, 0x78, 0x41, 0x68,
	0x87, 0x66, 0xd7, 0x60, 0x21, 0xe6, 0xc7, 0x34, 0xb0, 0x6c, 0xd7, 0x0d, 0x69, 0x14, 0xe9, 0x0b,
	0x38, 0x80, 0x32, 0x2a, 0xf7, 0xa4, 0x4e, 0x20, 0x14, 0xd2, 0x27, 0x5d, 0x16, 0x52, 0xcb, 0xa7,
	0x3e, 0xd7, 0x17, 0x25, 0xfe, 0x4a, 0xf7, 0x88, 0xfa, 0xdc, 0xf8, 0x10, 0x2a, 0x99, 0xc5, 0x8f,
	0xba, 0x1e, 0xae, 0x76, 0x60, 0xfb, 0x34, 0x59, 0x6d, 0x51, 0x26, 0x6f, 0xc0, 0xac, 0x2d, 0x42,
	0x21, 0xd2, 0xa7, 0xb6, 0xa7, 0x77, 0x4a, 0x77, 0xaa, 0xbb, 0x83, 0x70, 0xdc, 0x1d, 0xc4, 0x89,
	0xa9, 0x6c, 0x8c, 0x7f, 0x6b, 0xb0, 0x9c, 0xed, 0xb7, 0xc3, 0x83, 0x88, 0x92, 0x1b, 0x30, 0x17,
	0x75, 0x1d, 0x47, 0x0c, 0x58, 0x74, 0x3e, 0xdf, 0x28, 0xf5, 0x7b, 0xb5, 0x44, 0x65, 0x26, 0x05,
	0x72, 0x13, 0x80, 0x86, 0x21, 0x0f, 0x87, 0x81, 0x55, 0x68, 0x2c, 0xf6, 0x7b, 0xb5, 0x94, 0xd6,
	0x2c, 0x62, 0x19, 0xc3, 0xac, 0x01, 0x15, 0x59, 0x31, 0x16, 0x6c, 0x8d, 0x95, 0x7e, 0xaf, 0x36,
	0x5e, 0x69, 0x2e, 0xa1, 0xea, 0x7e, 0x2a, 0x10, 0xef, 0xc1, 0x6c, 0x88, 0xb3, 0xd7, 0x67, 0x70,
	0x7e, 0x9b, 0xa9, 0xf9, 0x8d, 0x21, 0xd4, 0x80, 0x7e, 0xaf, 0xa6, 0xec, 0x4d, 0xf5, 0x6b, 0xec,
	0x00, 0x79, 0x48, 0x63, 0x61, 0x74, 0x10, 0xb4, 0xb8, 0xca, 0xa3, 0xbc, 0xcc, 0x31, 0xbe, 0xd4,
	0x60, 0x39, 0x63, 0x7a, 0xee, 0xd1, 0xf9, 0x49, 0x0a, 0x1d, 0x6d, 0xd2, 0xea, 0xe7, 0xa2, 0xb2,
	0x0b, 0xfa, 0x63, 0x7a, 0xa2, 0x72, 0x56, 0x05, 0xe6, 0x59, 0xd8, 0x3c, 0x84, 0xb5, 0x1c, 0xfb,
	0x24, 0x2c, 0xc7, 0x36, 0x21, 0x1d, 0xe6, 0x92, 0x0c, 0x90, 0xfb, 0x4f, 0x22, 0x1a, 0xff, 0xd7,
	0x60, 0x3d, 0xaf, 0xa7, 0xf3, 0x0e, 0xf5, 0x83, 0x11, 0xa8, 0x8d, 0x14, 0xd4, 0x13, 0x90, 0xc9,
	0x05, 0x7e, 0x0f, 0x2a, 0xef, 0xd9, 0xd1, 0xcb, 0x11, 0x3f, 0x03, 0xc2, 0x7b, 0xb0, 0x94, 0xee,
	0xe2, 0x1b, 0x2c, 0xc2, 0xbf, 0x34, 0x20, 0x99, 0x2e, 0xce, 0x3b, 0xfa, 0x3f, 0x1d, 0x41, 0xff,
	0xb5, 0x14, 0xfa, 0xa3, 0x58, 0xe4, 0xc2, 0xbe, 0x0f, 0xcb, 0xfb, 0x47, 0xd4, 0x39, 0xfe, 0x56,
	0xc0, 0xff, 0x4d, 0x83, 0x6a, 0xb6, 0x97, 0x73, 0x0f, 0x9c, 0x91, 0x01, 0x6e, 0x3e, 0x17, 0x9b,
	0x1f, 0xc0, 0x8a, 0xda, 0x4a, 0x5f, 0x61, 0x23, 0xb8, 0x0f, 0xd5, 0x51, 0xe3, 0x6f, 0x10, 0x80,
	0xff, 0xd5, 0x60, 0x75, 0xac, 0x9b, 0xf3, 0x8e, 0xe5, 0xfe, 0xc8, 0x59, 0x54, 0x1b, 0x3f, 0x8b,
	0x5e, 0x1e, 0x88, 0x5f, 0xcd, 0xc3, 0xec, 0xe1, 0x29, 0x0b, 0x5a, 0x9c, 0x6c, 0xa6, 0x21, 0x6b,
	0xcc, 0xf7, 0x7b, 0x35, 0x94, 0x15, 0x78, 0x6f, 0xe6, 0xf1, 0xb8, 0xc6, 0x52, 0xbf, 0x57, 0xcb,
	0xe8, 0xb3, 0xcc, 0xee, 0x76, 0x0e, 0xb3, 0x6b, 0x5c, 0xee, 0xf7, 0x6a, 0x69, 0x75, 0x96, 0xea,
	0xdd, 0x18, 0xa1, 0x7a, 0x12, 0x6f, 0xa5, 0x1a, 0xf2, 0xbe, 0x1b, 0xc3, 0xb5, 0x2c, 0x60, 0xaf,
	0x68, 0xa6, 0x54, 0x83, 0x85, 0x15, 0x73, 0x42, 0x4e, 0x33, 0x3b, 0x9c, 0x93, 0x90, 0x4d, 0xfc,
	0x4b, 0xde, 0x82, 0xc5, 0x88, 0x77, 0x43, 0x87, 0x0e, 0xf8, 0x11, 0xf2, 0xbf, 0x06, 0xe9, 0xf7,
	0x6a, 0x23, 0x35, 0xe6, 0x82, 0x94, 0x13, 0xd2, 0xf4, 0x08, 0x56, 0xb2, 0x06, 0x96, 0x4b, 0x63,
	0x9b, 0x79, 0x92, 0x23, 0x36, 0xd6, 0xfb, 0xbd, 0x5a, 0xbe, 0x81, 0xb9, 0x9c, 0xe9, 0xe8, 0x3e,
	0x2a, 0xc5, 0x38, 0x23, 0xe6, 0x52, 0xc9, 0x21, 0xe5, 0x38, 0x85, 0x6c, 0xe2, 0x5f, 0x91, 0x35,
	0xb6, 0xcf, 0xbb, 0x41, 0x2c, 0x09, 0xa4, 0x5c, 0x48, 0xa9, 0x31, 0xd5, 0xaf, 0x08, 0x40, 0x41,
	0x37, 0x95, 0x5d, 0x09, 0xed, 0x30, 0x00, 0x87, 0x5a, 0xb3, 0x68, 0x37, 0xa3, 0x3d, 0x69, 0xfe,
	0x8e, 0x64, 0xa7, 0x1d, 0xcf, 0x8e, 0x5b, 0x3c, 0xf4, 0x91, 0x9d, 0x96, 0xb1, 0x51, 0xb5, 0xdf,
	0xab, 0x8d, 0xd5, 0x21, 0x67, 0xfd, 0xb9, 0x52, 0x08, 0xce, 0xba, 0x09, 0x33, 0xf1, 0x29, 0x73,
	0x25, 0xa1, 0x94, 0x03, 0x16, 0xb2, 0x89, 0x7f, 0xc9, 0x55, 0x98, 0x7d, 0xca, 0xbb, 0xb1, 0x15,
	0x20, 0x99, 0x9c, 0x96, 0x03, 0x96, 0x1a, 0xb3, 0x20, 0x7e, 0x1f, 0x8b, 0xf1, 0x86, 0x32, 0xaf,
	0x2d, 0xe6, 0xea, 0x97, 0x87, 0xe3, 0x1d, 0x6a, 0xcd, 0xa2, 0x2a, 0x1f, 0xb8, 0x02, 0x82, 0x28,
	0xb6, 0xe3, 0x6e, 0xa4, 0x2f, 0x0d, 0x21, 0x90, 0x1a, 0x53, 0xfd, 0x92, 0x5b, 0x50, 0x72, 0x42,
	0x2a, 0xb8, 0x76, 0xcc, 0x7c, 0xaa, 0x57, 0xd0, 0x35, 0x46, 0x5b, 0x4a, 0x6d, 0x82, 0x14, 0x0e,
	0x99, 0x4f, 0xc9, 0xf7, 0xa1, 0xe8, 0xd9, 0x82, 0x46, 0x0b, 0x7b, 0x82, 0xf6, 0x0b, 0xfd, 0x5e,
	0x6d, 0xa8, 0x34, 0xe7, 0x45, 0x11, 0x6d, 0x7f, 0x36, 0x81, 0xa5, 0x2f, 0x63, 0x94, 0xea, 0xfd,
	0x5e, 0x2d, 0xb7, 0x3e, 0x9f, 0xbf, 0xff, 0x18, 0x16, 0x94, 0x9a, 0xba, 0x56, 0xd0, 0xf5, 0xf5,
	0x2a, 0xf6, 0x52, 0xe9, 0xf7, 0x6a, 0xd9, 0x0a, 0xb3, 0x3c, 0x10, 0x1f, 0x77, 0x7d, 0xf2, 0x7a,
	0xea, 0xbe, 0xb1, 0x82, 0x40, 0x94, 0xfb, 0xbd, 0xda, 0x40, 0x37, 0xbc, 0x7d, 0xdc, 0x04, 0x10,
	0x4a, 0x15, 0x0e, 0xab, 0x38, 0x35, 0x84, 0x77, 0xa8, 0x35, 0x8b, 0x2d, 0x4a, 0x55, 0x38, 0xdc,
	0x82, 0x92, 0xa8, 0x48, 0x32, 0x6f, 0x0d, 0x47, 0x83, 0xd0, 0xa5, 0xd4, 0xa6, 0x68, 0x7c, 0x5f,
	0x25, 0xa0, 0x08, 0x80, 0x67, 0x1d, 0xaa, 0xeb, 0xa9, 0x00, 0x78, 0xd6, 0xa1, 0x26, 0xfe, 0x25,
	0xab, 0x30, 0xc5, 0x5c, 0x7d, 0x1d, 0xeb, 0x66, 0xfb, 0xbd, 0xda, 0x14, 0x73, 0xcd, 0x29, 0xe6,
	0x1a, 0xaf, 0xc3, 0x0a, 0x52, 0x5a, 0x35, 0xa5, 0xc3, 0xd3, 0x64, 0x6f, 0x5f, 0xc4, 0x06, 0x72,
	0xb7, 0x16, 0x86, 0x5f, 0x6a, 0xb0, 0x3a, 0x6a, 0x79, 0xee, 0x77, 0xe4, 0x1f, 0x8d, 0xd0, 0x82,
	0x4a, 0x6a, 0x47, 0x96, 0x9b, 0x6c, 0xee, 0x1e, 0xfc, 0xa7, 0x29, 0x79, 0xfa, 0xe4, 0xc0, 0x92,
	0x77, 0x8c, 0x11, 0xb5, 0x57, 0xc8, 0x33, 0x4c, 0xee, 0x10, 0xa9, 0xa3, 0x6d, 0x3a, 0x73, 0xb4,
	0x89, 0xc4, 0xf1, 0xed, 0x53, 0x91, 0x63, 0x33, 0x18, 0x04, 0x08, 0xd6, 0x1b, 0x51, 0x1c, 0xb2,
	0xa0, 0x6d, 0x16, 0x7c, 0xfb, 0x54, 0x26, 0x97, 0xcf, 0x02, 0x61, 0x53, 0xc8, 0xb3, 0x61, 0xc1,
	0x81, 0x4b, 0xaa, 0x50, 0xf0, 0x98, 0xcf, 0x62, 0xdc, 0x4a, 0x0b, 0xa6, 0x14, 0xc8, 0xaf, 0x00,
	0x9a, 0xb4, 0xcd, 0x02, 0x99, 0x41, 0x73, 0xd8, 0xfa, 0x9d, 0xff, 0xf5, 0x6a, 0x77, 0x9b, 0x2c,
	0x6e, 0x76, 0x9d, 0x63, 0x1a, 0xef, 0xf2, 0xb0, 0x5d, 0x6f, 0x32, 0xc6, 0xda, 0x1e, 0x4d, 0x7e,
	0xad, 0x13, 0xfb, 0xd6, 0xad, 0xdb, 0x96, 0x6b, 0xfb, 0x51, 0x3d, 0x0a, 0x9d, 0xba, 0xc7, 0x9a,
	0x75, 0xd1, 0xc1, 0xae, 0x48, 0x34, 0xb3, 0x88, 0x3d, 0x8a, 0xa2, 0xd1, 0xd7, 0x60, 0x6d, 0x0c,
	0x99, 0xef, 0x54, 0x18, 0x4c, 0xbf, 0x7a, 0x18, 0x7c, 0x0f, 0xd6, 0x1e, 0xd2, 0xf8, 0xc3, 0xe0,
	0x15, 0xb2, 0xe3, 0x9f, 0x1a, 0xe8, 0xe3, 0xb6, 0x17, 0x35, 0x3f, 0xfe, 0xac, 0x81, 0x2e, 0xa2,
	0x20, 0x17, 0x9a, 0x57, 0xcd, 0x90, 0x9d, 0x41, 0x1e, 0x4c, 0x63, 0x94, 0xe2, 0x56, 0x2b, 0x35,
	0x23, 0xd9, 0xb0, 0x33, 0xc8, 0x86, 0x99, 0x94, 0x25, 0x6a, 0x26, 0xe5, 0x44, 0x21, 0x95, 0x13,
	0xc6, 0x57, 0x1a, 0xac, 0xe7, 0x0c, 0xf7, 0xa2, 0x86, 0xed, 0x27, 0x53, 0x40, 0x1e, 0xd3, 0x93,
	0xe4, 0x35, 0xed, 0xac, 0x75, 0xb9, 0x92, 0x39, 0xf3, 0xe5, 0xea, 0xa4, 0xce, 0xf8, 0xc9, 0x9b,
	0xd8, 0xb5, 0x01, 0x01, 0xca, 0xd9, 0xc4, 0x12, 0x06, 0x44, 0x14, 0xd7, 0x2b, 0x48, 0x8f, 0xc8,
	0xf0, 0xee, 0xc0, 0x62, 0x8b, 0x0b, 0x12, 0x46, 0x4f, 0x63, 0x1a, 0x06, 0xb6, 0x27, 0xdf, 0xff,
	0xb2, 0x1d, 0x2c, 0xa0, 0xc9, 0xbb, 0xca, 0x62, 0xd8, 0x86, 0x05, 0xaa, 0xcd, 0xdc, 0xa4, 0x36,
	0x07, 0xca, 0xc2, 0xf8, 0x4c, 0x83, 0xe5, 0x0c, 0x08, 0xdf, 0xb1, 0x9b, 0x58, 0x31, 0x77, 0x69,
	0xdf, 0xc2, 0x5d, 0x26, 0x99, 0x94, 0xa4, 0xaa, 0xc9, 0xfa, 0x66, 0xd7, 0x52, 0x1b, 0x59, 0x4b,
	0x4c, 0x82, 0x9c, 0xb6, 0x17, 0x75, 0x8b, 0xfa, 0xc3, 0x0c, 0xac, 0xee, 0x73, 0xcf, 0xa3, 0x4e,
	0xbc, 0x6f, 0x7b, 0x5e, 0xd3, 0x76, 0x8e, 0x53, 0x89, 0xb0, 0x9f, 0x4a, 0x84, 0x7d, 0xb5, 0x41,
	0x1d, 0x9e, 0x0e, 0x52, 0x00, 0xcb, 0x64, 0x1b, 0x4a, 0x0f, 0x42, 0xee, 0xef, 0x65, 0x32, 0x20,
	0xad, 0x22, 0x9b, 0x50, 0x3c, 0xe4, 0x49, 0xfd, 0x8c, 0x44, 0x7c, 0xa0, 0x10, 0x7d, 0x3e, 0x4a,
	0x85, 0xbf, 0x28, 0x0b, 0xdd, 0x07, 0xdd, 0xf8, 0x31, 0x06, 0xfd, 0xb4, 0x89, 0x65, 0xb2, 0x0a,
	0xb3, 0x92, 0xf4, 0xa9, 0xc7, 0x6e, 0x25, 0x89, 0xec, 0xdb, 0xe7, 0xbe, 0x4f, 0x83, 0x58, 0xbd,
	0x73, 0x27, 0xa2, 0x68, 0x21, 0x5a, 0x76, 0x7d, 0xbc, 0x9e, 0x14, 0x4c, 0x25, 0x91, 0x25, 0x98,
	0x7e, 0x30, 0x78, 0xd4, 0x16, 0x45, 0xd1, 0xc7, 0x03, 0x49, 0x40, 0xe5, 0x0d, 0xc4, 0x4c, 0x44,
	0x31, 0xf6, 0x86, 0xc7, 0x9d, 0xe3, 0xf7, 0xec, 0xe8, 0x48, 0x5e, 0x34, 0xcc, 0xa1, 0x82, 0x6c,
	0xc0, 0x3c, 0x0a, 0xc2, 0xc7, 0x02, 0x8e, 0x75, 0x20, 0x93, 0xdf, 0x69, 0xaa, 0xa9, 0x60, 0x04,
	0xea, 0x3e, 0x71, 0x2c, 0xee, 0x28, 0x03, 0xa5, 0xca, 0xc9, 0xff, 0xf4, 0x6a, 0x2b, 0x6d, 0x1e,
	0xfa, 0x77, 0x0d, 0x41, 0x41, 0xef, 0xba, 0x76, 0x4c, 0x05, 0xa9, 0x78, 0xdb, 0xf8, 0xb6, 0x7c,
	0x64, 0xe0, 0x48, 0x62, 0x84, 0x7b, 0x3a, 0xde, 0x58, 0x0a, 0x66, 0x22, 0x0a, 0xa4, 0x7f, 0x21,
	0x8e, 0x9c, 0x25, 0x89, 0xbe, 0x28, 0x1b, 0x7f, 0xd7, 0x60, 0x6d, 0x2c, 0x28, 0x2e, 0xc4, 0xc6,
	0xf0, 0x04, 0xd6, 0x0e, 0xfc, 0x0e, 0x0f, 0xe3, 0x0f, 0x3c, 0x77, 0xfc, 0x91, 0x66, 0x2c, 0xdc,
	0x75, 0x98, 0xdb, 0xcb, 0x3e, 0xbc, 0x8c, 0x06, 0xed, 0x74, 0x2a, 0x68, 0xab, 0x50, 0x78, 0xdf,
	0x6e, 0x52, 0x4f, 0x85, 0xb8, 0x14, 0x8c, 0xcf, 0x35, 0xd0, 0xc7, 0x7d, 0x5e, 0x84, 0x07, 0xaf,
	0x3b, 0x7f, 0x29, 0x43, 0x61, 0x2f, 0xda, 0xeb, 0x30, 0xe2, 0xc0, 0xe5, 0xd4, 0x57, 0x84, 0x83,
	0xa0, 0xc5, 0xc9, 0x95, 0x49, 0x5f, 0x18, 0x10, 0xee, 0x8d, 0xad, 0x89, 0x1f, 0x20, 0x10, 0x19,
	0xa3, 0xf2, 0xc9, 0x67, 0x5f, 0xfc, 0x71, 0xaa, 0x44, 0x8a, 0x75, 0x1e, 0xb6, 0x2d, 0x7c, 0xe7,
	0xf9, 0x18, 0x4a, 0xa9, 0xcf, 0x0a, 0x19, 0x07, 0xe3, 0x5f, 0x26, 0x32, 0x0e, 0x72, 0xbe, 0x46,
	0x18, 0x04, 0x1d, 0x94, 0x09, 0xd4, 0xc5, 0x11, 0x2f, 0x3d, 0xc4, 0x50, 0x19, 0x7b, 0x83, 0x26,
	0xd7, 0xce, 0x7e, 0xa1, 0x96, 0xde, 0xae, 0xbf, 0xe4, 0x19, 0x5b, 0xfa, 0xac, 0xa2, 0xcf, 0x45,
	0xa3, 0x5c, 0x0f, 0xe8, 0x49, 0xf2, 0xbe, 0x42, 0x3e, 0x06, 0x18, 0xbe, 0xbd, 0x92, 0xcd, 0x09,
	0x4f, 0xb2, 0xd2, 0xcf, 0x95, 0x49, 0x0f, 0xb6, 0xd2, 0xc1, 0x0a, 0x3a, 0xb8, 0x4c, 0x16, 0xea,
	0xc9, 0xe3, 0x0d, 0xce, 0xeb, 0xd7, 0x50, 0x4e, 0xbf, 0xb7, 0x92, 0x34, 0x36, 0x39, 0xcf, 0xb9,
	0x1b, 0xb5, 0x89, 0xf5, 0xca, 0xcf, 0x3a, 0xfa, 0x59, 0x26, 0x95, 0x3a, 0x8b, 0xac, 0xa7, 0xb6,
	0xc7, 0xdc, 0xc1, 0x6c, 0x38, 0x2c, 0x66, 0x1f, 0xf1, 0xc8, 0xf6, 0x19, 0xef, 0x7b, 0xd2, 0xdf,
	0xd5, 0xb3, 0x5e, 0x00, 0xa5, 0x47, 0x1d, 0x3d, 0x12, 0xb2, 0x34, 0x98, 0xd9, 0x11, 0x8b, 0x62,
	0x1e, 0x3e, 0x23, 0xc7, 0xb0, 0x98, 0xbd, 0x70, 0x67, 0x1c, 0xe6, 0xde, 0xda, 0x33, 0x0e, 0xf3,
	0x6f, 0xeb, 0xc9, 0x5a, 0x91, 0x72, 0x3d, 0x0e, 0xed, 0x20, 0xb2, 0x1d, 0x4c, 0x8b, 0xa7, 0x32,
	0xd0, 0xd3, 0xde, 0x46, 0x07, 0x9f, 0xe3, 0xce, 0x38, 0xcb, 0x44, 0xf9, 0xdb, 0x44, 0x7f, 0xab,
	0xa4, 0x9a, 0xf6, 0x37, 0x98, 0x64, 0x08, 0x4b, 0xa3, 0xf7, 0x26, 0x62, 0x64, 0x27, 0x91, 0x77,
	0xcb, 0xd8, 0xb8, 0x76, 0xa6, 0xcd, 0x58, 0xd4, 0xa8, 0xcf, 0xd1, 0x32, 0x6a, 0x7e, 0x23, 0x3f,
	0x9e, 0x66, 0x9d, 0x5e, 0x1b, 0x99, 0x4a, 0xae, 0xd7, 0xeb, 0x67, 0x1b, 0x29, 0xb7, 0x57, 0xd0,
	0xed, 0x1a, 0x59, 0xa9, 0x77, 0x68, 0xe0, 0xe2, 0xe3, 0xd3, 0x70, 0xe6, 0x11, 0x39, 0x86, 0x52,
	0x8a, 0x99, 0x66, 0xd2, 0x7d, 0x9c, 0xb6, 0x67, 0xd2, 0x3d, 0x87, 0xd0, 0x26, 0xce, 0x8c, 0x15,
	0x4c, 0xbd, 0xe4, 0xab, 0xba, 0xa5, 0x88, 0x1f, 0xf9, 0xad, 0x06, 0x95, 0x31, 0xda, 0x47, 0x46,
	0xd0, 0xcb, 0x25, 0x94, 0x99, 0xc9, 0x4e, 0x64, 0x8e, 0xc6, 0x75, 0xf4, 0xbf, 0x45, 0x36, 0xeb,
	0x03, 0xdf, 0x02, 0x64, 0xab, 0xf9, 0xcc, 0x1a, 0xd2, 0x51, 0x12, 0xc1, 0xe5, 0x91, 0x83, 0x37,
	0x13, 0x5e, 0xf9, 0x4c, 0x2d, 0x13, 0x5e, 0x13, 0xce, 0xed, 0x24, 0x63, 0x8d, 0x4a, 0xdd, 0x91,
	0x16, 0x96, 0x93, 0x78, 0x38, 0x85, 0xa5, 0xd1, 0x03, 0x2a, 0x13, 0x5b, 0x13, 0x4e, 0xcc, 0x4c,
	0x6c, 0x4d, 0x3a, 0xe1, 0x8c, 0xd7, 0xd0, 0xef, 0x8a, 0xb1, 0x5c, 0x67, 0x68, 0x62, 0x71, 0x6f,
	0xb0, 0x57, 0x34, 0x3e, 0xfa, 0xeb, 0xf3, 0x2d, 0xed, 0xd3, 0xe7, 0x5b, 0xda, 0x3f, 0x9e, 0x6f,
	0x69, 0xbf, 0x7f, 0xb1, 0x75, 0xe9, 0xd3, 0x17, 0x5b, 0x97, 0x3e, 0x7f, 0xb1, 0x75, 0xe9, 0xa3,
	0x7b, 0x2f, 0xe7, 0x3d, 0x3f, 0xb4, 0xf0, 0x1f, 0x3c, 0xc4, 0xe1, 0x57, 0xc7, 0x81, 0xdc, 0x6c,
	0xf3, 0x36, 0x7f, 0xbb, 0xd3, 0x44, 0xa1, 0x39, 0x8b, 0xb5, 0x6f, 0x7e, 0x1d, 0x00, 0x00, 0xff,
	0xff, 0x72, 0xcf, 0x22, 0x2a, 0x65, 0x22, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AsApiClient is the client API for AsApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AsApiClient interface {
	//coin
	ListAllCoinInfo(ctx context.Context, in *ListAllCoinRequest, opts ...grpc.CallOption) (*ListAllCoinResponse, error)
	//coin
	GetCoinInfo(ctx context.Context, in *GetCoinInfoRequest, opts ...grpc.CallOption) (*GetCoinInfoResponse, error)
	//
	NewDepositAddress(ctx context.Context, in *NewDepositAddressRequest, opts ...grpc.CallOption) (*NewDepositAddressResponse, error)
	// 
	HasAddress(ctx context.Context, in *HasAddressRequest, opts ...grpc.CallOption) (*HasAddressResponse, error)
	//
	CheckAddress(ctx context.Context, in *CheckAddressRequest, opts ...grpc.CallOption) (*CheckAddressResponse, error)
	//
	ListAllAddress(ctx context.Context, in *ListAllAddressRequest, opts ...grpc.CallOption) (*ListAllAddressResponse, error)
	//
	GetConfirmedTx(ctx context.Context, in *GetConfirmedTxRequest, opts ...grpc.CallOption) (*GetConfirmedTxResponse, error)
	//
	ListConfirmedTx(ctx context.Context, in *ListConfirmedTxRequest, opts ...grpc.CallOption) (*ListConfirmedTxResponse, error)
	//
	GetUnConfirmedTx(ctx context.Context, in *GetUnConfirmedTxRequest, opts ...grpc.CallOption) (*GetUnConfirmedTxResponse, error)
	//
	ListUnConfirmedTx(ctx context.Context, in *ListUnConfirmedTxRequest, opts ...grpc.CallOption) (*ListUnConfirmedTxResponse, error)
	//
	NewWithdraw(ctx context.Context, in *NewWithdrawRequest, opts ...grpc.CallOption) (*NewWithdrawResponse, error)
	//
	GetWithdrawDetail(ctx context.Context, in *GetWithdrawDetailRequest, opts ...grpc.CallOption) (*GetWithdrawDetailResponse, error)
	//
	CollectCallback(ctx context.Context, in *CollectCallbackRequest, opts ...grpc.CallOption) (*CollectCallbackResponse, error)
	//
	ImportOldAddress(ctx context.Context, in *ImportOldAddressRequest, opts ...grpc.CallOption) (*ImportOldAddressResponse, error)
}

type asApiClient struct {
	cc *grpc.ClientConn
}

func NewAsApiClient(cc *grpc.ClientConn) AsApiClient {
	return &asApiClient{cc}
}

func (c *asApiClient) ListAllCoinInfo(ctx context.Context, in *ListAllCoinRequest, opts ...grpc.CallOption) (*ListAllCoinResponse, error) {
	out := new(ListAllCoinResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/ListAllCoinInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) GetCoinInfo(ctx context.Context, in *GetCoinInfoRequest, opts ...grpc.CallOption) (*GetCoinInfoResponse, error) {
	out := new(GetCoinInfoResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/GetCoinInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) NewDepositAddress(ctx context.Context, in *NewDepositAddressRequest, opts ...grpc.CallOption) (*NewDepositAddressResponse, error) {
	out := new(NewDepositAddressResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/NewDepositAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) HasAddress(ctx context.Context, in *HasAddressRequest, opts ...grpc.CallOption) (*HasAddressResponse, error) {
	out := new(HasAddressResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/HasAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) CheckAddress(ctx context.Context, in *CheckAddressRequest, opts ...grpc.CallOption) (*CheckAddressResponse, error) {
	out := new(CheckAddressResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/CheckAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) ListAllAddress(ctx context.Context, in *ListAllAddressRequest, opts ...grpc.CallOption) (*ListAllAddressResponse, error) {
	out := new(ListAllAddressResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/ListAllAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) GetConfirmedTx(ctx context.Context, in *GetConfirmedTxRequest, opts ...grpc.CallOption) (*GetConfirmedTxResponse, error) {
	out := new(GetConfirmedTxResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/GetConfirmedTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) ListConfirmedTx(ctx context.Context, in *ListConfirmedTxRequest, opts ...grpc.CallOption) (*ListConfirmedTxResponse, error) {
	out := new(ListConfirmedTxResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/ListConfirmedTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) GetUnConfirmedTx(ctx context.Context, in *GetUnConfirmedTxRequest, opts ...grpc.CallOption) (*GetUnConfirmedTxResponse, error) {
	out := new(GetUnConfirmedTxResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/GetUnConfirmedTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) ListUnConfirmedTx(ctx context.Context, in *ListUnConfirmedTxRequest, opts ...grpc.CallOption) (*ListUnConfirmedTxResponse, error) {
	out := new(ListUnConfirmedTxResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/ListUnConfirmedTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) NewWithdraw(ctx context.Context, in *NewWithdrawRequest, opts ...grpc.CallOption) (*NewWithdrawResponse, error) {
	out := new(NewWithdrawResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/NewWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) GetWithdrawDetail(ctx context.Context, in *GetWithdrawDetailRequest, opts ...grpc.CallOption) (*GetWithdrawDetailResponse, error) {
	out := new(GetWithdrawDetailResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/GetWithdrawDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) CollectCallback(ctx context.Context, in *CollectCallbackRequest, opts ...grpc.CallOption) (*CollectCallbackResponse, error) {
	out := new(CollectCallbackResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/CollectCallback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asApiClient) ImportOldAddress(ctx context.Context, in *ImportOldAddressRequest, opts ...grpc.CallOption) (*ImportOldAddressResponse, error) {
	out := new(ImportOldAddressResponse)
	err := c.cc.Invoke(ctx, "/asapi.api.AsApi/ImportOldAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AsApiServer is the server API for AsApi service.
type AsApiServer interface {
	//coin
	ListAllCoinInfo(context.Context, *ListAllCoinRequest) (*ListAllCoinResponse, error)
	//coin
	GetCoinInfo(context.Context, *GetCoinInfoRequest) (*GetCoinInfoResponse, error)
	//
	NewDepositAddress(context.Context, *NewDepositAddressRequest) (*NewDepositAddressResponse, error)
	// 
	HasAddress(context.Context, *HasAddressRequest) (*HasAddressResponse, error)
	//
	CheckAddress(context.Context, *CheckAddressRequest) (*CheckAddressResponse, error)
	//
	ListAllAddress(context.Context, *ListAllAddressRequest) (*ListAllAddressResponse, error)
	//
	GetConfirmedTx(context.Context, *GetConfirmedTxRequest) (*GetConfirmedTxResponse, error)
	//
	ListConfirmedTx(context.Context, *ListConfirmedTxRequest) (*ListConfirmedTxResponse, error)
	//
	GetUnConfirmedTx(context.Context, *GetUnConfirmedTxRequest) (*GetUnConfirmedTxResponse, error)
	//
	ListUnConfirmedTx(context.Context, *ListUnConfirmedTxRequest) (*ListUnConfirmedTxResponse, error)
	//
	NewWithdraw(context.Context, *NewWithdrawRequest) (*NewWithdrawResponse, error)
	//
	GetWithdrawDetail(context.Context, *GetWithdrawDetailRequest) (*GetWithdrawDetailResponse, error)
	//
	CollectCallback(context.Context, *CollectCallbackRequest) (*CollectCallbackResponse, error)
	//
	ImportOldAddress(context.Context, *ImportOldAddressRequest) (*ImportOldAddressResponse, error)
}

// UnimplementedAsApiServer can be embedded to have forward compatible implementations.
type UnimplementedAsApiServer struct {
}

func (*UnimplementedAsApiServer) ListAllCoinInfo(ctx context.Context, req *ListAllCoinRequest) (*ListAllCoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllCoinInfo not implemented")
}
func (*UnimplementedAsApiServer) GetCoinInfo(ctx context.Context, req *GetCoinInfoRequest) (*GetCoinInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCoinInfo not implemented")
}
func (*UnimplementedAsApiServer) NewDepositAddress(ctx context.Context, req *NewDepositAddressRequest) (*NewDepositAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewDepositAddress not implemented")
}
func (*UnimplementedAsApiServer) HasAddress(ctx context.Context, req *HasAddressRequest) (*HasAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasAddress not implemented")
}
func (*UnimplementedAsApiServer) CheckAddress(ctx context.Context, req *CheckAddressRequest) (*CheckAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAddress not implemented")
}
func (*UnimplementedAsApiServer) ListAllAddress(ctx context.Context, req *ListAllAddressRequest) (*ListAllAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllAddress not implemented")
}
func (*UnimplementedAsApiServer) GetConfirmedTx(ctx context.Context, req *GetConfirmedTxRequest) (*GetConfirmedTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfirmedTx not implemented")
}
func (*UnimplementedAsApiServer) ListConfirmedTx(ctx context.Context, req *ListConfirmedTxRequest) (*ListConfirmedTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConfirmedTx not implemented")
}
func (*UnimplementedAsApiServer) GetUnConfirmedTx(ctx context.Context, req *GetUnConfirmedTxRequest) (*GetUnConfirmedTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnConfirmedTx not implemented")
}
func (*UnimplementedAsApiServer) ListUnConfirmedTx(ctx context.Context, req *ListUnConfirmedTxRequest) (*ListUnConfirmedTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUnConfirmedTx not implemented")
}
func (*UnimplementedAsApiServer) NewWithdraw(ctx context.Context, req *NewWithdrawRequest) (*NewWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewWithdraw not implemented")
}
func (*UnimplementedAsApiServer) GetWithdrawDetail(ctx context.Context, req *GetWithdrawDetailRequest) (*GetWithdrawDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWithdrawDetail not implemented")
}
func (*UnimplementedAsApiServer) CollectCallback(ctx context.Context, req *CollectCallbackRequest) (*CollectCallbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectCallback not implemented")
}
func (*UnimplementedAsApiServer) ImportOldAddress(ctx context.Context, req *ImportOldAddressRequest) (*ImportOldAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportOldAddress not implemented")
}

func RegisterAsApiServer(s *grpc.Server, srv AsApiServer) {
	s.RegisterService(&_AsApi_serviceDesc, srv)
}

func _AsApi_ListAllCoinInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAllCoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).ListAllCoinInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/ListAllCoinInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).ListAllCoinInfo(ctx, req.(*ListAllCoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_GetCoinInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCoinInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).GetCoinInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/GetCoinInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).GetCoinInfo(ctx, req.(*GetCoinInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_NewDepositAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewDepositAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).NewDepositAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/NewDepositAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).NewDepositAddress(ctx, req.(*NewDepositAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_HasAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).HasAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/HasAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).HasAddress(ctx, req.(*HasAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_CheckAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).CheckAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/CheckAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).CheckAddress(ctx, req.(*CheckAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_ListAllAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAllAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).ListAllAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/ListAllAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).ListAllAddress(ctx, req.(*ListAllAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_GetConfirmedTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfirmedTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).GetConfirmedTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/GetConfirmedTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).GetConfirmedTx(ctx, req.(*GetConfirmedTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_ListConfirmedTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConfirmedTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).ListConfirmedTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/ListConfirmedTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).ListConfirmedTx(ctx, req.(*ListConfirmedTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_GetUnConfirmedTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnConfirmedTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).GetUnConfirmedTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/GetUnConfirmedTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).GetUnConfirmedTx(ctx, req.(*GetUnConfirmedTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_ListUnConfirmedTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUnConfirmedTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).ListUnConfirmedTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/ListUnConfirmedTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).ListUnConfirmedTx(ctx, req.(*ListUnConfirmedTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_NewWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewWithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).NewWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/NewWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).NewWithdraw(ctx, req.(*NewWithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_GetWithdrawDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWithdrawDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).GetWithdrawDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/GetWithdrawDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).GetWithdrawDetail(ctx, req.(*GetWithdrawDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_CollectCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).CollectCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/CollectCallback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).CollectCallback(ctx, req.(*CollectCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsApi_ImportOldAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportOldAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsApiServer).ImportOldAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/asapi.api.AsApi/ImportOldAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsApiServer).ImportOldAddress(ctx, req.(*ImportOldAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "asapi.api.AsApi",
	HandlerType: (*AsApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAllCoinInfo",
			Handler:    _AsApi_ListAllCoinInfo_Handler,
		},
		{
			MethodName: "GetCoinInfo",
			Handler:    _AsApi_GetCoinInfo_Handler,
		},
		{
			MethodName: "NewDepositAddress",
			Handler:    _AsApi_NewDepositAddress_Handler,
		},
		{
			MethodName: "HasAddress",
			Handler:    _AsApi_HasAddress_Handler,
		},
		{
			MethodName: "CheckAddress",
			Handler:    _AsApi_CheckAddress_Handler,
		},
		{
			MethodName: "ListAllAddress",
			Handler:    _AsApi_ListAllAddress_Handler,
		},
		{
			MethodName: "GetConfirmedTx",
			Handler:    _AsApi_GetConfirmedTx_Handler,
		},
		{
			MethodName: "ListConfirmedTx",
			Handler:    _AsApi_ListConfirmedTx_Handler,
		},
		{
			MethodName: "GetUnConfirmedTx",
			Handler:    _AsApi_GetUnConfirmedTx_Handler,
		},
		{
			MethodName: "ListUnConfirmedTx",
			Handler:    _AsApi_ListUnConfirmedTx_Handler,
		},
		{
			MethodName: "NewWithdraw",
			Handler:    _AsApi_NewWithdraw_Handler,
		},
		{
			MethodName: "GetWithdrawDetail",
			Handler:    _AsApi_GetWithdrawDetail_Handler,
		},
		{
			MethodName: "CollectCallback",
			Handler:    _AsApi_CollectCallback_Handler,
		},
		{
			MethodName: "ImportOldAddress",
			Handler:    _AsApi_ImportOldAddress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asapi.proto",
}

func (m *ListAllCoinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllCoinRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllCoinRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CoinAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequireMemo) > 0 {
		i -= len(m.RequireMemo)
		copy(dAtA[i:], m.RequireMemo)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.RequireMemo)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.TokenAddress) > 0 {
		i -= len(m.TokenAddress)
		copy(dAtA[i:], m.TokenAddress)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.TokenAddress)))
		i--
		dAtA[i] = 0x6a
	}
	if m.DustThreshold != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.DustThreshold))
		i--
		dAtA[i] = 0x60
	}
	if m.ConfirmingThreshold != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ConfirmingThreshold))
		i--
		dAtA[i] = 0x58
	}
	if len(m.AbsEstimateFee) > 0 {
		i -= len(m.AbsEstimateFee)
		copy(dAtA[i:], m.AbsEstimateFee)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.AbsEstimateFee)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FeeCoin) > 0 {
		i -= len(m.FeeCoin)
		copy(dAtA[i:], m.FeeCoin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.FeeCoin)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AbsBalance) > 0 {
		i -= len(m.AbsBalance)
		copy(dAtA[i:], m.AbsBalance)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.AbsBalance)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Balance) > 0 {
		i -= len(m.Balance)
		copy(dAtA[i:], m.Balance)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Balance)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CanWithdraw {
		i--
		if m.CanWithdraw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CanDeposit {
		i--
		if m.CanDeposit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Decimal != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.Decimal))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DisplayCode) > 0 {
		i -= len(m.DisplayCode)
		copy(dAtA[i:], m.DisplayCode)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.DisplayCode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAllCoinResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllCoinResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllCoinResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAsapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAllCoinResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllCoinResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllCoinResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAsapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCoinInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCoinInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCoinInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCoinInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCoinInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCoinInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NewDepositAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewDepositAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewDepositAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NewDepositAddressResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewDepositAddressResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewDepositAddressResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NewDepositAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewDepositAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewDepositAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HasAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HasAddressResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasAddressResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasAddressResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HasAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListAllAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAllAddressResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllAddressResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllAddressResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAllAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAsapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Txinfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Txinfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Txinfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.FeeDecimal != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.FeeDecimal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.FeeAmount != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.FeeAmount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.FeeCoin) > 0 {
		i -= len(m.FeeCoin)
		copy(dAtA[i:], m.FeeCoin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.FeeCoin)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ConfirmedNum != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ConfirmedNum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ConfirmingThreshold != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ConfirmingThreshold))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.LastTime != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.LastTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.CreateTime != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x7a
	}
	if m.VoutN != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.VoutN))
		i--
		dAtA[i] = 0x70
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.AbsPlatformFee) > 0 {
		i -= len(m.AbsPlatformFee)
		copy(dAtA[i:], m.AbsPlatformFee)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.AbsPlatformFee)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AbsAmount) > 0 {
		i -= len(m.AbsAmount)
		copy(dAtA[i:], m.AbsAmount)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.AbsAmount)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Side) > 0 {
		i -= len(m.Side)
		copy(dAtA[i:], m.Side)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Side)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SourceAddressDetail) > 0 {
		i -= len(m.SourceAddressDetail)
		copy(dAtA[i:], m.SourceAddressDetail)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.SourceAddressDetail)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SourceAddress) > 0 {
		i -= len(m.SourceAddress)
		copy(dAtA[i:], m.SourceAddress)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.SourceAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Decimal != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.Decimal))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DisplayCode) > 0 {
		i -= len(m.DisplayCode)
		copy(dAtA[i:], m.DisplayCode)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.DisplayCode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetConfirmedTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfirmedTxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfirmedTxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetConfirmedTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfirmedTxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfirmedTxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListConfirmedTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListConfirmedTxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListConfirmedTxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BeginTime != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.BeginTime))
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.MinId != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.MinId))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxId != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Side) > 0 {
		i -= len(m.Side)
		copy(dAtA[i:], m.Side)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Side)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListConfirmedTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListConfirmedTxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListConfirmedTxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAsapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUnConfirmedTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUnConfirmedTxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUnConfirmedTxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUnConfirmedTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUnConfirmedTxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUnConfirmedTxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListUnConfirmedTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUnConfirmedTxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUnConfirmedTxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.MinId != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.MinId))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxId != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Side) > 0 {
		i -= len(m.Side)
		copy(dAtA[i:], m.Side)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Side)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListUnConfirmedTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUnConfirmedTxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUnConfirmedTxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAsapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NewWithdrawRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewWithdrawRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewWithdrawRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceInternal {
		i--
		if m.ForceInternal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ForceExternal {
		i--
		if m.ForceExternal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Amount != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NewWithdrawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewWithdrawResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewWithdrawResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetWithdrawDetailRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWithdrawDetailRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWithdrawDetailRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWithdrawDetailResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWithdrawDetailResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWithdrawDetailResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectCallbackRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectCallbackRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectCallbackRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Side) > 0 {
		i -= len(m.Side)
		copy(dAtA[i:], m.Side)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Side)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Confirm != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.Confirm))
		i--
		dAtA[i] = 0x78
	}
	if m.BlockTime != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x70
	}
	if m.BlockNum != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x68
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.FeeCoin) > 0 {
		i -= len(m.FeeCoin)
		copy(dAtA[i:], m.FeeCoin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.FeeCoin)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Fee) > 0 {
		i -= len(m.Fee)
		copy(dAtA[i:], m.Fee)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Fee)))
		i--
		dAtA[i] = 0x52
	}
	if m.OutNum != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.OutNum))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x3a
	}
	if m.OutN != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.OutN))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectCallbackResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectCallbackResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectCallbackResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImportOldAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportOldAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportOldAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImportOldAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportOldAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportOldAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintAsapi(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAsapi(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAsapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovAsapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ListAllCoinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CoinAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.DisplayCode)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Decimal != 0 {
		n += 1 + sovAsapi(uint64(m.Decimal))
	}
	if m.CanDeposit {
		n += 2
	}
	if m.CanWithdraw {
		n += 2
	}
	l = len(m.Balance)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.AbsBalance)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.FeeCoin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.AbsEstimateFee)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.ConfirmingThreshold != 0 {
		n += 1 + sovAsapi(uint64(m.ConfirmingThreshold))
	}
	if m.DustThreshold != 0 {
		n += 1 + sovAsapi(uint64(m.DustThreshold))
	}
	l = len(m.TokenAddress)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.RequireMemo)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *ListAllCoinResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovAsapi(uint64(l))
		}
	}
	return n
}

func (m *ListAllCoinResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovAsapi(uint64(l))
		}
	}
	return n
}

func (m *GetCoinInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *GetCoinInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *NewDepositAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *NewDepositAddressResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *NewDepositAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *HasAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *HasAddressResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *HasAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *CheckAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *CheckAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Result {
		n += 2
	}
	return n
}

func (m *ListAllAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *ListAllAddressResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *ListAllAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovAsapi(uint64(l))
		}
	}
	return n
}

func (m *Txinfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.DisplayCode)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Decimal != 0 {
		n += 1 + sovAsapi(uint64(m.Decimal))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.SourceAddress)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.SourceAddressDetail)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Side)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.AbsAmount)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.AbsPlatformFee)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.VoutN != 0 {
		n += 1 + sovAsapi(uint64(m.VoutN))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 2 + l + sovAsapi(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 2 + sovAsapi(uint64(m.CreateTime))
	}
	if m.LastTime != 0 {
		n += 2 + sovAsapi(uint64(m.LastTime))
	}
	if m.ConfirmingThreshold != 0 {
		n += 2 + sovAsapi(uint64(m.ConfirmingThreshold))
	}
	if m.ConfirmedNum != 0 {
		n += 2 + sovAsapi(uint64(m.ConfirmedNum))
	}
	l = len(m.FeeCoin)
	if l > 0 {
		n += 2 + l + sovAsapi(uint64(l))
	}
	if m.FeeAmount != 0 {
		n += 2 + sovAsapi(uint64(m.FeeAmount))
	}
	if m.FeeDecimal != 0 {
		n += 2 + sovAsapi(uint64(m.FeeDecimal))
	}
	l = len(m.Type)
	if l > 0 {
		n += 2 + l + sovAsapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 2 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *GetConfirmedTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *GetConfirmedTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *ListConfirmedTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Side)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.MaxId != 0 {
		n += 1 + sovAsapi(uint64(m.MaxId))
	}
	if m.MinId != 0 {
		n += 1 + sovAsapi(uint64(m.MinId))
	}
	if m.Limit != 0 {
		n += 1 + sovAsapi(uint64(m.Limit))
	}
	if m.BeginTime != 0 {
		n += 1 + sovAsapi(uint64(m.BeginTime))
	}
	return n
}

func (m *ListConfirmedTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovAsapi(uint64(l))
		}
	}
	return n
}

func (m *GetUnConfirmedTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *GetUnConfirmedTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *ListUnConfirmedTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Side)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.MaxId != 0 {
		n += 1 + sovAsapi(uint64(m.MaxId))
	}
	if m.MinId != 0 {
		n += 1 + sovAsapi(uint64(m.MinId))
	}
	if m.Limit != 0 {
		n += 1 + sovAsapi(uint64(m.Limit))
	}
	return n
}

func (m *ListUnConfirmedTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovAsapi(uint64(l))
		}
	}
	return n
}

func (m *NewWithdrawRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovAsapi(uint64(m.Amount))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.ForceExternal {
		n += 2
	}
	if m.ForceInternal {
		n += 2
	}
	return n
}

func (m *NewWithdrawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *GetWithdrawDetailRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *GetWithdrawDetailResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *CollectCallbackRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.OutN != 0 {
		n += 1 + sovAsapi(uint64(m.OutN))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.OutNum != 0 {
		n += 1 + sovAsapi(uint64(m.OutNum))
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.FeeCoin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sovAsapi(uint64(m.BlockNum))
	}
	if m.BlockTime != 0 {
		n += 1 + sovAsapi(uint64(m.BlockTime))
	}
	if m.Confirm != 0 {
		n += 1 + sovAsapi(uint64(m.Confirm))
	}
	l = len(m.Side)
	if l > 0 {
		n += 2 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *CollectCallbackResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *ImportOldAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	return n
}

func (m *ImportOldAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAsapi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovAsapi(uint64(l))
	}
	if m.Result {
		n += 2
	}
	return n
}

func sovAsapi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAsapi(x uint64) (n int) {
	return sovAsapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ListAllCoinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllCoinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllCoinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeposit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDeposit = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanWithdraw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanWithdraw = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsBalance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCoin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeCoin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsEstimateFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsEstimateFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmingThreshold", wireType)
			}
			m.ConfirmingThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmingThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DustThreshold", wireType)
			}
			m.DustThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DustThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireMemo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequireMemo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllCoinResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllCoinResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllCoinResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &CoinAsset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllCoinResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllCoinResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllCoinResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ListAllCoinResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCoinInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCoinInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCoinInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCoinInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCoinInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCoinInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &CoinAsset{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewDepositAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewDepositAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewDepositAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewDepositAddressResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewDepositAddressResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewDepositAddressResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewDepositAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewDepositAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewDepositAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &NewDepositAddressResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasAddressResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasAddressResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasAddressResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &HasAddressResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllAddressResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllAddressResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllAddressResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ListAllAddressResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Txinfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Txinfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Txinfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddressDetail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAddressDetail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Side = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsPlatformFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsPlatformFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoutN", wireType)
			}
			m.VoutN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoutN |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTime", wireType)
			}
			m.LastTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmingThreshold", wireType)
			}
			m.ConfirmingThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmingThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmedNum", wireType)
			}
			m.ConfirmedNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmedNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCoin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeCoin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeAmount", wireType)
			}
			m.FeeAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeDecimal", wireType)
			}
			m.FeeDecimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeDecimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfirmedTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfirmedTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfirmedTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfirmedTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfirmedTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfirmedTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Txinfo{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListConfirmedTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListConfirmedTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListConfirmedTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Side = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinId", wireType)
			}
			m.MinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTime", wireType)
			}
			m.BeginTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListConfirmedTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListConfirmedTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListConfirmedTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &Txinfo{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUnConfirmedTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUnConfirmedTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUnConfirmedTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUnConfirmedTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUnConfirmedTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUnConfirmedTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Txinfo{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUnConfirmedTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUnConfirmedTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUnConfirmedTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Side = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinId", wireType)
			}
			m.MinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUnConfirmedTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUnConfirmedTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUnConfirmedTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &Txinfo{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewWithdrawRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewWithdrawRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewWithdrawRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceExternal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceExternal = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceInternal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceInternal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewWithdrawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewWithdrawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewWithdrawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWithdrawDetailRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWithdrawDetailRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWithdrawDetailRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWithdrawDetailResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWithdrawDetailResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWithdrawDetailResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Txinfo{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectCallbackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectCallbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectCallbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutN", wireType)
			}
			m.OutN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutN |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutNum", wireType)
			}
			m.OutNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCoin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeCoin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirm", wireType)
			}
			m.Confirm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confirm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Side = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectCallbackResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectCallbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectCallbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportOldAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportOldAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportOldAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportOldAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportOldAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportOldAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAsapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAsapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAsapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAsapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAsapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAsapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAsapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAsapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAsapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAsapi = fmt.Errorf("proto: unexpected end of group")
)
