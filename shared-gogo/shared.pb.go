// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shared.proto

package pbshared

import (
	bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time "bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StateType int32

const (
	StateType_State_Unknown  StateType = 0
	StateType_State_Freeze   StateType = 1
	StateType_State_Active   StateType = 2
	StateType_State_UnActive StateType = 3
	StateType_State_Delete   StateType = 4
	StateType_State_MaxState StateType = 999
)

var StateType_name = map[int32]string{
	0:   "State_Unknown",
	1:   "State_Freeze",
	2:   "State_Active",
	3:   "State_UnActive",
	4:   "State_Delete",
	999: "State_MaxState",
}

var StateType_value = map[string]int32{
	"State_Unknown":  0,
	"State_Freeze":   1,
	"State_Active":   2,
	"State_UnActive": 3,
	"State_Delete":   4,
	"State_MaxState": 999,
}

func (x StateType) String() string {
	return proto.EnumName(StateType_name, int32(x))
}

func (StateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{0}
}

type ACodeOpType int32

const (
	ACodeOpType_ACode_OpType_Unknown    ACodeOpType = 0
	ACodeOpType_ACode_OpType_Active     ACodeOpType = 1
	ACodeOpType_ACode_OpType_ModifyPass ACodeOpType = 2
	ACodeOpType_ACode_OpType_Modify2FA  ACodeOpType = 3
)

var ACodeOpType_name = map[int32]string{
	0: "ACode_OpType_Unknown",
	1: "ACode_OpType_Active",
	2: "ACode_OpType_ModifyPass",
	3: "ACode_OpType_Modify2FA",
}

var ACodeOpType_value = map[string]int32{
	"ACode_OpType_Unknown":    0,
	"ACode_OpType_Active":     1,
	"ACode_OpType_ModifyPass": 2,
	"ACode_OpType_Modify2FA":  3,
}

func (x ACodeOpType) String() string {
	return proto.EnumName(ACodeOpType_name, int32(x))
}

func (ACodeOpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{1}
}

type ACodeStateType int32

const (
	ACodeStateType_ACode_State_Unknown ACodeStateType = 0
	ACodeStateType_ACode_State_UnOp    ACodeStateType = 1
	ACodeStateType_ACode_State_Invalid ACodeStateType = 2
	ACodeStateType_ACode_State_Success ACodeStateType = 3
	ACodeStateType_ACode_State_Fail    ACodeStateType = 4
)

var ACodeStateType_name = map[int32]string{
	0: "ACode_State_Unknown",
	1: "ACode_State_UnOp",
	2: "ACode_State_Invalid",
	3: "ACode_State_Success",
	4: "ACode_State_Fail",
}

var ACodeStateType_value = map[string]int32{
	"ACode_State_Unknown": 0,
	"ACode_State_UnOp":    1,
	"ACode_State_Invalid": 2,
	"ACode_State_Success": 3,
	"ACode_State_Fail":    4,
}

func (x ACodeStateType) String() string {
	return proto.EnumName(ACodeStateType_name, int32(x))
}

func (ACodeStateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{2}
}

type WalletType int32

const (
	//hd钱包
	WalletType_WalletType_HD WalletType = 0
	//导入钱包
	WalletType_WalletType_Import WalletType = 1
	//系统钱包
	WalletType_WalletType_Sys WalletType = 2
)

var WalletType_name = map[int32]string{
	0: "WalletType_HD",
	1: "WalletType_Import",
	2: "WalletType_Sys",
}

var WalletType_value = map[string]int32{
	"WalletType_HD":     0,
	"WalletType_Import": 1,
	"WalletType_Sys":    2,
}

func (x WalletType) String() string {
	return proto.EnumName(WalletType_name, int32(x))
}

func (WalletType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{3}
}

type AddressType int32

const (
	AddressType_AddressType_Unknown AddressType = 0
	AddressType_OLD                 AddressType = 1
	AddressType_NEW                 AddressType = 2
)

var AddressType_name = map[int32]string{
	0: "AddressType_Unknown",
	1: "OLD",
	2: "NEW",
}

var AddressType_value = map[string]int32{
	"AddressType_Unknown": 0,
	"OLD":                 1,
	"NEW":                 2,
}

func (x AddressType) String() string {
	return proto.EnumName(AddressType_name, int32(x))
}

func (AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{4}
}

type BillType int32

const (
	BillType_BillType_Unknown         BillType = 0
	BillType_BillType_Amount_In       BillType = 1
	BillType_BillType_Amount_Out      BillType = 2
	BillType_BillType_Fee_In          BillType = 3
	BillType_BillType_Fee_Out         BillType = 4
	BillType_BillType_PlatformFee_In  BillType = 5
	BillType_BillType_PlatformFee_Out BillType = 6
)

var BillType_name = map[int32]string{
	0: "BillType_Unknown",
	1: "BillType_Amount_In",
	2: "BillType_Amount_Out",
	3: "BillType_Fee_In",
	4: "BillType_Fee_Out",
	5: "BillType_PlatformFee_In",
	6: "BillType_PlatformFee_Out",
}

var BillType_value = map[string]int32{
	"BillType_Unknown":         0,
	"BillType_Amount_In":       1,
	"BillType_Amount_Out":      2,
	"BillType_Fee_In":          3,
	"BillType_Fee_Out":         4,
	"BillType_PlatformFee_In":  5,
	"BillType_PlatformFee_Out": 6,
}

func (x BillType) String() string {
	return proto.EnumName(BillType_name, int32(x))
}

func (BillType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{5}
}

type TxStateType int32

const (
	TxStateType_TxState_Unknown         TxStateType = 0
	TxStateType_TxState_Submit          TxStateType = 1
	TxStateType_TxState_CallbackApprove TxStateType = 2
	TxStateType_TxState_Approve         TxStateType = 3
	TxStateType_TxState_WaitSend        TxStateType = 9
	TxStateType_TxState_Sending         TxStateType = 10
	TxStateType_TxState_Confirming      TxStateType = 11
	TxStateType_TxState_UnGenBill       TxStateType = 12
	TxStateType_TxState_Finished        TxStateType = 13
	TxStateType_TxState_Fail            TxStateType = 14
	TxStateType_TxState_Invalid         TxStateType = 15
)

var TxStateType_name = map[int32]string{
	0:  "TxState_Unknown",
	1:  "TxState_Submit",
	2:  "TxState_CallbackApprove",
	3:  "TxState_Approve",
	9:  "TxState_WaitSend",
	10: "TxState_Sending",
	11: "TxState_Confirming",
	12: "TxState_UnGenBill",
	13: "TxState_Finished",
	14: "TxState_Fail",
	15: "TxState_Invalid",
}

var TxStateType_value = map[string]int32{
	"TxState_Unknown":         0,
	"TxState_Submit":          1,
	"TxState_CallbackApprove": 2,
	"TxState_Approve":         3,
	"TxState_WaitSend":        9,
	"TxState_Sending":         10,
	"TxState_Confirming":      11,
	"TxState_UnGenBill":       12,
	"TxState_Finished":        13,
	"TxState_Fail":            14,
	"TxState_Invalid":         15,
}

func (x TxStateType) String() string {
	return proto.EnumName(TxStateType_name, int32(x))
}

func (TxStateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{6}
}

type TxSideType int32

const (
	TxSideType_TxSide_Unknown  TxSideType = 0
	TxSideType_TxSide_Withdraw TxSideType = 1
	TxSideType_TxSide_Deposit  TxSideType = 2
)

var TxSideType_name = map[int32]string{
	0: "TxSide_Unknown",
	1: "TxSide_Withdraw",
	2: "TxSide_Deposit",
}

var TxSideType_value = map[string]int32{
	"TxSide_Unknown":  0,
	"TxSide_Withdraw": 1,
	"TxSide_Deposit":  2,
}

func (x TxSideType) String() string {
	return proto.EnumName(TxSideType_name, int32(x))
}

func (TxSideType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{7}
}

type TxTypeType int32

const (
	TxTypeType_TxType_Unknown  TxTypeType = 0
	TxTypeType_TxType_Internal TxTypeType = 1
	TxTypeType_TxType_External TxTypeType = 2
)

var TxTypeType_name = map[int32]string{
	0: "TxType_Unknown",
	1: "TxType_Internal",
	2: "TxType_External",
}

var TxTypeType_value = map[string]int32{
	"TxType_Unknown":  0,
	"TxType_Internal": 1,
	"TxType_External": 2,
}

func (x TxTypeType) String() string {
	return proto.EnumName(TxTypeType_name, int32(x))
}

func (TxTypeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{8}
}

type MsgType int32

const (
	MsgType_MsgType_Unknown           MsgType = 0
	MsgType_MsgType_Withdraw_Confirm  MsgType = 1
	MsgType_MsgType_Withdraw_Finished MsgType = 2
	MsgType_MsgType_Withdraw_Pending  MsgType = 3
	MsgType_MsgType_Withdraw_Failed   MsgType = 4
	MsgType_MsgType_Deposit_Finished  MsgType = 5
	MsgType_MsgType_Deposit_Pending   MsgType = 6
	MsgType_MsgType_Deposit_Failed    MsgType = 7
)

var MsgType_name = map[int32]string{
	0: "MsgType_Unknown",
	1: "MsgType_Withdraw_Confirm",
	2: "MsgType_Withdraw_Finished",
	3: "MsgType_Withdraw_Pending",
	4: "MsgType_Withdraw_Failed",
	5: "MsgType_Deposit_Finished",
	6: "MsgType_Deposit_Pending",
	7: "MsgType_Deposit_Failed",
}

var MsgType_value = map[string]int32{
	"MsgType_Unknown":           0,
	"MsgType_Withdraw_Confirm":  1,
	"MsgType_Withdraw_Finished": 2,
	"MsgType_Withdraw_Pending":  3,
	"MsgType_Withdraw_Failed":   4,
	"MsgType_Deposit_Finished":  5,
	"MsgType_Deposit_Pending":   6,
	"MsgType_Deposit_Failed":    7,
}

func (x MsgType) String() string {
	return proto.EnumName(MsgType_name, int32(x))
}

func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{9}
}

type PushStatusType int32

const (
	PushStatusType_PushStatusType_UnPush  PushStatusType = 0
	PushStatusType_PushStatusType_Pushing PushStatusType = 1
	PushStatusType_PushStatusType_Success PushStatusType = 2
	PushStatusType_PushStatusType_Fail    PushStatusType = 3
)

var PushStatusType_name = map[int32]string{
	0: "PushStatusType_UnPush",
	1: "PushStatusType_Pushing",
	2: "PushStatusType_Success",
	3: "PushStatusType_Fail",
}

var PushStatusType_value = map[string]int32{
	"PushStatusType_UnPush":  0,
	"PushStatusType_Pushing": 1,
	"PushStatusType_Success": 2,
	"PushStatusType_Fail":    3,
}

func (x PushStatusType) String() string {
	return proto.EnumName(PushStatusType_name, int32(x))
}

func (PushStatusType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{10}
}

type NotifyState int32

const (
	NotifyState_UnSend        NotifyState = 0
	NotifyState_NotifySuccess NotifyState = 1
	NotifyState_NotifyFailed  NotifyState = 2
)

var NotifyState_name = map[int32]string{
	0: "UnSend",
	1: "NotifySuccess",
	2: "NotifyFailed",
}

var NotifyState_value = map[string]int32{
	"UnSend":        0,
	"NotifySuccess": 1,
	"NotifyFailed":  2,
}

func (x NotifyState) String() string {
	return proto.EnumName(NotifyState_name, int32(x))
}

func (NotifyState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{11}
}

type ErrInfo struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//错误代码
	Code int32 `protobuf:"varint,2,opt,name=Code,proto3" json:"code"`
	//错误描述
	Detail string `protobuf:"bytes,3,opt,name=Detail,proto3" json:"detail"`
}

func (m *ErrInfo) Reset()         { *m = ErrInfo{} }
func (m *ErrInfo) String() string { return proto.CompactTextString(m) }
func (*ErrInfo) ProtoMessage()    {}
func (*ErrInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{0}
}
func (m *ErrInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrInfo.Merge(m, src)
}
func (m *ErrInfo) XXX_Size() int {
	return m.Size()
}
func (m *ErrInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ErrInfo proto.InternalMessageInfo

func (m *ErrInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ErrInfo) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ErrInfo) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

type UserLoginLog struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//登录用户id
	Uid int64 `protobuf:"varint,2,opt,name=Uid,proto3" json:"uid" gorm:"index;"`
	//IP
	IP string `protobuf:"bytes,3,opt,name=IP,proto3" json:"ip" gorm:"size:20"`
	//设备
	UserAgent string `protobuf:"bytes,4,opt,name=UserAgent,proto3" json:"user_agent" gorm:"size:256"`
	//备注
	Comment string `protobuf:"bytes,5,opt,name=Comment,proto3" json:"comment" gorm:"size:100"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
}

func (m *UserLoginLog) Reset()         { *m = UserLoginLog{} }
func (m *UserLoginLog) String() string { return proto.CompactTextString(m) }
func (*UserLoginLog) ProtoMessage()    {}
func (*UserLoginLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{1}
}
func (m *UserLoginLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserLoginLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserLoginLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserLoginLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserLoginLog.Merge(m, src)
}
func (m *UserLoginLog) XXX_Size() int {
	return m.Size()
}
func (m *UserLoginLog) XXX_DiscardUnknown() {
	xxx_messageInfo_UserLoginLog.DiscardUnknown(m)
}

var xxx_messageInfo_UserLoginLog proto.InternalMessageInfo

func (m *UserLoginLog) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserLoginLog) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UserLoginLog) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *UserLoginLog) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *UserLoginLog) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *UserLoginLog) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

type AccountInfo struct {
	//账户id
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户名称
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"name" gorm:"size:255;"`
	//详细描述
	Description string `protobuf:"bytes,3,opt,name=Description,proto3" json:"description" gorm:"size:255;"`
	//账户状态 1 冻结 2 已激活 3 未激活 4 已删除
	State StateType `protobuf:"varint,4,opt,name=State,proto3,enum=shared.api.StateType" json:"state"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *AccountInfo) Reset()         { *m = AccountInfo{} }
func (m *AccountInfo) String() string { return proto.CompactTextString(m) }
func (*AccountInfo) ProtoMessage()    {}
func (*AccountInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{2}
}
func (m *AccountInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountInfo.Merge(m, src)
}
func (m *AccountInfo) XXX_Size() int {
	return m.Size()
}
func (m *AccountInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AccountInfo proto.InternalMessageInfo

func (m *AccountInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AccountInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AccountInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AccountInfo) GetState() StateType {
	if m != nil {
		return m.State
	}
	return StateType_State_Unknown
}

func (m *AccountInfo) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *AccountInfo) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type UserActivationCode struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	RefAid int64 `protobuf:"varint,2,opt,name=RefAid,proto3" json:"-" gorm:"index:idx_user_accode_aid;"`
	//用户id
	RefUid int64 `protobuf:"varint,3,opt,name=RefUid,proto3" json:"uid" gorm:"index:idx_user_accode_uid;"`
	//操作类型 1 激活 2 重置密码 3 重置2FA
	OpName ACodeOpType `protobuf:"varint,4,opt,name=OpName,proto3,enum=shared.api.ACodeOpType" json:"op_name" gorm:"unique;"`
	//激活码
	Code string `protobuf:"bytes,5,opt,name=Code,proto3" json:"code" gorm:"unique;"`
	//操作结果
	State ACodeStateType `protobuf:"varint,6,opt,name=State,proto3,enum=shared.api.ACodeStateType" json:"state" gorm:"index;"`
	//操作时间
	OpTime bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,7,opt,name=OpTime,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"op_time" gorm:"type:datetime;"`
	//有效期开始时间
	BeginTime bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,8,opt,name=BeginTime,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"begin_time" gorm:"type:datetime;"`
	//有效期结束时间
	EndTime bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,9,opt,name=EndTime,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"end_time" gorm:"type:datetime;"`
}

func (m *UserActivationCode) Reset()         { *m = UserActivationCode{} }
func (m *UserActivationCode) String() string { return proto.CompactTextString(m) }
func (*UserActivationCode) ProtoMessage()    {}
func (*UserActivationCode) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{3}
}
func (m *UserActivationCode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserActivationCode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserActivationCode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserActivationCode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserActivationCode.Merge(m, src)
}
func (m *UserActivationCode) XXX_Size() int {
	return m.Size()
}
func (m *UserActivationCode) XXX_DiscardUnknown() {
	xxx_messageInfo_UserActivationCode.DiscardUnknown(m)
}

var xxx_messageInfo_UserActivationCode proto.InternalMessageInfo

func (m *UserActivationCode) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserActivationCode) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *UserActivationCode) GetRefUid() int64 {
	if m != nil {
		return m.RefUid
	}
	return 0
}

func (m *UserActivationCode) GetOpName() ACodeOpType {
	if m != nil {
		return m.OpName
	}
	return ACodeOpType_ACode_OpType_Unknown
}

func (m *UserActivationCode) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *UserActivationCode) GetState() ACodeStateType {
	if m != nil {
		return m.State
	}
	return ACodeStateType_ACode_State_Unknown
}

func (m *UserActivationCode) GetOpTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.OpTime
	}
	return 0
}

func (m *UserActivationCode) GetBeginTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.BeginTime
	}
	return 0
}

func (m *UserActivationCode) GetEndTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// 用户信息
type UserInfo struct {
	// 用户ID
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	// 账户ID
	AccountId int64 `protobuf:"varint,2,opt,name=AccountId,proto3" json:"account_id" gorm:"index;"`
	// 用户名称
	UserName string `protobuf:"bytes,3,opt,name=UserName,proto3" json:"user_name" gorm:"index;size:128"`
	// 邮箱
	Email string `protobuf:"bytes,4,opt,name=Email,proto3" json:"email" gorm:"column:email;unique;size:100"`
	// 地区代码
	CountryCode string `protobuf:"bytes,5,opt,name=CountryCode,proto3" json:"country_code" gorm:"size:60;"`
	// 手机号
	Mobile string `protobuf:"bytes,6,opt,name=Mobile,proto3" json:"mobile" gorm:"column:mobile;unique;size:60"`
	// pass=md5(Nonce+Pass)
	Nonce int64 `protobuf:"varint,7,opt,name=Nonce,proto3" json:"-"`
	// 用户密码
	Password string `protobuf:"bytes,8,opt,name=Password,proto3" json:"-" gorm:"size:100;"`
	// 二次验证
	TwoFA string `protobuf:"bytes,9,opt,name=TwoFA,proto3" json:"two_fa" gorm:"column:two_fa;size:128"`
	// 语言
	Lang string `protobuf:"bytes,10,opt,name=Lang,proto3" json:"lang" gorm:"size:20;"`
	// 货币
	Currency string `protobuf:"bytes,11,opt,name=Currency,proto3" json:"currency" gorm:"size:20;"`
	// 欢迎语(防钓鱼码)
	Welcome string `protobuf:"bytes,12,opt,name=Welcome,proto3" json:"welcome" gorm:"size:100;"`
	// 邀请人ID
	InvitedById int64 `protobuf:"varint,13,opt,name=InvitedById,proto3" json:"invited_by_id"`
	// 激活码 aes(op,time)
	ActivationCode string `protobuf:"bytes,14,opt,name=ActivationCode,proto3" json:"activation_code" gorm:"unique;size:100"`
	// 登录错误次数
	LoginErrNum int32 `protobuf:"varint,15,opt,name=LoginErrNum,proto3" json:"login_err_num"`
	// 用户状态
	Status StateType `protobuf:"varint,16,opt,name=Status,proto3,enum=shared.api.StateType" json:"status"`
	// 创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,17,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	// 最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,18,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *UserInfo) Reset()         { *m = UserInfo{} }
func (m *UserInfo) String() string { return proto.CompactTextString(m) }
func (*UserInfo) ProtoMessage()    {}
func (*UserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{4}
}
func (m *UserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserInfo.Merge(m, src)
}
func (m *UserInfo) XXX_Size() int {
	return m.Size()
}
func (m *UserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UserInfo proto.InternalMessageInfo

func (m *UserInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserInfo) GetAccountId() int64 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *UserInfo) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *UserInfo) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserInfo) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *UserInfo) GetMobile() string {
	if m != nil {
		return m.Mobile
	}
	return ""
}

func (m *UserInfo) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserInfo) GetTwoFA() string {
	if m != nil {
		return m.TwoFA
	}
	return ""
}

func (m *UserInfo) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *UserInfo) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *UserInfo) GetWelcome() string {
	if m != nil {
		return m.Welcome
	}
	return ""
}

func (m *UserInfo) GetInvitedById() int64 {
	if m != nil {
		return m.InvitedById
	}
	return 0
}

func (m *UserInfo) GetActivationCode() string {
	if m != nil {
		return m.ActivationCode
	}
	return ""
}

func (m *UserInfo) GetLoginErrNum() int32 {
	if m != nil {
		return m.LoginErrNum
	}
	return 0
}

func (m *UserInfo) GetStatus() StateType {
	if m != nil {
		return m.Status
	}
	return StateType_State_Unknown
}

func (m *UserInfo) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *UserInfo) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type ApiKey struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	// 账户id
	AccountId int64 `protobuf:"varint,2,opt,name=AccountId,proto3" json:"account_id" gorm:"index;"`
	// 钱包id
	WalletId int64 `protobuf:"varint,3,opt,name=WalletId,proto3" json:"wallet_id" gorm:"index;"`
	// 权限类型：0:未知;1:查询;2:操作及查询;3:提现、操作及查询。
	AccessType int32 `protobuf:"varint,4,opt,name=AccessType,proto3" json:"access_type"`
	// API用户访问KEY
	AccessKey string `protobuf:"bytes,5,opt,name=AccessKey,proto3" json:"access_key" gorm:"unique;not null;size:64;"`
	// API用户验签公钥
	PublicKey string `protobuf:"bytes,6,opt,name=PublicKey,proto3" json:"public_key" gorm:"size:128;"`
	// 创建用户id
	UserId int64 `protobuf:"varint,7,opt,name=UserId,proto3" json:"user_id"`
	// IP白名单，多个IP用逗号分隔，为空不限制
	IpLimit string `protobuf:"bytes,8,opt,name=IpLimit,proto3" json:"ip_limit" gorm:"size:512;"`
	// 备注
	Remark string `protobuf:"bytes,9,opt,name=Remark,proto3" json:"remark" gorm:"size:255;"`
	// ApiKey状态。0:未知;1:冻结;2:已激活;3:未激活;4:已删除。
	Status StateType `protobuf:"varint,10,opt,name=status,proto3,enum=shared.api.StateType" json:"status"`
	// 创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	// 最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *ApiKey) Reset()         { *m = ApiKey{} }
func (m *ApiKey) String() string { return proto.CompactTextString(m) }
func (*ApiKey) ProtoMessage()    {}
func (*ApiKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{5}
}
func (m *ApiKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApiKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApiKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApiKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApiKey.Merge(m, src)
}
func (m *ApiKey) XXX_Size() int {
	return m.Size()
}
func (m *ApiKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ApiKey.DiscardUnknown(m)
}

var xxx_messageInfo_ApiKey proto.InternalMessageInfo

func (m *ApiKey) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ApiKey) GetAccountId() int64 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *ApiKey) GetWalletId() int64 {
	if m != nil {
		return m.WalletId
	}
	return 0
}

func (m *ApiKey) GetAccessType() int32 {
	if m != nil {
		return m.AccessType
	}
	return 0
}

func (m *ApiKey) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *ApiKey) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *ApiKey) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ApiKey) GetIpLimit() string {
	if m != nil {
		return m.IpLimit
	}
	return ""
}

func (m *ApiKey) GetRemark() string {
	if m != nil {
		return m.Remark
	}
	return ""
}

func (m *ApiKey) GetStatus() StateType {
	if m != nil {
		return m.Status
	}
	return StateType_State_Unknown
}

func (m *ApiKey) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *ApiKey) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

//地区代码
type CountryCode struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//地区代码
	Code string `protobuf:"bytes,2,opt,name=Code,proto3" json:"code" gorm:"size:60;"`
	//描述
	Description string `protobuf:"bytes,3,opt,name=Description,proto3" json:"description" gorm:"size:255;"`
}

func (m *CountryCode) Reset()         { *m = CountryCode{} }
func (m *CountryCode) String() string { return proto.CompactTextString(m) }
func (*CountryCode) ProtoMessage()    {}
func (*CountryCode) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{6}
}
func (m *CountryCode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountryCode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountryCode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountryCode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountryCode.Merge(m, src)
}
func (m *CountryCode) XXX_Size() int {
	return m.Size()
}
func (m *CountryCode) XXX_DiscardUnknown() {
	xxx_messageInfo_CountryCode.DiscardUnknown(m)
}

var xxx_messageInfo_CountryCode proto.InternalMessageInfo

func (m *CountryCode) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CountryCode) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *CountryCode) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// 角色表
type RoleItem struct {
	// 角色ID
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	// 角色名称
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"name" gorm:"size:128;unique;"`
	// 备注
	Remark string `protobuf:"bytes,3,opt,name=Remark,proto3" json:"remark" gorm:"size:100;"`
	// 创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,4,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	// 最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,5,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *RoleItem) Reset()         { *m = RoleItem{} }
func (m *RoleItem) String() string { return proto.CompactTextString(m) }
func (*RoleItem) ProtoMessage()    {}
func (*RoleItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{7}
}
func (m *RoleItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleItem.Merge(m, src)
}
func (m *RoleItem) XXX_Size() int {
	return m.Size()
}
func (m *RoleItem) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleItem.DiscardUnknown(m)
}

var xxx_messageInfo_RoleItem proto.InternalMessageInfo

func (m *RoleItem) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoleItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RoleItem) GetRemark() string {
	if m != nil {
		return m.Remark
	}
	return ""
}

func (m *RoleItem) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *RoleItem) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

// 权限表
type AuthItem struct {
	// 权限ID
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//模块名
	Module string `protobuf:"bytes,2,opt,name=Module,proto3" json:"module" gorm:"size:50;"`
	//权限名称
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name" gorm:"size:128;unique;"`
	//此权限对应的页面url
	Url string `protobuf:"bytes,4,opt,name=Url,proto3" json:"url" gorm:"size:100;"`
	//描述
	Description string `protobuf:"bytes,5,opt,name=Description,proto3" json:"description" gorm:"size:255;"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,6,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,7,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *AuthItem) Reset()         { *m = AuthItem{} }
func (m *AuthItem) String() string { return proto.CompactTextString(m) }
func (*AuthItem) ProtoMessage()    {}
func (*AuthItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{8}
}
func (m *AuthItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthItem.Merge(m, src)
}
func (m *AuthItem) XXX_Size() int {
	return m.Size()
}
func (m *AuthItem) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthItem.DiscardUnknown(m)
}

var xxx_messageInfo_AuthItem proto.InternalMessageInfo

func (m *AuthItem) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AuthItem) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *AuthItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AuthItem) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *AuthItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AuthItem) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *AuthItem) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

// 角色权限对应关系
type RoleAuth struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	// 角色ID
	RoleId int64 `protobuf:"varint,2,opt,name=RoleId,proto3" json:"role_id"`
	// 权限ID
	AuthId int64 `protobuf:"varint,3,opt,name=AuthId,proto3" json:"auth_id"`
}

func (m *RoleAuth) Reset()         { *m = RoleAuth{} }
func (m *RoleAuth) String() string { return proto.CompactTextString(m) }
func (*RoleAuth) ProtoMessage()    {}
func (*RoleAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{9}
}
func (m *RoleAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleAuth.Merge(m, src)
}
func (m *RoleAuth) XXX_Size() int {
	return m.Size()
}
func (m *RoleAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleAuth.DiscardUnknown(m)
}

var xxx_messageInfo_RoleAuth proto.InternalMessageInfo

func (m *RoleAuth) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoleAuth) GetRoleId() int64 {
	if m != nil {
		return m.RoleId
	}
	return 0
}

func (m *RoleAuth) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

//用户角色权限分配
type AuthAssign struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	RefAid int64 `protobuf:"varint,2,opt,name=RefAid,proto3" json:"aid" gorm:"index;"`
	//用户id
	RefUid int64 `protobuf:"varint,3,opt,name=RefUid,proto3" json:"uid" gorm:"index;"`
	// 角色ID
	RoleId int64 `protobuf:"varint,4,opt,name=RoleId,proto3" json:"role_id" gorm:"index;"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
}

func (m *AuthAssign) Reset()         { *m = AuthAssign{} }
func (m *AuthAssign) String() string { return proto.CompactTextString(m) }
func (*AuthAssign) ProtoMessage()    {}
func (*AuthAssign) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{10}
}
func (m *AuthAssign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthAssign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthAssign.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthAssign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthAssign.Merge(m, src)
}
func (m *AuthAssign) XXX_Size() int {
	return m.Size()
}
func (m *AuthAssign) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthAssign.DiscardUnknown(m)
}

var xxx_messageInfo_AuthAssign proto.InternalMessageInfo

func (m *AuthAssign) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AuthAssign) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *AuthAssign) GetRefUid() int64 {
	if m != nil {
		return m.RefUid
	}
	return 0
}

func (m *AuthAssign) GetRoleId() int64 {
	if m != nil {
		return m.RoleId
	}
	return 0
}

func (m *AuthAssign) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

//普通用户
type UserData struct {
	//用户id
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	AccountId int64 `protobuf:"varint,2,opt,name=AccountId,proto3" json:"account_id"`
	//账户名称
	AccountName string `protobuf:"bytes,3,opt,name=AccountName,proto3" json:"account_name"`
	//账户描述
	AccountDescription string `protobuf:"bytes,4,opt,name=AccountDescription,proto3" json:"account_description"`
	//防钓鱼码
	Welcome string `protobuf:"bytes,5,opt,name=Welcome,proto3" json:"welcome"`
	//用户状态 1 冻结 2 已激活 3 未激活 4 已删除
	Status StateType `protobuf:"varint,6,opt,name=Status,proto3,enum=shared.api.StateType" json:"status"`
	//邀请用户id
	InvitationRefUid int64 `protobuf:"varint,7,opt,name=InvitationRefUid,proto3" json:"invitation_uid"`
	//激活码
	ActivationCode string `protobuf:"bytes,8,opt,name=ActivationCode,proto3" json:"activation_code"`
	//用户名称
	UserName string `protobuf:"bytes,9,opt,name=UserName,proto3" json:"user_name"`
	//用户密码
	Pass  string `protobuf:"bytes,10,opt,name=Pass,proto3" json:"pass"`
	Nonce int64  `protobuf:"varint,11,opt,name=Nonce,proto3" json:"nonce"`
	//邮箱
	EMail string `protobuf:"bytes,12,opt,name=EMail,proto3" json:"email"`
	//手机号
	Mobile string `protobuf:"bytes,13,opt,name=Mobile,proto3" json:"mobile"`
	//地区代码
	CountryCode string `protobuf:"bytes,14,opt,name=CountryCode,proto3" json:"country_code"`
	//二次验证
	TwoFA string `protobuf:"bytes,15,opt,name=TwoFA,proto3" json:"two_fa"`
	//权限
	Perms []*AuthItem `protobuf:"bytes,20,rep,name=Perms,proto3" json:"perms"`
	//角色
	Roles []*RoleItem `protobuf:"bytes,21,rep,name=Roles,proto3" json:"roles"`
	//是否为管理员
	Admin bool `protobuf:"varint,22,opt,name=Admin,proto3" json:"admin"`
	//语言
	Lang string `protobuf:"bytes,23,opt,name=Lang,proto3" json:"lang"`
	//货币
	Currency string `protobuf:"bytes,24,opt,name=Currency,proto3" json:"currency"`
	//登录错误次数
	LoginErrNum int32 `protobuf:"varint,25,opt,name=LoginErrNum,proto3" json:"login_err_num"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,30,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,31,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *UserData) Reset()         { *m = UserData{} }
func (m *UserData) String() string { return proto.CompactTextString(m) }
func (*UserData) ProtoMessage()    {}
func (*UserData) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{11}
}
func (m *UserData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserData.Merge(m, src)
}
func (m *UserData) XXX_Size() int {
	return m.Size()
}
func (m *UserData) XXX_DiscardUnknown() {
	xxx_messageInfo_UserData.DiscardUnknown(m)
}

var xxx_messageInfo_UserData proto.InternalMessageInfo

func (m *UserData) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserData) GetAccountId() int64 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *UserData) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *UserData) GetAccountDescription() string {
	if m != nil {
		return m.AccountDescription
	}
	return ""
}

func (m *UserData) GetWelcome() string {
	if m != nil {
		return m.Welcome
	}
	return ""
}

func (m *UserData) GetStatus() StateType {
	if m != nil {
		return m.Status
	}
	return StateType_State_Unknown
}

func (m *UserData) GetInvitationRefUid() int64 {
	if m != nil {
		return m.InvitationRefUid
	}
	return 0
}

func (m *UserData) GetActivationCode() string {
	if m != nil {
		return m.ActivationCode
	}
	return ""
}

func (m *UserData) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *UserData) GetPass() string {
	if m != nil {
		return m.Pass
	}
	return ""
}

func (m *UserData) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserData) GetEMail() string {
	if m != nil {
		return m.EMail
	}
	return ""
}

func (m *UserData) GetMobile() string {
	if m != nil {
		return m.Mobile
	}
	return ""
}

func (m *UserData) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *UserData) GetTwoFA() string {
	if m != nil {
		return m.TwoFA
	}
	return ""
}

func (m *UserData) GetPerms() []*AuthItem {
	if m != nil {
		return m.Perms
	}
	return nil
}

func (m *UserData) GetRoles() []*RoleItem {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *UserData) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

func (m *UserData) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *UserData) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *UserData) GetLoginErrNum() int32 {
	if m != nil {
		return m.LoginErrNum
	}
	return 0
}

func (m *UserData) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *UserData) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type RespPerm struct {
	Perms []*AuthItem `protobuf:"bytes,1,rep,name=Perms,proto3" json:"Perms,omitempty"`
	Roles []*RoleItem `protobuf:"bytes,2,rep,name=Roles,proto3" json:"Roles,omitempty"`
	Admin bool        `protobuf:"varint,3,opt,name=Admin,proto3" json:"Admin,omitempty"`
}

func (m *RespPerm) Reset()         { *m = RespPerm{} }
func (m *RespPerm) String() string { return proto.CompactTextString(m) }
func (*RespPerm) ProtoMessage()    {}
func (*RespPerm) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{12}
}
func (m *RespPerm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespPerm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespPerm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespPerm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespPerm.Merge(m, src)
}
func (m *RespPerm) XXX_Size() int {
	return m.Size()
}
func (m *RespPerm) XXX_DiscardUnknown() {
	xxx_messageInfo_RespPerm.DiscardUnknown(m)
}

var xxx_messageInfo_RespPerm proto.InternalMessageInfo

func (m *RespPerm) GetPerms() []*AuthItem {
	if m != nil {
		return m.Perms
	}
	return nil
}

func (m *RespPerm) GetRoles() []*RoleItem {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *RespPerm) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

// session中缓存的权限数据。
type SessionAuthItem struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//    //模块名
	//    string Module = 2;
	//权限名称
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name"`
	//此权限对应的页面url
	Url string `protobuf:"bytes,5,opt,name=Url,proto3" json:"url"`
}

func (m *SessionAuthItem) Reset()         { *m = SessionAuthItem{} }
func (m *SessionAuthItem) String() string { return proto.CompactTextString(m) }
func (*SessionAuthItem) ProtoMessage()    {}
func (*SessionAuthItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{13}
}
func (m *SessionAuthItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionAuthItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionAuthItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionAuthItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionAuthItem.Merge(m, src)
}
func (m *SessionAuthItem) XXX_Size() int {
	return m.Size()
}
func (m *SessionAuthItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionAuthItem.DiscardUnknown(m)
}

var xxx_messageInfo_SessionAuthItem proto.InternalMessageInfo

func (m *SessionAuthItem) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SessionAuthItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SessionAuthItem) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// session中缓存的角色数据
type SessionRoleItem struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//权限名称
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
}

func (m *SessionRoleItem) Reset()         { *m = SessionRoleItem{} }
func (m *SessionRoleItem) String() string { return proto.CompactTextString(m) }
func (*SessionRoleItem) ProtoMessage()    {}
func (*SessionRoleItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{14}
}
func (m *SessionRoleItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionRoleItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionRoleItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionRoleItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionRoleItem.Merge(m, src)
}
func (m *SessionRoleItem) XXX_Size() int {
	return m.Size()
}
func (m *SessionRoleItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionRoleItem.DiscardUnknown(m)
}

var xxx_messageInfo_SessionRoleItem proto.InternalMessageInfo

func (m *SessionRoleItem) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SessionRoleItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// 在session中缓存的信息
type SessionUser struct {
	//用户id
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	AccountId int64 `protobuf:"varint,2,opt,name=AccountId,proto3" json:"account_id"`
	//账户名称
	AccountName string `protobuf:"bytes,3,opt,name=AccountName,proto3" json:"account_name"`
	//用户状态 1 冻结 2 已激活 3 未激活 4 已删除
	State StateType `protobuf:"varint,4,opt,name=State,proto3,enum=shared.api.StateType" json:"state"`
	//邀请用户id
	InvitationRefUid int64 `protobuf:"varint,5,opt,name=InvitationRefUid,proto3" json:"invitation_uid"`
	//用户名称
	UserName string `protobuf:"bytes,6,opt,name=UserName,proto3" json:"user_name"`
	Nonce    int64  `protobuf:"varint,7,opt,name=Nonce,proto3" json:"nonce"`
	//邮箱
	EMail string `protobuf:"bytes,8,opt,name=EMail,proto3" json:"email"`
	//地区代码
	CountryCode string `protobuf:"bytes,9,opt,name=CountryCode,proto3" json:"country_code"`
	//手机号
	Mobile string `protobuf:"bytes,10,opt,name=Mobile,proto3" json:"mobile"`
	//是否为管理员
	Admin bool `protobuf:"varint,11,opt,name=Admin,proto3" json:"admin"`
	//语言
	Lang string `protobuf:"bytes,12,opt,name=Lang,proto3" json:"lang"`
	//货币
	Currency string `protobuf:"bytes,13,opt,name=Currency,proto3" json:"currency"`
	//二次验证
	TwoFA string `protobuf:"bytes,14,opt,name=TwoFA,proto3" json:"two_fa"`
	//防钓鱼码
	Welcome string `protobuf:"bytes,15,opt,name=Welcome,proto3" json:"welcome"`
	//角色
	Roles []*SessionRoleItem `protobuf:"bytes,20,rep,name=Roles,proto3" json:"roles"`
	//权限
	Perms []*SessionAuthItem `protobuf:"bytes,21,rep,name=Perms,proto3" json:"perms"`
}

func (m *SessionUser) Reset()         { *m = SessionUser{} }
func (m *SessionUser) String() string { return proto.CompactTextString(m) }
func (*SessionUser) ProtoMessage()    {}
func (*SessionUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{15}
}
func (m *SessionUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionUser.Merge(m, src)
}
func (m *SessionUser) XXX_Size() int {
	return m.Size()
}
func (m *SessionUser) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionUser.DiscardUnknown(m)
}

var xxx_messageInfo_SessionUser proto.InternalMessageInfo

func (m *SessionUser) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SessionUser) GetAccountId() int64 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *SessionUser) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *SessionUser) GetState() StateType {
	if m != nil {
		return m.State
	}
	return StateType_State_Unknown
}

func (m *SessionUser) GetInvitationRefUid() int64 {
	if m != nil {
		return m.InvitationRefUid
	}
	return 0
}

func (m *SessionUser) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *SessionUser) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SessionUser) GetEMail() string {
	if m != nil {
		return m.EMail
	}
	return ""
}

func (m *SessionUser) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *SessionUser) GetMobile() string {
	if m != nil {
		return m.Mobile
	}
	return ""
}

func (m *SessionUser) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

func (m *SessionUser) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *SessionUser) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *SessionUser) GetTwoFA() string {
	if m != nil {
		return m.TwoFA
	}
	return ""
}

func (m *SessionUser) GetWelcome() string {
	if m != nil {
		return m.Welcome
	}
	return ""
}

func (m *SessionUser) GetRoles() []*SessionRoleItem {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *SessionUser) GetPerms() []*SessionAuthItem {
	if m != nil {
		return m.Perms
	}
	return nil
}

// session获取角色、权限等信息时的返回值。
type SessionData struct {
	Roles   []*SessionRoleItem `protobuf:"bytes,1,rep,name=Roles,proto3" json:"roles"`
	Perms   []*SessionAuthItem `protobuf:"bytes,2,rep,name=Perms,proto3" json:"perms"`
	IsAdmin bool               `protobuf:"varint,3,opt,name=isAdmin,proto3" json:"is_admin"`
}

func (m *SessionData) Reset()         { *m = SessionData{} }
func (m *SessionData) String() string { return proto.CompactTextString(m) }
func (*SessionData) ProtoMessage()    {}
func (*SessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{16}
}
func (m *SessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionData.Merge(m, src)
}
func (m *SessionData) XXX_Size() int {
	return m.Size()
}
func (m *SessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionData proto.InternalMessageInfo

func (m *SessionData) GetRoles() []*SessionRoleItem {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *SessionData) GetPerms() []*SessionAuthItem {
	if m != nil {
		return m.Perms
	}
	return nil
}

func (m *SessionData) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

// 向缓存中存放的ApiKey信息。
type CacheApiKey struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	// 账户id
	AccountId int64 `protobuf:"varint,2,opt,name=AccountId,proto3" json:"account_id"`
	// 钱包id
	WalletId int64 `protobuf:"varint,3,opt,name=WalletId,proto3" json:"wallet_id"`
	// 权限类型：0:未知;1:查询;2:操作及查询;3:提现、操作及查询。
	AccessType int32 `protobuf:"varint,4,opt,name=AccessType,proto3" json:"access_type"`
	// API用户访问KEY
	AccessKey string `protobuf:"bytes,5,opt,name=AccessKey,proto3" json:"access_key"`
	// API用户验签公钥
	PublicKey string `protobuf:"bytes,6,opt,name=PublicKey,proto3" json:"public_key"`
	// 创建用户id
	UserId int64 `protobuf:"varint,7,opt,name=UserId,proto3" json:"user_id"`
	// IP白名单，多个IP用逗号分隔，为空不限制
	IpLimit string `protobuf:"bytes,8,opt,name=IpLimit,proto3" json:"ip_limit"`
}

func (m *CacheApiKey) Reset()         { *m = CacheApiKey{} }
func (m *CacheApiKey) String() string { return proto.CompactTextString(m) }
func (*CacheApiKey) ProtoMessage()    {}
func (*CacheApiKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{17}
}
func (m *CacheApiKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheApiKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheApiKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheApiKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheApiKey.Merge(m, src)
}
func (m *CacheApiKey) XXX_Size() int {
	return m.Size()
}
func (m *CacheApiKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheApiKey.DiscardUnknown(m)
}

var xxx_messageInfo_CacheApiKey proto.InternalMessageInfo

func (m *CacheApiKey) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CacheApiKey) GetAccountId() int64 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CacheApiKey) GetWalletId() int64 {
	if m != nil {
		return m.WalletId
	}
	return 0
}

func (m *CacheApiKey) GetAccessType() int32 {
	if m != nil {
		return m.AccessType
	}
	return 0
}

func (m *CacheApiKey) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *CacheApiKey) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *CacheApiKey) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CacheApiKey) GetIpLimit() string {
	if m != nil {
		return m.IpLimit
	}
	return ""
}

//链的基本信息
type BlockInfo struct {
	Id        int64                                                      `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	RefCid    int64                                                      `protobuf:"varint,2,opt,name=RefCid,proto3" json:"RefCid,omitempty"`
	Symbol    string                                                     `protobuf:"bytes,3,opt,name=Symbol,proto3" json:"Symbol,omitempty"`
	Chain     string                                                     `protobuf:"bytes,4,opt,name=Chain,proto3" json:"Chain,omitempty"`
	BlockNum  int64                                                      `protobuf:"varint,5,opt,name=BlockNum,proto3" json:"BlockNum,omitempty"`
	BlockTime bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,6,opt,name=BlockTime,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"block_time" gorm:"type:datetime;"`
	UpdateAt  bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,7,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *BlockInfo) Reset()         { *m = BlockInfo{} }
func (m *BlockInfo) String() string { return proto.CompactTextString(m) }
func (*BlockInfo) ProtoMessage()    {}
func (*BlockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{18}
}
func (m *BlockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockInfo.Merge(m, src)
}
func (m *BlockInfo) XXX_Size() int {
	return m.Size()
}
func (m *BlockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlockInfo proto.InternalMessageInfo

func (m *BlockInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BlockInfo) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *BlockInfo) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *BlockInfo) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *BlockInfo) GetBlockNum() int64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *BlockInfo) GetBlockTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *BlockInfo) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type WalletInfo struct {
	//钱包id
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	RefAid int64 `protobuf:"varint,2,opt,name=RefAid,proto3" json:"aid" gorm:"index:idx_wallet_info_aid"`
	//钱包名称
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name" gorm:"size:100;"`
	//钱包状态1 冻结/2 激活
	State StateType `protobuf:"varint,4,opt,name=State,proto3,enum=shared.api.StateType" json:"state"`
	//钱包类型
	WType WalletType `protobuf:"varint,5,opt,name=WType,proto3,enum=shared.api.WalletType" json:"wtype" gorm:"column:wtype;"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,50,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,51,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *WalletInfo) Reset()         { *m = WalletInfo{} }
func (m *WalletInfo) String() string { return proto.CompactTextString(m) }
func (*WalletInfo) ProtoMessage()    {}
func (*WalletInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{19}
}
func (m *WalletInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletInfo.Merge(m, src)
}
func (m *WalletInfo) XXX_Size() int {
	return m.Size()
}
func (m *WalletInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WalletInfo proto.InternalMessageInfo

func (m *WalletInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WalletInfo) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *WalletInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WalletInfo) GetState() StateType {
	if m != nil {
		return m.State
	}
	return StateType_State_Unknown
}

func (m *WalletInfo) GetWType() WalletType {
	if m != nil {
		return m.WType
	}
	return WalletType_WalletType_HD
}

func (m *WalletInfo) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *WalletInfo) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

//地址表有两个功能：
//1、地址表 记录分配的地址，对于eth等公链，token地址=链地址
//2、地址余额表 记录地址的链上余额，充值、提现成功入账后都会去刷新链上地址余额，公链token在有充值/提现时，会生成token的地址及余额记录
type AddressInfo struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户
	AccountId int64 `protobuf:"varint,2,opt,name=AccountId,proto3" json:"account_id" gorm:"index:idx_wai_aid_wid_cid"`
	//创建地址的用户id
	UserId int64 `protobuf:"varint,3,opt,name=UserId,proto3" json:"user_id" gorm:"index:idx_wai_uid"`
	//钱包id
	WalletId int64 `protobuf:"varint,4,opt,name=WalletId,proto3" json:"wallet_id" gorm:"index:idx_wai_aid_wid_cid"`
	//Coin id
	CoinId int64 `protobuf:"varint,5,opt,name=CoinId,proto3" json:"coin_id" gorm:"index:idx_wai_aid_wid_cid"`
	//Coin代号
	Symbol string `protobuf:"bytes,6,opt,name=Symbol,proto3" json:"symbol" gorm:"size:16;"`
	//hd地址的路径
	HdPath string `protobuf:"bytes,7,opt,name=HdPath,proto3" json:"hd_path"`
	//hd 的序号
	AddressIndex int32 `protobuf:"varint,8,opt,name=AddressIndex,proto3" json:"address_index"`
	//label
	Label string `protobuf:"bytes,9,opt,name=Label,proto3" json:"label" gorm:"size:100;"`
	//地址
	Address string `protobuf:"bytes,10,opt,name=Address,proto3" json:"address" gorm:"index:idx_wai_address;size:100"`
	//memo eos用
	Memo string `protobuf:"bytes,11,opt,name=Memo,proto3" json:"memo" gorm:"index:idx_wai_address;size:100"`
	//公钥
	PublicKey string `protobuf:"bytes,12,opt,name=PublicKey,proto3" json:"public_key" gorm:"size:100;"`
	//地址状态 2 State_Active正常可用; 3 State_UnActive 隐藏; 4 State_Delete 删除
	State StateType `protobuf:"varint,13,opt,name=State,proto3,enum=shared.api.StateType" json:"state"`
	//utxo模型不用此字段；账户模型：地址余额，生成充值/提现账单时都会去链上查询一下地址的余额，方便对账
	Balance float64 `protobuf:"fixed64,14,opt,name=Balance,proto3" json:"balance"`
	//地址版本 1 旧地址，从外部导入 2 新地址，钱包hd服务生成
	Type AddressType `protobuf:"varint,15,opt,name=Type,proto3,enum=shared.api.AddressType" json:"type"`
	// 监听状态。0:未监听;1:已监听;2:已移除。
	MonitorStatus int32 `protobuf:"varint,16,opt,name=MonitorStatus,proto3" json:"monitor_status"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *AddressInfo) Reset()         { *m = AddressInfo{} }
func (m *AddressInfo) String() string { return proto.CompactTextString(m) }
func (*AddressInfo) ProtoMessage()    {}
func (*AddressInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{20}
}
func (m *AddressInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressInfo.Merge(m, src)
}
func (m *AddressInfo) XXX_Size() int {
	return m.Size()
}
func (m *AddressInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AddressInfo proto.InternalMessageInfo

func (m *AddressInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AddressInfo) GetAccountId() int64 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *AddressInfo) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AddressInfo) GetWalletId() int64 {
	if m != nil {
		return m.WalletId
	}
	return 0
}

func (m *AddressInfo) GetCoinId() int64 {
	if m != nil {
		return m.CoinId
	}
	return 0
}

func (m *AddressInfo) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *AddressInfo) GetHdPath() string {
	if m != nil {
		return m.HdPath
	}
	return ""
}

func (m *AddressInfo) GetAddressIndex() int32 {
	if m != nil {
		return m.AddressIndex
	}
	return 0
}

func (m *AddressInfo) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *AddressInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AddressInfo) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *AddressInfo) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *AddressInfo) GetState() StateType {
	if m != nil {
		return m.State
	}
	return StateType_State_Unknown
}

func (m *AddressInfo) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *AddressInfo) GetType() AddressType {
	if m != nil {
		return m.Type
	}
	return AddressType_AddressType_Unknown
}

func (m *AddressInfo) GetMonitorStatus() int32 {
	if m != nil {
		return m.MonitorStatus
	}
	return 0
}

func (m *AddressInfo) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *AddressInfo) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type CoinInfo struct {
	//Coin id
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//链 eg:eth
	Chain string `protobuf:"bytes,2,opt,name=Chain,proto3" json:"chain" gorm:"size:50;index:idx_coin_info_chain_symbol"`
	//Coin代号 eg: bix
	Symbol string `protobuf:"bytes,3,opt,name=Symbol,proto3" json:"symbol" gorm:"size:50;index:idx_coin_info_chain_symbol"`
	//币种全称
	Description string `protobuf:"bytes,4,opt,name=Description,proto3" json:"description" gorm:"size:255;"`
	//合约地址、发行id等
	CoinAddr string `protobuf:"bytes,5,opt,name=CoinAddr,proto3" json:"coin_addr" gorm:"size:60;"`
	//小数点位数 eg:eth是18位
	OriginalDecimal int32 `protobuf:"varint,6,opt,name=OriginalDecimal,proto3" json:"original_decimal"`
	//钱包支持的小数点位数
	ValidDecimal int32 `protobuf:"varint,7,opt,name=ValidDecimal,proto3" json:"valid_decimal"`
	//是否上架
	IsActive bool `protobuf:"varint,8,opt,name=IsActive,proto3" json:"is_active"`
	//是否能充值 平台开关
	CanDeposit bool `protobuf:"varint,9,opt,name=CanDeposit,proto3" json:"can_deposit"`
	//是否能提现
	CanWithdraw bool `protobuf:"varint,10,opt,name=CanWithdraw,proto3" json:"can_withdraw"`
	//区块链浏览器地址
	ExplorerUrl string `protobuf:"bytes,11,opt,name=ExplorerUrl,proto3" json:"explorer_url"`
	//coin logo
	Icon string `protobuf:"bytes,12,opt,name=Icon,proto3" json:"icon"`
	//链类型
	IsUtxo bool `protobuf:"varint,13,opt,name=IsUtxo,proto3" json:"is_utxo"`
	//是否需要归集
	IsCollect bool `protobuf:"varint,14,opt,name=IsCollect,proto3" json:"is_collect"`
	//确认数阀值
	ConfirmingThreshold int32 `protobuf:"varint,17,opt,name=ConfirmingThreshold,proto3" json:"confirming_threshold"`
	//最小交易额
	DustThreshold int32 `protobuf:"varint,18,opt,name=DustThreshold,proto3" json:"dust_threshold"`
	//是否需要memo
	RequestMemo bool `protobuf:"varint,19,opt,name=RequestMemo,proto3" json:"request_memo"`
	//访问coinwallet的地址
	RpcUrl string `protobuf:"bytes,20,opt,name=RpcUrl,proto3" json:"rpc_url" gorm:"size:255;"`
	//bip39 对应的CoinType
	HdCoinType int32 `protobuf:"varint,21,opt,name=HdCoinType,proto3" json:"hd_coin_type"`
	//归集的最小金额
	CollectAmountMin float64 `protobuf:"fixed64,22,opt,name=CollectAmountMin,proto3" json:"collect_amount_min"`
	//费率
	SlowFeeUnitPrice float64 `protobuf:"fixed64,30,opt,name=SlowFeeUnitPrice,proto3" json:"slow_fee_unit_price"`
	//费率
	MiddleFeeUnitPrice float64 `protobuf:"fixed64,31,opt,name=MiddleFeeUnitPrice,proto3" json:"middle_fee_unit_price"`
	//费率
	FastFeeUnitPrice float64 `protobuf:"fixed64,32,opt,name=FastFeeUnitPrice,proto3" json:"fast_fee_unit_price"`
	//一次转账需要占用的系统资源数量
	FeeCount float64 `protobuf:"fixed64,33,opt,name=FeeCount,proto3" json:"fee_count"`
	//一次转账需要占用的系统资源数量的最大值
	FeeLimitCount float64 `protobuf:"fixed64,34,opt,name=FeeLimitCount,proto3" json:"fee_limit_count"`
	//fee coin id
	FeeRefCid int64 `protobuf:"varint,36,opt,name=FeeRefCid,proto3" json:"fee_ref_cid"`
	//fee coin symbol
	FeeSymbol string `protobuf:"bytes,37,opt,name=FeeSymbol,proto3" json:"fee_symbol" gorm:"size:16;"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,50,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,51,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *CoinInfo) Reset()         { *m = CoinInfo{} }
func (m *CoinInfo) String() string { return proto.CompactTextString(m) }
func (*CoinInfo) ProtoMessage()    {}
func (*CoinInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{21}
}
func (m *CoinInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinInfo.Merge(m, src)
}
func (m *CoinInfo) XXX_Size() int {
	return m.Size()
}
func (m *CoinInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CoinInfo proto.InternalMessageInfo

func (m *CoinInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CoinInfo) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *CoinInfo) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CoinInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CoinInfo) GetCoinAddr() string {
	if m != nil {
		return m.CoinAddr
	}
	return ""
}

func (m *CoinInfo) GetOriginalDecimal() int32 {
	if m != nil {
		return m.OriginalDecimal
	}
	return 0
}

func (m *CoinInfo) GetValidDecimal() int32 {
	if m != nil {
		return m.ValidDecimal
	}
	return 0
}

func (m *CoinInfo) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *CoinInfo) GetCanDeposit() bool {
	if m != nil {
		return m.CanDeposit
	}
	return false
}

func (m *CoinInfo) GetCanWithdraw() bool {
	if m != nil {
		return m.CanWithdraw
	}
	return false
}

func (m *CoinInfo) GetExplorerUrl() string {
	if m != nil {
		return m.ExplorerUrl
	}
	return ""
}

func (m *CoinInfo) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *CoinInfo) GetIsUtxo() bool {
	if m != nil {
		return m.IsUtxo
	}
	return false
}

func (m *CoinInfo) GetIsCollect() bool {
	if m != nil {
		return m.IsCollect
	}
	return false
}

func (m *CoinInfo) GetConfirmingThreshold() int32 {
	if m != nil {
		return m.ConfirmingThreshold
	}
	return 0
}

func (m *CoinInfo) GetDustThreshold() int32 {
	if m != nil {
		return m.DustThreshold
	}
	return 0
}

func (m *CoinInfo) GetRequestMemo() bool {
	if m != nil {
		return m.RequestMemo
	}
	return false
}

func (m *CoinInfo) GetRpcUrl() string {
	if m != nil {
		return m.RpcUrl
	}
	return ""
}

func (m *CoinInfo) GetHdCoinType() int32 {
	if m != nil {
		return m.HdCoinType
	}
	return 0
}

func (m *CoinInfo) GetCollectAmountMin() float64 {
	if m != nil {
		return m.CollectAmountMin
	}
	return 0
}

func (m *CoinInfo) GetSlowFeeUnitPrice() float64 {
	if m != nil {
		return m.SlowFeeUnitPrice
	}
	return 0
}

func (m *CoinInfo) GetMiddleFeeUnitPrice() float64 {
	if m != nil {
		return m.MiddleFeeUnitPrice
	}
	return 0
}

func (m *CoinInfo) GetFastFeeUnitPrice() float64 {
	if m != nil {
		return m.FastFeeUnitPrice
	}
	return 0
}

func (m *CoinInfo) GetFeeCount() float64 {
	if m != nil {
		return m.FeeCount
	}
	return 0
}

func (m *CoinInfo) GetFeeLimitCount() float64 {
	if m != nil {
		return m.FeeLimitCount
	}
	return 0
}

func (m *CoinInfo) GetFeeRefCid() int64 {
	if m != nil {
		return m.FeeRefCid
	}
	return 0
}

func (m *CoinInfo) GetFeeSymbol() string {
	if m != nil {
		return m.FeeSymbol
	}
	return ""
}

func (m *CoinInfo) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *CoinInfo) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

// 钱包币种索引表。
type WalletHdIndex struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	// 账户ID
	AccountId int64 `protobuf:"varint,2,opt,name=AccountId,proto3" json:"account_id" gorm:"index:IDX_AID_CID_INDEX"`
	// 币种ID
	CoinId int64 `protobuf:"varint,3,opt,name=CoinId,proto3" json:"coin_id" gorm:"index:IDX_AID_CID_INDEX"`
	// 地址最后使用的序号
	AddressIndexLast int32 `protobuf:"varint,4,opt,name=AddressIndexLast,proto3" json:"address_index_last" gorm:"index:IDX_AID_CID_INDEX"`
	// 创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	// 最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *WalletHdIndex) Reset()         { *m = WalletHdIndex{} }
func (m *WalletHdIndex) String() string { return proto.CompactTextString(m) }
func (*WalletHdIndex) ProtoMessage()    {}
func (*WalletHdIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{22}
}
func (m *WalletHdIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletHdIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletHdIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletHdIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletHdIndex.Merge(m, src)
}
func (m *WalletHdIndex) XXX_Size() int {
	return m.Size()
}
func (m *WalletHdIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletHdIndex.DiscardUnknown(m)
}

var xxx_messageInfo_WalletHdIndex proto.InternalMessageInfo

func (m *WalletHdIndex) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WalletHdIndex) GetAccountId() int64 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *WalletHdIndex) GetCoinId() int64 {
	if m != nil {
		return m.CoinId
	}
	return 0
}

func (m *WalletHdIndex) GetAddressIndexLast() int32 {
	if m != nil {
		return m.AddressIndexLast
	}
	return 0
}

func (m *WalletHdIndex) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *WalletHdIndex) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type WalletCoin struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//钱包id
	RefWid int64 `protobuf:"varint,2,opt,name=RefWid,proto3" json:"wid" gorm:"unique:idx_wallet_coin_aid_wid_cid"`
	//账户id
	RefAid int64 `protobuf:"varint,3,opt,name=RefAid,proto3" json:"aid" gorm:"unique:idx_wallet_coin_aid_wid_cid"`
	//Coin id
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid" gorm:"unique:idx_wallet_coin_aid_wid_cid"`
	//Coin 代号
	Symbol string `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol" gorm:"size:50;"`
	//每次提现按固定fee扣收，与实际fee的差额作为平台服务费
	CanFixedFee bool `protobuf:"varint,6,opt,name=CanFixedFee,proto3" json:"can_fixed_fee"`
	//固定的fee
	FixedFee float64 `protobuf:"fixed64,7,opt,name=FixedFee,proto3" json:"fixed_fee"`
	//是否允许平台额外收取提现的服务费
	CanPlatformFee bool `protobuf:"varint,8,opt,name=CanPlatformFee,proto3" json:"can_platform_fee"`
	//平台收取的fee，针对账户收取，不同账户可能不一样
	PlatformFee float64 `protobuf:"fixed64,9,opt,name=PlatformFee,proto3" json:"platform_fee"`
	FeeRefCid   int64   `protobuf:"varint,10,opt,name=FeeRefCid,proto3" json:"fee_ref_cid"`
	FeeSymbol   string  `protobuf:"bytes,11,opt,name=FeeSymbol,proto3" json:"fee_symbol" gorm:"size:50;"`
	//是否能充值 账户开关
	CanDeposit bool `protobuf:"varint,12,opt,name=CanDeposit,proto3" json:"can_deposit"`
	//是否能提现
	CanWithdraw bool `protobuf:"varint,13,opt,name=CanWithdraw,proto3" json:"can_withdraw"`
	//分配地址时，传递给coinWallet的label，为空则后台自动填充
	Label string `protobuf:"bytes,14,opt,name=Label,proto3" json:"Label" gorm:"size:255;"`
	//是否允许生成充值地址 管理没有私钥的钱包时，此钱包就不能生成充值地址，避免地址混合一块
	CanNewAddress bool `protobuf:"varint,15,opt,name=CanNewAddress,proto3" json:"can_new_address"`
	//地址状态 2 State_Active正常可用;  4 State_Delete 删除 使用软删除
	State StateType `protobuf:"varint,17,opt,name=State,proto3,enum=shared.api.StateType" json:"state"`
	//是否可用,对账对不上时,禁止提现
	IsActive bool `protobuf:"varint,18,opt,name=IsActive,proto3" json:"is_active"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *WalletCoin) Reset()         { *m = WalletCoin{} }
func (m *WalletCoin) String() string { return proto.CompactTextString(m) }
func (*WalletCoin) ProtoMessage()    {}
func (*WalletCoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{23}
}
func (m *WalletCoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletCoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletCoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletCoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletCoin.Merge(m, src)
}
func (m *WalletCoin) XXX_Size() int {
	return m.Size()
}
func (m *WalletCoin) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletCoin.DiscardUnknown(m)
}

var xxx_messageInfo_WalletCoin proto.InternalMessageInfo

func (m *WalletCoin) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WalletCoin) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *WalletCoin) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *WalletCoin) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *WalletCoin) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *WalletCoin) GetCanFixedFee() bool {
	if m != nil {
		return m.CanFixedFee
	}
	return false
}

func (m *WalletCoin) GetFixedFee() float64 {
	if m != nil {
		return m.FixedFee
	}
	return 0
}

func (m *WalletCoin) GetCanPlatformFee() bool {
	if m != nil {
		return m.CanPlatformFee
	}
	return false
}

func (m *WalletCoin) GetPlatformFee() float64 {
	if m != nil {
		return m.PlatformFee
	}
	return 0
}

func (m *WalletCoin) GetFeeRefCid() int64 {
	if m != nil {
		return m.FeeRefCid
	}
	return 0
}

func (m *WalletCoin) GetFeeSymbol() string {
	if m != nil {
		return m.FeeSymbol
	}
	return ""
}

func (m *WalletCoin) GetCanDeposit() bool {
	if m != nil {
		return m.CanDeposit
	}
	return false
}

func (m *WalletCoin) GetCanWithdraw() bool {
	if m != nil {
		return m.CanWithdraw
	}
	return false
}

func (m *WalletCoin) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *WalletCoin) GetCanNewAddress() bool {
	if m != nil {
		return m.CanNewAddress
	}
	return false
}

func (m *WalletCoin) GetState() StateType {
	if m != nil {
		return m.State
	}
	return StateType_State_Unknown
}

func (m *WalletCoin) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *WalletCoin) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *WalletCoin) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

//对eth的地址作资产记账
type AddressAsset struct {
	Id       int64                                                      `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	RefWid   int64                                                      `protobuf:"varint,2,opt,name=RefWid,proto3" json:"ref_wid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	RefAid   int64                                                      `protobuf:"varint,3,opt,name=RefAid,proto3" json:"ref_aid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	RefCid   int64                                                      `protobuf:"varint,4,opt,name=RefCid,proto3" json:"ref_cid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	Symbol   string                                                     `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol"`
	Address  string                                                     `protobuf:"bytes,6,opt,name=Address,proto3" json:"Address,omitempty"`
	Memo     string                                                     `protobuf:"bytes,7,opt,name=Memo,proto3" json:"Memo,omitempty"`
	Balance  float64                                                    `protobuf:"fixed64,8,opt,name=Balance,proto3" json:"balance" gorm:"type:decimal(34,10)"`
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,14,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,15,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"balance_update_at" gorm:"type:datetime"`
}

func (m *AddressAsset) Reset()         { *m = AddressAsset{} }
func (m *AddressAsset) String() string { return proto.CompactTextString(m) }
func (*AddressAsset) ProtoMessage()    {}
func (*AddressAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{24}
}
func (m *AddressAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressAsset.Merge(m, src)
}
func (m *AddressAsset) XXX_Size() int {
	return m.Size()
}
func (m *AddressAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressAsset.DiscardUnknown(m)
}

var xxx_messageInfo_AddressAsset proto.InternalMessageInfo

func (m *AddressAsset) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AddressAsset) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *AddressAsset) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *AddressAsset) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *AddressAsset) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *AddressAsset) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AddressAsset) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *AddressAsset) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *AddressAsset) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *AddressAsset) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type WalletAsset struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//钱包id
	RefWid int64 `protobuf:"varint,2,opt,name=RefWid,proto3" json:"wid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//账户id
	RefAid int64 `protobuf:"varint,3,opt,name=RefAid,proto3" json:"aid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//Coin id
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//Coin代号
	Symbol string `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol" gorm:"size:50;"`
	//资产余额
	Balance float64 `protobuf:"fixed64,6,opt,name=Balance,proto3" json:"balance" gorm:"type:decimal(34,10)"`
	//资产冻结金额
	Freeze float64 `protobuf:"fixed64,7,opt,name=Freeze,proto3" json:"freeze" gorm:"type:decimal(34,10)"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *WalletAsset) Reset()         { *m = WalletAsset{} }
func (m *WalletAsset) String() string { return proto.CompactTextString(m) }
func (*WalletAsset) ProtoMessage()    {}
func (*WalletAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{25}
}
func (m *WalletAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletAsset.Merge(m, src)
}
func (m *WalletAsset) XXX_Size() int {
	return m.Size()
}
func (m *WalletAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletAsset.DiscardUnknown(m)
}

var xxx_messageInfo_WalletAsset proto.InternalMessageInfo

func (m *WalletAsset) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WalletAsset) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *WalletAsset) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *WalletAsset) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *WalletAsset) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *WalletAsset) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *WalletAsset) GetFreeze() float64 {
	if m != nil {
		return m.Freeze
	}
	return 0
}

func (m *WalletAsset) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *WalletAsset) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

//资产快照表，定期对账后没问题就快照一份
type WalletAssetSnapshot struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//钱包id
	RefWid int64 `protobuf:"varint,2,opt,name=RefWid,proto3" json:"wid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//账户id
	RefAid int64 `protobuf:"varint,3,opt,name=RefAid,proto3" json:"aid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//Coin id
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//Coin代号
	Symbol string `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol" gorm:"size:50;"`
	//资产余额
	Balance float64 `protobuf:"fixed64,6,opt,name=Balance,proto3" json:"balance" gorm:"type:decimal(34,10)"`
	//资产冻结金额
	Freeze float64 `protobuf:"fixed64,7,opt,name=Freeze,proto3" json:"freeze" gorm:"type:decimal(34,10)"`
	//资产最后更新时间
	AssetUpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,8,opt,name=AssetUpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"asset_update_at" gorm:"type:datetime;"`
	//快照时间
	SnapshotAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,14,opt,name=SnapshotAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"snapshot_at" gorm:"type:datetime;"`
}

func (m *WalletAssetSnapshot) Reset()         { *m = WalletAssetSnapshot{} }
func (m *WalletAssetSnapshot) String() string { return proto.CompactTextString(m) }
func (*WalletAssetSnapshot) ProtoMessage()    {}
func (*WalletAssetSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{26}
}
func (m *WalletAssetSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletAssetSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletAssetSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletAssetSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletAssetSnapshot.Merge(m, src)
}
func (m *WalletAssetSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *WalletAssetSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletAssetSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_WalletAssetSnapshot proto.InternalMessageInfo

func (m *WalletAssetSnapshot) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WalletAssetSnapshot) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *WalletAssetSnapshot) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *WalletAssetSnapshot) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *WalletAssetSnapshot) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *WalletAssetSnapshot) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *WalletAssetSnapshot) GetFreeze() float64 {
	if m != nil {
		return m.Freeze
	}
	return 0
}

func (m *WalletAssetSnapshot) GetAssetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.AssetUpdateAt
	}
	return 0
}

func (m *WalletAssetSnapshot) GetSnapshotAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.SnapshotAt
	}
	return 0
}

//提现统计
type WithdrawStat struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//钱包id
	RefWid int64 `protobuf:"varint,2,opt,name=RefWid,proto3" json:"wid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//账户id
	RefAid int64 `protobuf:"varint,3,opt,name=RefAid,proto3" json:"aid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//Coin id
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid" gorm:"index:idx_wallet_asset_aid_wid_cid"`
	//最新一笔提现金额
	Amount float64 `protobuf:"fixed64,5,opt,name=Amount,proto3" json:"amount"`
	//最近一小时提现金额累计
	AmountPerHour float64 `protobuf:"fixed64,6,opt,name=AmountPerHour,proto3" json:"amount_per_hour"`
	//最近一天提现金额累计
	AmountPerDay float64 `protobuf:"fixed64,7,opt,name=AmountPerDay,proto3" json:"amount_per_day"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *WithdrawStat) Reset()         { *m = WithdrawStat{} }
func (m *WithdrawStat) String() string { return proto.CompactTextString(m) }
func (*WithdrawStat) ProtoMessage()    {}
func (*WithdrawStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{27}
}
func (m *WithdrawStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawStat.Merge(m, src)
}
func (m *WithdrawStat) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawStat) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawStat.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawStat proto.InternalMessageInfo

func (m *WithdrawStat) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WithdrawStat) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *WithdrawStat) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *WithdrawStat) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *WithdrawStat) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *WithdrawStat) GetAmountPerHour() float64 {
	if m != nil {
		return m.AmountPerHour
	}
	return 0
}

func (m *WithdrawStat) GetAmountPerDay() float64 {
	if m != nil {
		return m.AmountPerDay
	}
	return 0
}

func (m *WithdrawStat) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *WithdrawStat) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type Bill struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//钱包id
	RefWid int64 `protobuf:"varint,2,opt,name=RefWid,proto3" json:"wid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	//账户id
	RefAid int64 `protobuf:"varint,3,opt,name=RefAid,proto3" json:"aid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	//Coin id
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	//Coin代号
	Symbol string `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol" gorm:"size:50;"`
	//账单类型 1 充值 2 提现 3 提现fee 4平台fee
	BillType BillType `protobuf:"varint,7,opt,name=BillType,proto3,enum=shared.api.BillType" json:"bill_type"`
	//
	RelayId uint64 `protobuf:"varint,8,opt,name=RelayId,proto3" json:"relay_id"`
	//
	RefCtid int64 `protobuf:"varint,9,opt,name=RefCtid,proto3" json:"ctid"`
	//改变金额
	ChangeAmount float64 `protobuf:"fixed64,11,opt,name=ChangeAmount,proto3" json:"change_amount"`
	//改变后总金额
	ResultAmount float64 `protobuf:"fixed64,12,opt,name=ResultAmount,proto3" json:"result_amount"`
	//fee cid
	FeeRefCid int64 `protobuf:"varint,13,opt,name=FeeRefCid,proto3" json:"fee_cid"`
	//fee coin symbol
	FeeSymbol string `protobuf:"bytes,14,opt,name=FeeSymbol,proto3" json:"fee_symbol" gorm:"size:50;"`
	//
	InnerTxid string `protobuf:"bytes,16,opt,name=InnerTxid,proto3" json:"inner_txid" gorm:"size:100;"`
	//备注
	Comment string `protobuf:"bytes,17,opt,name=Comment,proto3" json:"comment" gorm:"size:255;"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *Bill) Reset()         { *m = Bill{} }
func (m *Bill) String() string { return proto.CompactTextString(m) }
func (*Bill) ProtoMessage()    {}
func (*Bill) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{28}
}
func (m *Bill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bill.Merge(m, src)
}
func (m *Bill) XXX_Size() int {
	return m.Size()
}
func (m *Bill) XXX_DiscardUnknown() {
	xxx_messageInfo_Bill.DiscardUnknown(m)
}

var xxx_messageInfo_Bill proto.InternalMessageInfo

func (m *Bill) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Bill) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *Bill) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *Bill) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *Bill) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Bill) GetBillType() BillType {
	if m != nil {
		return m.BillType
	}
	return BillType_BillType_Unknown
}

func (m *Bill) GetRelayId() uint64 {
	if m != nil {
		return m.RelayId
	}
	return 0
}

func (m *Bill) GetRefCtid() int64 {
	if m != nil {
		return m.RefCtid
	}
	return 0
}

func (m *Bill) GetChangeAmount() float64 {
	if m != nil {
		return m.ChangeAmount
	}
	return 0
}

func (m *Bill) GetResultAmount() float64 {
	if m != nil {
		return m.ResultAmount
	}
	return 0
}

func (m *Bill) GetFeeRefCid() int64 {
	if m != nil {
		return m.FeeRefCid
	}
	return 0
}

func (m *Bill) GetFeeSymbol() string {
	if m != nil {
		return m.FeeSymbol
	}
	return ""
}

func (m *Bill) GetInnerTxid() string {
	if m != nil {
		return m.InnerTxid
	}
	return ""
}

func (m *Bill) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Bill) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Bill) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type CoinTx struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//钱包
	RefWid int64 `protobuf:"varint,2,opt,name=RefWid,proto3" json:"wid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	//账户
	RefAid int64 `protobuf:"varint,3,opt,name=RefAid,proto3" json:"aid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	//币
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	//Coin代号
	Symbol string `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol" gorm:"size:16;"`
	//relayid=md5(txid,toAddress,Memo,OutN,InnerTxid)
	//区块高度
	BlockNum int64 `protobuf:"varint,6,opt,name=BlockNum,proto3" json:"block_num"`
	//区块时间
	BlockTime bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,7,opt,name=BlockTime,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"block_time" gorm:"type:datetime;"`
	//交易id
	Txid string `protobuf:"bytes,8,opt,name=Txid,proto3" json:"txid" gorm:"size:255;"`
	//tx转出地址
	FromAddress string `protobuf:"bytes,9,opt,name=FromAddress,proto3" json:"from_address" gorm:"size:255;"`
	//tx转入地址
	ToAddress string `protobuf:"bytes,10,opt,name=ToAddress,proto3" json:"to_address" gorm:"size:255;"`
	//memo eos用
	Memo string `protobuf:"bytes,11,opt,name=Memo,proto3" json:"memo" gorm:"size:100;"`
	//btc outn/eth nonce/eos globalnumber
	OutN int64 `protobuf:"varint,12,opt,name=OutN,proto3" json:"out_n"`
	//提现备注
	Remark string `protobuf:"bytes,13,opt,name=Remark,proto3" json:"remark" gorm:"size:100;"`
	//tx交易金额
	Amount float64 `protobuf:"fixed64,14,opt,name=Amount,proto3" json:"amount" gorm:"type:decimal(34,10)"`
	//备注
	Comment string `protobuf:"bytes,15,opt,name=Comment,proto3" json:"comment"`
	//提现申请id 由调用方生成
	RequestId string `protobuf:"bytes,16,opt,name=RequestId,proto3" json:"request_id" gorm:"size:32;index;"`
	//交易类型 1 快速提现/充值(钱包内地址互转，不上链) 2 普通提现/充值（上链）
	Type TxTypeType `protobuf:"varint,17,opt,name=Type,proto3,enum=shared.api.TxTypeType" json:"type"`
	//内部Id 由系统生成，全表唯一
	InnerTxid string `protobuf:"bytes,18,opt,name=InnerTxid,proto3" json:"inner_txid" gorm:"size:100;unique;"`
	// 1 提现 2 充值
	Side TxSideType `protobuf:"varint,19,opt,name=Side,proto3,enum=shared.api.TxSideType" json:"side"`
	//tx的当前序号，用来生成InnerTxid用
	Index int64 `protobuf:"varint,20,opt,name=Index,proto3" json:"index"`
	//提现操作用户id
	OpRefUid int64 `protobuf:"varint,27,opt,name=OpRefUid,proto3" json:"op_ref_uid"`
	//费率
	FeeRate float64 `protobuf:"fixed64,28,opt,name=FeeRate,proto3" json:"fee_rate" gorm:"type:decimal(34,10)"`
	//上链fee允许最大值
	FeeLimit float64 `protobuf:"fixed64,29,opt,name=FeeLimit,proto3" json:"fee_limit" gorm:"type:decimal(34,10)"`
	//预估的上链fee 当使用固定费率时，此字段让系统自动填充
	Fee float64 `protobuf:"fixed64,30,opt,name=Fee,proto3" json:"fee" gorm:"type:decimal(34,10)"`
	//实际花的上链fee
	FeeAct float64 `protobuf:"fixed64,31,opt,name=FeeAct,proto3" json:"fee_act" gorm:"type:decimal(34,10)"`
	//给平台fee
	PlatformFee float64 `protobuf:"fixed64,32,opt,name=PlatformFee,proto3" json:"platform_fee" gorm:"type:decimal(34,10)"`
	//fee coin id
	FeeRefCid int64 `protobuf:"varint,33,opt,name=FeeRefCid,proto3" json:"fee_cid"`
	//fee coin symbol
	FeeSymbol string `protobuf:"bytes,34,opt,name=FeeSymbol,proto3" json:"fee_symbol"`
	//审核确认数
	ApproveNum int32 `protobuf:"varint,35,opt,name=ApproveNum,proto3" json:"approve_num"`
	//需要的审核数（需要的确认数在policy设置参数里）
	NeedApproveNum int32 `protobuf:"varint,36,opt,name=NeedApproveNum,proto3" json:"need_approve_num"`
	//对于token，主链的Coin id,加此字段方便查询时把一条链的所有token一并查出
	ChainRefCid int64 `protobuf:"varint,39,opt,name=ChainRefCid,proto3" json:"chain_cid" gorm:"index:idx_coin_tx_chain_cid"`
	//是否已经生成账单
	IsGenerateBill bool `protobuf:"varint,40,opt,name=IsGenerateBill,proto3" json:"is_generate_bill"`
	//状态 1 提交/2 api回调确认/3 人工审核 /9 待发币 /10 发币中/11  等待区块数确认 /12 生成账单 /13 完成/14 失败
	State TxStateType `protobuf:"varint,41,opt,name=State,proto3,enum=shared.api.TxStateType" json:"state"`
	//确认数
	ConfirmedNum int32 `protobuf:"varint,42,opt,name=ConfirmedNum,proto3" json:"confirmed_num"`
	//需要的最小确认数
	NeedConfirmedNum int32 `protobuf:"varint,44,opt,name=NeedConfirmedNum,proto3" json:"need_confirmed_num"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,50,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,54,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *CoinTx) Reset()         { *m = CoinTx{} }
func (m *CoinTx) String() string { return proto.CompactTextString(m) }
func (*CoinTx) ProtoMessage()    {}
func (*CoinTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{29}
}
func (m *CoinTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinTx.Merge(m, src)
}
func (m *CoinTx) XXX_Size() int {
	return m.Size()
}
func (m *CoinTx) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinTx.DiscardUnknown(m)
}

var xxx_messageInfo_CoinTx proto.InternalMessageInfo

func (m *CoinTx) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CoinTx) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *CoinTx) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *CoinTx) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *CoinTx) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CoinTx) GetBlockNum() int64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *CoinTx) GetBlockTime() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *CoinTx) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *CoinTx) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *CoinTx) GetToAddress() string {
	if m != nil {
		return m.ToAddress
	}
	return ""
}

func (m *CoinTx) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *CoinTx) GetOutN() int64 {
	if m != nil {
		return m.OutN
	}
	return 0
}

func (m *CoinTx) GetRemark() string {
	if m != nil {
		return m.Remark
	}
	return ""
}

func (m *CoinTx) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *CoinTx) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *CoinTx) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *CoinTx) GetType() TxTypeType {
	if m != nil {
		return m.Type
	}
	return TxTypeType_TxType_Unknown
}

func (m *CoinTx) GetInnerTxid() string {
	if m != nil {
		return m.InnerTxid
	}
	return ""
}

func (m *CoinTx) GetSide() TxSideType {
	if m != nil {
		return m.Side
	}
	return TxSideType_TxSide_Unknown
}

func (m *CoinTx) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CoinTx) GetOpRefUid() int64 {
	if m != nil {
		return m.OpRefUid
	}
	return 0
}

func (m *CoinTx) GetFeeRate() float64 {
	if m != nil {
		return m.FeeRate
	}
	return 0
}

func (m *CoinTx) GetFeeLimit() float64 {
	if m != nil {
		return m.FeeLimit
	}
	return 0
}

func (m *CoinTx) GetFee() float64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *CoinTx) GetFeeAct() float64 {
	if m != nil {
		return m.FeeAct
	}
	return 0
}

func (m *CoinTx) GetPlatformFee() float64 {
	if m != nil {
		return m.PlatformFee
	}
	return 0
}

func (m *CoinTx) GetFeeRefCid() int64 {
	if m != nil {
		return m.FeeRefCid
	}
	return 0
}

func (m *CoinTx) GetFeeSymbol() string {
	if m != nil {
		return m.FeeSymbol
	}
	return ""
}

func (m *CoinTx) GetApproveNum() int32 {
	if m != nil {
		return m.ApproveNum
	}
	return 0
}

func (m *CoinTx) GetNeedApproveNum() int32 {
	if m != nil {
		return m.NeedApproveNum
	}
	return 0
}

func (m *CoinTx) GetChainRefCid() int64 {
	if m != nil {
		return m.ChainRefCid
	}
	return 0
}

func (m *CoinTx) GetIsGenerateBill() bool {
	if m != nil {
		return m.IsGenerateBill
	}
	return false
}

func (m *CoinTx) GetState() TxStateType {
	if m != nil {
		return m.State
	}
	return TxStateType_TxState_Unknown
}

func (m *CoinTx) GetConfirmedNum() int32 {
	if m != nil {
		return m.ConfirmedNum
	}
	return 0
}

func (m *CoinTx) GetNeedConfirmedNum() int32 {
	if m != nil {
		return m.NeedConfirmedNum
	}
	return 0
}

func (m *CoinTx) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *CoinTx) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

//tx对应的动作，1 审核限额、审核白名单、审核对账 2 人工审核 3 发币 3 确认数 4 生成账单
type TxAction struct {
	Id           int64                                                      `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	RefWid       int64                                                      `protobuf:"varint,2,opt,name=RefWid,proto3" json:"ref_wid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	RefAid       int64                                                      `protobuf:"varint,3,opt,name=RefAid,proto3" json:"ref_aid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	RefCid       int64                                                      `protobuf:"varint,4,opt,name=RefCid,proto3" json:"ref_cid" gorm:"index:idx_coin_deposit_tx_aid_wid_cid"`
	RefUid       int64                                                      `protobuf:"varint,6,opt,name=RefUid,proto3" json:"RefUid,omitempty"`
	Symbol       string                                                     `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol"`
	RefInnerTxid string                                                     `protobuf:"bytes,40,opt,name=RefInnerTxid,proto3" json:"RefInnerTxid,omitempty"`
	RefTxState   TxStateType                                                `protobuf:"varint,9,opt,name=RefTxState,proto3,enum=shared.api.TxStateType" json:"RefTxState,omitempty"`
	ActName      string                                                     `protobuf:"bytes,10,opt,name=ActName,proto3" json:"ActName,omitempty"`
	Result       int32                                                      `protobuf:"varint,11,opt,name=Result,proto3" json:"Result,omitempty"`
	NeedNextAct  bool                                                       `protobuf:"varint,13,opt,name=NeedNextAct,proto3" json:"NeedNextAct,omitempty"`
	Comment      string                                                     `protobuf:"bytes,12,opt,name=Comment,proto3" json:"Comment,omitempty"`
	CreateAt     bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,50,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
}

func (m *TxAction) Reset()         { *m = TxAction{} }
func (m *TxAction) String() string { return proto.CompactTextString(m) }
func (*TxAction) ProtoMessage()    {}
func (*TxAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{30}
}
func (m *TxAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxAction.Merge(m, src)
}
func (m *TxAction) XXX_Size() int {
	return m.Size()
}
func (m *TxAction) XXX_DiscardUnknown() {
	xxx_messageInfo_TxAction.DiscardUnknown(m)
}

var xxx_messageInfo_TxAction proto.InternalMessageInfo

func (m *TxAction) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TxAction) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *TxAction) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *TxAction) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *TxAction) GetRefUid() int64 {
	if m != nil {
		return m.RefUid
	}
	return 0
}

func (m *TxAction) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *TxAction) GetRefInnerTxid() string {
	if m != nil {
		return m.RefInnerTxid
	}
	return ""
}

func (m *TxAction) GetRefTxState() TxStateType {
	if m != nil {
		return m.RefTxState
	}
	return TxStateType_TxState_Unknown
}

func (m *TxAction) GetActName() string {
	if m != nil {
		return m.ActName
	}
	return ""
}

func (m *TxAction) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *TxAction) GetNeedNextAct() bool {
	if m != nil {
		return m.NeedNextAct
	}
	return false
}

func (m *TxAction) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *TxAction) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

//提现策略设置
type WithdrawSetting struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	RefAid int64 `protobuf:"varint,2,opt,name=RefAid,proto3" json:"aid"`
	//钱包id
	RefWid int64 `protobuf:"varint,3,opt,name=RefWid,proto3" json:"wid" gorm:"unique;"`
	//审核所有交易,对所有发送交易都需要一个审核才能放行(无视发送限制策略)
	ApproveAll bool `protobuf:"varint,4,opt,name=ApproveAll,proto3" json:"approved_all"`
	//提现确认回调
	WithdrawCallbackUrl string `protobuf:"bytes,5,opt,name=WithdrawCallbackUrl,proto3" json:"withdraw_callback_url"`
	//交易回调
	TransferCallbackUrl string `protobuf:"bytes,6,opt,name=TransferCallbackUrl,proto3" json:"transfer_callback_url"`
	//包含确认数
	IsContainConfirmNum bool `protobuf:"varint,7,opt,name=IsContainConfirmNum,proto3" json:"is_contain_confirm_num"`
	//提现确认回调最多重试次数
	WithdrawCallbackRetryNum int32 `protobuf:"varint,8,opt,name=WithdrawCallbackRetryNum,proto3" json:"withdraw_callback_retry_num"`
	//交易回调(充值、提现确认数已经大于最小确认数)最多重试次数
	TransferCallbackRetryNum int32 `protobuf:"varint,9,opt,name=TransferCallbackRetryNum,proto3" json:"transfer_callback_retry_num"`
	//交易回调(确认区间)最多重试次数
	ConfirmingCallbackRetryNum int32 `protobuf:"varint,10,opt,name=ConfirmingCallbackRetryNum,proto3" json:"confirming_callback_retry_num"`
	//重试间隔 单位秒
	RetryInv int64 `protobuf:"varint,11,opt,name=RetryInv,proto3" json:"retry_inv"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *WithdrawSetting) Reset()         { *m = WithdrawSetting{} }
func (m *WithdrawSetting) String() string { return proto.CompactTextString(m) }
func (*WithdrawSetting) ProtoMessage()    {}
func (*WithdrawSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{31}
}
func (m *WithdrawSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawSetting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawSetting.Merge(m, src)
}
func (m *WithdrawSetting) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawSetting.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawSetting proto.InternalMessageInfo

func (m *WithdrawSetting) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WithdrawSetting) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *WithdrawSetting) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *WithdrawSetting) GetApproveAll() bool {
	if m != nil {
		return m.ApproveAll
	}
	return false
}

func (m *WithdrawSetting) GetWithdrawCallbackUrl() string {
	if m != nil {
		return m.WithdrawCallbackUrl
	}
	return ""
}

func (m *WithdrawSetting) GetTransferCallbackUrl() string {
	if m != nil {
		return m.TransferCallbackUrl
	}
	return ""
}

func (m *WithdrawSetting) GetIsContainConfirmNum() bool {
	if m != nil {
		return m.IsContainConfirmNum
	}
	return false
}

func (m *WithdrawSetting) GetWithdrawCallbackRetryNum() int32 {
	if m != nil {
		return m.WithdrawCallbackRetryNum
	}
	return 0
}

func (m *WithdrawSetting) GetTransferCallbackRetryNum() int32 {
	if m != nil {
		return m.TransferCallbackRetryNum
	}
	return 0
}

func (m *WithdrawSetting) GetConfirmingCallbackRetryNum() int32 {
	if m != nil {
		return m.ConfirmingCallbackRetryNum
	}
	return 0
}

func (m *WithdrawSetting) GetRetryInv() int64 {
	if m != nil {
		return m.RetryInv
	}
	return 0
}

func (m *WithdrawSetting) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *WithdrawSetting) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

//提现限额设置
type CoinWithdrawQuota struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	RefAid int64 `protobuf:"varint,2,opt,name=RefAid,proto3" json:"aid"`
	//钱包id
	RefWid int64 `protobuf:"varint,3,opt,name=RefWid,proto3" json:"wid"`
	//Coin id
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid"`
	//Coin 代号
	Symbol string `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol" gorm:"size:50;"`
	//每笔限额
	QuotaPerTx float64 `protobuf:"fixed64,6,opt,name=QuotaPerTx,proto3" json:"quota_per_tx"`
	//每小时限额
	QuotaPerHour float64 `protobuf:"fixed64,7,opt,name=QuotaPerHour,proto3" json:"quota_per_hour"`
	//每天限额
	QuotaPerDay float64 `protobuf:"fixed64,8,opt,name=QuotaPerDay,proto3" json:"quota_per_day"`
	//需要审核的人数
	ApprovedPerson int32 `protobuf:"varint,9,opt,name=ApprovedPerson,proto3" json:"approved_person"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *CoinWithdrawQuota) Reset()         { *m = CoinWithdrawQuota{} }
func (m *CoinWithdrawQuota) String() string { return proto.CompactTextString(m) }
func (*CoinWithdrawQuota) ProtoMessage()    {}
func (*CoinWithdrawQuota) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{32}
}
func (m *CoinWithdrawQuota) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinWithdrawQuota) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinWithdrawQuota.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinWithdrawQuota) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinWithdrawQuota.Merge(m, src)
}
func (m *CoinWithdrawQuota) XXX_Size() int {
	return m.Size()
}
func (m *CoinWithdrawQuota) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinWithdrawQuota.DiscardUnknown(m)
}

var xxx_messageInfo_CoinWithdrawQuota proto.InternalMessageInfo

func (m *CoinWithdrawQuota) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CoinWithdrawQuota) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *CoinWithdrawQuota) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *CoinWithdrawQuota) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *CoinWithdrawQuota) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CoinWithdrawQuota) GetQuotaPerTx() float64 {
	if m != nil {
		return m.QuotaPerTx
	}
	return 0
}

func (m *CoinWithdrawQuota) GetQuotaPerHour() float64 {
	if m != nil {
		return m.QuotaPerHour
	}
	return 0
}

func (m *CoinWithdrawQuota) GetQuotaPerDay() float64 {
	if m != nil {
		return m.QuotaPerDay
	}
	return 0
}

func (m *CoinWithdrawQuota) GetApprovedPerson() int32 {
	if m != nil {
		return m.ApprovedPerson
	}
	return 0
}

func (m *CoinWithdrawQuota) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *CoinWithdrawQuota) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

//提现白名单设置
type CoinWithdrawWhitelist struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	RefAid int64 `protobuf:"varint,2,opt,name=RefAid,proto3" json:"aid"`
	//钱包id
	RefWid int64 `protobuf:"varint,3,opt,name=RefWid,proto3" json:"wid"`
	//Coin id
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid"`
	//Coin 代号
	Symbol string `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol" gorm:"size:50;"`
	//地址
	Address string `protobuf:"bytes,6,opt,name=Address,proto3" json:"address" gorm:"size:100;"`
	//memo
	Memo string `protobuf:"bytes,7,opt,name=Memo,proto3" json:"memo" gorm:"size:100;"`
	//此设置的状态 1 未激活 2 已激活
	State StateType `protobuf:"varint,8,opt,name=State,proto3,enum=shared.api.StateType" json:"state"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,20,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,21,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *CoinWithdrawWhitelist) Reset()         { *m = CoinWithdrawWhitelist{} }
func (m *CoinWithdrawWhitelist) String() string { return proto.CompactTextString(m) }
func (*CoinWithdrawWhitelist) ProtoMessage()    {}
func (*CoinWithdrawWhitelist) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{33}
}
func (m *CoinWithdrawWhitelist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinWithdrawWhitelist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinWithdrawWhitelist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinWithdrawWhitelist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinWithdrawWhitelist.Merge(m, src)
}
func (m *CoinWithdrawWhitelist) XXX_Size() int {
	return m.Size()
}
func (m *CoinWithdrawWhitelist) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinWithdrawWhitelist.DiscardUnknown(m)
}

var xxx_messageInfo_CoinWithdrawWhitelist proto.InternalMessageInfo

func (m *CoinWithdrawWhitelist) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CoinWithdrawWhitelist) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *CoinWithdrawWhitelist) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *CoinWithdrawWhitelist) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *CoinWithdrawWhitelist) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CoinWithdrawWhitelist) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CoinWithdrawWhitelist) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *CoinWithdrawWhitelist) GetState() StateType {
	if m != nil {
		return m.State
	}
	return StateType_State_Unknown
}

func (m *CoinWithdrawWhitelist) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *CoinWithdrawWhitelist) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

//提现策略设置
type WithdrawPolicy struct {
	//提现参数
	Setting *WithdrawSetting `protobuf:"bytes,1,opt,name=Setting,proto3" json:"setting"`
	//限额，一旦设置了限额，只有在限额内的才能提现，以审核人数
	Quota []*CoinWithdrawQuota `protobuf:"bytes,2,rep,name=Quota,proto3" json:"quota"`
	//白名单，一旦设置了白名单，只有在白名单的地址才能提现
	Whitelist []*CoinWithdrawWhitelist `protobuf:"bytes,3,rep,name=Whitelist,proto3" json:"whitelist"`
}

func (m *WithdrawPolicy) Reset()         { *m = WithdrawPolicy{} }
func (m *WithdrawPolicy) String() string { return proto.CompactTextString(m) }
func (*WithdrawPolicy) ProtoMessage()    {}
func (*WithdrawPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{34}
}
func (m *WithdrawPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawPolicy.Merge(m, src)
}
func (m *WithdrawPolicy) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawPolicy proto.InternalMessageInfo

func (m *WithdrawPolicy) GetSetting() *WithdrawSetting {
	if m != nil {
		return m.Setting
	}
	return nil
}

func (m *WithdrawPolicy) GetQuota() []*CoinWithdrawQuota {
	if m != nil {
		return m.Quota
	}
	return nil
}

func (m *WithdrawPolicy) GetWhitelist() []*CoinWithdrawWhitelist {
	if m != nil {
		return m.Whitelist
	}
	return nil
}

type WalletCoinDetail struct {
	//币详情
	Detail *CoinInfo `protobuf:"bytes,1,opt,name=Detail,proto3" json:"detail"`
	//币参数
	Coin *WalletCoin `protobuf:"bytes,2,opt,name=Coin,proto3" json:"coin"`
	//币资产
	Asset *WalletAsset `protobuf:"bytes,3,opt,name=Asset,proto3" json:"asset"`
}

func (m *WalletCoinDetail) Reset()         { *m = WalletCoinDetail{} }
func (m *WalletCoinDetail) String() string { return proto.CompactTextString(m) }
func (*WalletCoinDetail) ProtoMessage()    {}
func (*WalletCoinDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{35}
}
func (m *WalletCoinDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletCoinDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletCoinDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletCoinDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletCoinDetail.Merge(m, src)
}
func (m *WalletCoinDetail) XXX_Size() int {
	return m.Size()
}
func (m *WalletCoinDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletCoinDetail.DiscardUnknown(m)
}

var xxx_messageInfo_WalletCoinDetail proto.InternalMessageInfo

func (m *WalletCoinDetail) GetDetail() *CoinInfo {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *WalletCoinDetail) GetCoin() *WalletCoin {
	if m != nil {
		return m.Coin
	}
	return nil
}

func (m *WalletCoinDetail) GetAsset() *WalletAsset {
	if m != nil {
		return m.Asset
	}
	return nil
}

type WalletDetail struct {
	//钱包详情
	Detail *WalletInfo `protobuf:"bytes,1,opt,name=Detail,proto3" json:"detail"`
	//钱包添加的币
	Coins []*WalletCoinDetail `protobuf:"bytes,2,rep,name=Coins,proto3" json:"wallet_coin_detail"`
}

func (m *WalletDetail) Reset()         { *m = WalletDetail{} }
func (m *WalletDetail) String() string { return proto.CompactTextString(m) }
func (*WalletDetail) ProtoMessage()    {}
func (*WalletDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{36}
}
func (m *WalletDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletDetail.Merge(m, src)
}
func (m *WalletDetail) XXX_Size() int {
	return m.Size()
}
func (m *WalletDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletDetail.DiscardUnknown(m)
}

var xxx_messageInfo_WalletDetail proto.InternalMessageInfo

func (m *WalletDetail) GetDetail() *WalletInfo {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *WalletDetail) GetCoins() []*WalletCoinDetail {
	if m != nil {
		return m.Coins
	}
	return nil
}

//推送消息
type Message struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//账户id
	RefAid int64 `protobuf:"varint,2,opt,name=RefAid,proto3" json:"aid"`
	//钱包id
	RefWid int64 `protobuf:"varint,3,opt,name=RefWid,proto3" json:"wid"`
	//Coin id
	RefCid int64 `protobuf:"varint,4,opt,name=RefCid,proto3" json:"cid"`
	//Coin 代号
	Symbol string `protobuf:"bytes,5,opt,name=Symbol,proto3" json:"symbol" gorm:"size:50;"`
	//CoinTx id
	RefCtid int64 `protobuf:"varint,7,opt,name=RefCtid,proto3" json:"ctid"`
	//消息类型
	Type MsgType `protobuf:"varint,10,opt,name=Type,proto3,enum=shared.api.MsgType" json:"type"`
	//回调url
	Url string `protobuf:"bytes,11,opt,name=Url,proto3" json:"url" gorm:"size:255;"`
	//内容json
	Content string `protobuf:"bytes,12,opt,name=Content,proto3" json:"content" gorm:"size:2048;"`
	//推送次数
	ReqNum int32 `protobuf:"varint,13,opt,name=ReqNum,proto3" json:"req_num"`
	//允许最多推送次数
	MaxReqNum int32 `protobuf:"varint,14,opt,name=MaxReqNum,proto3" json:"max_req_num"`
	//推送失败重试间隔 单位秒
	RetryInv int64 `protobuf:"varint,15,opt,name=RetryInv,proto3" json:"retry_inv"`
	// 0 未推送 1 推送中 2 成功 3 失败
	PushStatus PushStatusType `protobuf:"varint,21,opt,name=PushStatus,proto3,enum=shared.api.PushStatusType" json:"push_status"`
	//备注
	Commnet string `protobuf:"bytes,22,opt,name=Commnet,proto3" json:"commnet" gorm:"size:512;"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,50,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,51,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{37}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Message) GetRefAid() int64 {
	if m != nil {
		return m.RefAid
	}
	return 0
}

func (m *Message) GetRefWid() int64 {
	if m != nil {
		return m.RefWid
	}
	return 0
}

func (m *Message) GetRefCid() int64 {
	if m != nil {
		return m.RefCid
	}
	return 0
}

func (m *Message) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Message) GetRefCtid() int64 {
	if m != nil {
		return m.RefCtid
	}
	return 0
}

func (m *Message) GetType() MsgType {
	if m != nil {
		return m.Type
	}
	return MsgType_MsgType_Unknown
}

func (m *Message) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Message) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Message) GetReqNum() int32 {
	if m != nil {
		return m.ReqNum
	}
	return 0
}

func (m *Message) GetMaxReqNum() int32 {
	if m != nil {
		return m.MaxReqNum
	}
	return 0
}

func (m *Message) GetRetryInv() int64 {
	if m != nil {
		return m.RetryInv
	}
	return 0
}

func (m *Message) GetPushStatus() PushStatusType {
	if m != nil {
		return m.PushStatus
	}
	return PushStatusType_PushStatusType_UnPush
}

func (m *Message) GetCommnet() string {
	if m != nil {
		return m.Commnet
	}
	return ""
}

func (m *Message) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Message) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

type Notify struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id"`
	//消息内容，包括通道、参数
	Txt string `protobuf:"bytes,2,opt,name=Txt,proto3" json:"txt" gorm:"size:512;"`
	//状态 0 未发送 1 已发送 2 发送失败
	State   NotifyState `protobuf:"varint,3,opt,name=State,proto3,enum=shared.api.NotifyState" json:"state"`
	Comment string      `protobuf:"bytes,4,opt,name=Comment,proto3" json:"comment" gorm:"size:512;"`
	//创建时间
	CreateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,50,opt,name=CreateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"create_at" gorm:"type:datetime;"`
	//最后更新时间
	UpdateAt bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time `protobuf:"varint,51,opt,name=UpdateAt,proto3,casttype=bitbucket.org/biiigle/biiigle_wa001_dams/src/lib/time.Time" json:"update_at" gorm:"type:datetime;"`
}

func (m *Notify) Reset()         { *m = Notify{} }
func (m *Notify) String() string { return proto.CompactTextString(m) }
func (*Notify) ProtoMessage()    {}
func (*Notify) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a4e87e678c5ced, []int{38}
}
func (m *Notify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notify.Merge(m, src)
}
func (m *Notify) XXX_Size() int {
	return m.Size()
}
func (m *Notify) XXX_DiscardUnknown() {
	xxx_messageInfo_Notify.DiscardUnknown(m)
}

var xxx_messageInfo_Notify proto.InternalMessageInfo

func (m *Notify) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Notify) GetTxt() string {
	if m != nil {
		return m.Txt
	}
	return ""
}

func (m *Notify) GetState() NotifyState {
	if m != nil {
		return m.State
	}
	return NotifyState_UnSend
}

func (m *Notify) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Notify) GetCreateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Notify) GetUpdateAt() bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

func init() {
	proto.RegisterEnum("shared.api.StateType", StateType_name, StateType_value)
	proto.RegisterEnum("shared.api.ACodeOpType", ACodeOpType_name, ACodeOpType_value)
	proto.RegisterEnum("shared.api.ACodeStateType", ACodeStateType_name, ACodeStateType_value)
	proto.RegisterEnum("shared.api.WalletType", WalletType_name, WalletType_value)
	proto.RegisterEnum("shared.api.AddressType", AddressType_name, AddressType_value)
	proto.RegisterEnum("shared.api.BillType", BillType_name, BillType_value)
	proto.RegisterEnum("shared.api.TxStateType", TxStateType_name, TxStateType_value)
	proto.RegisterEnum("shared.api.TxSideType", TxSideType_name, TxSideType_value)
	proto.RegisterEnum("shared.api.TxTypeType", TxTypeType_name, TxTypeType_value)
	proto.RegisterEnum("shared.api.MsgType", MsgType_name, MsgType_value)
	proto.RegisterEnum("shared.api.PushStatusType", PushStatusType_name, PushStatusType_value)
	proto.RegisterEnum("shared.api.NotifyState", NotifyState_name, NotifyState_value)
	proto.RegisterType((*ErrInfo)(nil), "shared.api.ErrInfo")
	proto.RegisterType((*UserLoginLog)(nil), "shared.api.UserLoginLog")
	proto.RegisterType((*AccountInfo)(nil), "shared.api.AccountInfo")
	proto.RegisterType((*UserActivationCode)(nil), "shared.api.UserActivationCode")
	proto.RegisterType((*UserInfo)(nil), "shared.api.UserInfo")
	proto.RegisterType((*ApiKey)(nil), "shared.api.ApiKey")
	proto.RegisterType((*CountryCode)(nil), "shared.api.CountryCode")
	proto.RegisterType((*RoleItem)(nil), "shared.api.RoleItem")
	proto.RegisterType((*AuthItem)(nil), "shared.api.AuthItem")
	proto.RegisterType((*RoleAuth)(nil), "shared.api.RoleAuth")
	proto.RegisterType((*AuthAssign)(nil), "shared.api.AuthAssign")
	proto.RegisterType((*UserData)(nil), "shared.api.UserData")
	proto.RegisterType((*RespPerm)(nil), "shared.api.RespPerm")
	proto.RegisterType((*SessionAuthItem)(nil), "shared.api.SessionAuthItem")
	proto.RegisterType((*SessionRoleItem)(nil), "shared.api.SessionRoleItem")
	proto.RegisterType((*SessionUser)(nil), "shared.api.SessionUser")
	proto.RegisterType((*SessionData)(nil), "shared.api.SessionData")
	proto.RegisterType((*CacheApiKey)(nil), "shared.api.CacheApiKey")
	proto.RegisterType((*BlockInfo)(nil), "shared.api.BlockInfo")
	proto.RegisterType((*WalletInfo)(nil), "shared.api.WalletInfo")
	proto.RegisterType((*AddressInfo)(nil), "shared.api.AddressInfo")
	proto.RegisterType((*CoinInfo)(nil), "shared.api.CoinInfo")
	proto.RegisterType((*WalletHdIndex)(nil), "shared.api.WalletHdIndex")
	proto.RegisterType((*WalletCoin)(nil), "shared.api.WalletCoin")
	proto.RegisterType((*AddressAsset)(nil), "shared.api.AddressAsset")
	proto.RegisterType((*WalletAsset)(nil), "shared.api.WalletAsset")
	proto.RegisterType((*WalletAssetSnapshot)(nil), "shared.api.WalletAssetSnapshot")
	proto.RegisterType((*WithdrawStat)(nil), "shared.api.WithdrawStat")
	proto.RegisterType((*Bill)(nil), "shared.api.Bill")
	proto.RegisterType((*CoinTx)(nil), "shared.api.CoinTx")
	proto.RegisterType((*TxAction)(nil), "shared.api.TxAction")
	proto.RegisterType((*WithdrawSetting)(nil), "shared.api.WithdrawSetting")
	proto.RegisterType((*CoinWithdrawQuota)(nil), "shared.api.CoinWithdrawQuota")
	proto.RegisterType((*CoinWithdrawWhitelist)(nil), "shared.api.CoinWithdrawWhitelist")
	proto.RegisterType((*WithdrawPolicy)(nil), "shared.api.WithdrawPolicy")
	proto.RegisterType((*WalletCoinDetail)(nil), "shared.api.WalletCoinDetail")
	proto.RegisterType((*WalletDetail)(nil), "shared.api.WalletDetail")
	proto.RegisterType((*Message)(nil), "shared.api.Message")
	proto.RegisterType((*Notify)(nil), "shared.api.Notify")
}

func init() { proto.RegisterFile("shared.proto", fileDescriptor_d8a4e87e678c5ced) }

var fileDescriptor_d8a4e87e678c5ced = []byte{
	// 6204 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x4b, 0x6c, 0x1c, 0x49,
	0x72, 0xf6, 0x34, 0xfb, 0x9d, 0xcd, 0x47, 0x2b, 0xf5, 0x6a, 0x3d, 0x5b, 0x6a, 0xed, 0xcc, 0x4a,
	0x5c, 0x3d, 0xa8, 0xb7, 0x46, 0x9c, 0x9d, 0x99, 0xe6, 0x4b, 0xd3, 0x3b, 0x12, 0xc9, 0xbf, 0x28,
	0xfe, 0x5a, 0xd8, 0x87, 0x42, 0xb1, 0x2b, 0x49, 0x96, 0x55, 0x5d, 0xd5, 0x53, 0x55, 0x2d, 0x92,
	0x0b, 0x2f, 0x60, 0xc0, 0xf0, 0x2e, 0xe0, 0x83, 0xb1, 0x27, 0xc3, 0x3e, 0xf8, 0x6c, 0xc0, 0x86,
	0x0f, 0xf6, 0xc5, 0x30, 0xe0, 0x83, 0x17, 0x86, 0x61, 0xc3, 0xa7, 0x05, 0x7c, 0xd9, 0x83, 0xd1,
	0x30, 0x76, 0x6d, 0x2c, 0x40, 0xc0, 0x07, 0x13, 0x3e, 0xed, 0xc5, 0x46, 0x44, 0x66, 0x56, 0x65,
	0x55, 0x3f, 0x28, 0x72, 0x56, 0xa0, 0x16, 0xe6, 0x49, 0xec, 0xc8, 0x88, 0xc8, 0xac, 0xcc, 0x88,
	0x2f, 0x23, 0x22, 0xb3, 0x4a, 0x64, 0xd4, 0xdf, 0x34, 0x3c, 0x66, 0xde, 0x6e, 0x7b, 0x6e, 0xe0,
	0x52, 0x22, 0x7e, 0x19, 0x6d, 0xeb, 0xfc, 0xad, 0x0d, 0x2b, 0xd8, 0xec, 0xac, 0xdd, 0x6e, 0xba,
	0xad, 0x3b, 0x1b, 0xee, 0x86, 0x7b, 0x07, 0x59, 0xd6, 0x3a, 0xeb, 0xf8, 0x0b, 0x7f, 0xe0, 0x5f,
	0x5c, 0xb4, 0xd6, 0x24, 0xf9, 0x79, 0xcf, 0x6b, 0x38, 0xeb, 0x2e, 0x3d, 0x43, 0x46, 0x1a, 0x66,
	0x25, 0x75, 0x25, 0x75, 0x3d, 0x3d, 0x93, 0xdb, 0xed, 0x56, 0x47, 0x2c, 0x53, 0x1b, 0x69, 0x98,
	0xf4, 0x22, 0xc9, 0xcc, 0xba, 0x26, 0xab, 0x8c, 0x5c, 0x49, 0x5d, 0xcf, 0xce, 0x14, 0x76, 0xbb,
	0xd5, 0x4c, 0xd3, 0x35, 0x99, 0x86, 0x54, 0x5a, 0x23, 0xb9, 0x39, 0x16, 0x18, 0x96, 0x5d, 0x49,
	0x5f, 0x49, 0x5d, 0x2f, 0xce, 0x90, 0xdd, 0x6e, 0x35, 0x67, 0x22, 0x45, 0x13, 0x2d, 0xb5, 0x5f,
	0x8e, 0x90, 0xd1, 0x55, 0x9f, 0x79, 0xcf, 0xdd, 0x0d, 0xcb, 0x79, 0xee, 0x6e, 0x0c, 0xec, 0x6a,
	0x92, 0xa4, 0x57, 0x2d, 0x13, 0x7b, 0x4a, 0xcf, 0x54, 0x76, 0xbb, 0xd5, 0x74, 0xc7, 0x32, 0xf7,
	0xba, 0xd5, 0xb1, 0x0d, 0xd7, 0x6b, 0x3d, 0xad, 0x59, 0x8e, 0xc9, 0xb6, 0xa7, 0x6b, 0x1a, 0x30,
	0xd1, 0xeb, 0x64, 0xa4, 0xb1, 0x2c, 0x3a, 0xad, 0xa0, 0x8e, 0xf6, 0x5e, 0xb7, 0x3a, 0xce, 0x39,
	0x7d, 0xeb, 0x7b, 0xec, 0xe9, 0xbd, 0xa9, 0x9a, 0x36, 0xd2, 0x58, 0xa6, 0x9f, 0x91, 0x22, 0xf4,
	0x5e, 0xdf, 0x60, 0x4e, 0x50, 0xc9, 0xa0, 0xc0, 0xd5, 0xdd, 0x6e, 0x95, 0x74, 0x7c, 0xe6, 0xe9,
	0x06, 0x50, 0xf7, 0xba, 0xd5, 0x09, 0x55, 0xf0, 0xe1, 0xa3, 0x9a, 0x16, 0xc9, 0xd0, 0x27, 0x24,
	0x3f, 0xeb, 0xb6, 0x5a, 0x20, 0x9e, 0x45, 0xf1, 0xcb, 0xbb, 0xdd, 0x6a, 0xbe, 0xc9, 0x49, 0x09,
	0xd9, 0xbb, 0x53, 0x53, 0x35, 0x4d, 0xb2, 0xd3, 0xdf, 0x49, 0x91, 0xc2, 0xac, 0xc7, 0x8c, 0x80,
	0xd5, 0x83, 0xca, 0x29, 0x7c, 0x2c, 0x73, 0xb7, 0x5b, 0x2d, 0x36, 0x91, 0xa6, 0x1b, 0x20, 0x7d,
	0x9a, 0x4b, 0x07, 0x3b, 0x6d, 0xf6, 0xd4, 0x34, 0x02, 0x16, 0x58, 0x2d, 0x36, 0x5d, 0xfb, 0x65,
	0xb7, 0xfa, 0x74, 0xcd, 0x0a, 0xd6, 0x3a, 0xcd, 0xd7, 0x2c, 0xb8, 0xed, 0x7a, 0x1b, 0x77, 0xd6,
	0x2c, 0xcb, 0xda, 0xb0, 0x99, 0xfc, 0x57, 0xdf, 0x32, 0xa6, 0xa6, 0xee, 0xea, 0xa6, 0xd1, 0xf2,
	0xef, 0xf8, 0x5e, 0xf3, 0x8e, 0x6d, 0xad, 0xdd, 0x01, 0xd1, 0xdb, 0x2f, 0xad, 0x16, 0xd3, 0xc2,
	0x5e, 0x6b, 0xff, 0x9a, 0x26, 0xa5, 0x7a, 0xb3, 0xe9, 0x76, 0x9c, 0x60, 0xe8, 0x32, 0x4f, 0x91,
	0xcc, 0xa2, 0xd1, 0xe2, 0xcb, 0x5c, 0x9c, 0xb9, 0x08, 0xcb, 0xec, 0x18, 0x2d, 0xb6, 0xd7, 0xad,
	0x96, 0x63, 0x53, 0xf3, 0x70, 0xba, 0xa6, 0x21, 0x27, 0x9d, 0x27, 0xa5, 0x39, 0xe6, 0x37, 0x3d,
	0xab, 0x1d, 0x58, 0xae, 0x23, 0x96, 0xe2, 0xda, 0x6e, 0xb7, 0x5a, 0x32, 0x23, 0x72, 0x5f, 0x79,
	0x55, 0x8e, 0x3e, 0x22, 0xd9, 0x95, 0xc0, 0x08, 0x18, 0x2e, 0xcd, 0xf8, 0xbd, 0xd3, 0xb7, 0x23,
	0x6b, 0xbe, 0x8d, 0x0d, 0x2f, 0x77, 0xda, 0x6c, 0xa6, 0xb8, 0xdb, 0xad, 0x66, 0x7d, 0xf8, 0xa9,
	0x71, 0xf6, 0xf7, 0x60, 0x6e, 0x71, 0x08, 0xab, 0x6d, 0x93, 0x0f, 0xe1, 0x74, 0x34, 0x84, 0x0e,
	0xd2, 0xde, 0xe5, 0x10, 0x64, 0xaf, 0xb5, 0xdf, 0xcb, 0x11, 0x8a, 0x96, 0xda, 0x0c, 0xac, 0x37,
	0x06, 0x4c, 0x28, 0xba, 0xe5, 0xa0, 0x55, 0x9e, 0x21, 0x39, 0x8d, 0xad, 0xd7, 0x43, 0x27, 0x9b,
	0xdc, 0xed, 0x56, 0x53, 0xb7, 0xf6, 0xba, 0xd5, 0xab, 0x8a, 0x8b, 0x3d, 0xb5, 0xcc, 0x6d, 0x9d,
	0x7b, 0x47, 0x13, 0x5c, 0x5d, 0x37, 0x2c, 0x73, 0xba, 0xa6, 0x09, 0x49, 0x3a, 0x87, 0x3a, 0xc0,
	0x51, 0xd3, 0xa8, 0xe3, 0x66, 0xe4, 0xa8, 0x43, 0xb5, 0x74, 0x42, 0x2d, 0xe0, 0xbf, 0x8b, 0x24,
	0xb7, 0xd4, 0x46, 0x8b, 0xe3, 0xeb, 0x7e, 0x56, 0x5d, 0xf7, 0x3a, 0x3c, 0xc4, 0x52, 0x1b, 0x57,
	0xfe, 0x12, 0x38, 0x9b, 0xdb, 0xd6, 0x85, 0x35, 0x0a, 0x0f, 0xef, 0x38, 0xd6, 0x57, 0x1d, 0x06,
	0xfa, 0xb8, 0x16, 0x7a, 0x5b, 0xc0, 0x14, 0xf7, 0xd0, 0xf3, 0x12, 0xa6, 0xfa, 0x48, 0x70, 0xe0,
	0x7a, 0x2e, 0xcd, 0x2e, 0x87, 0xdd, 0x9f, 0xef, 0xe9, 0x3e, 0xb2, 0xbd, 0xf3, 0xa1, 0xed, 0xf5,
	0x62, 0x91, 0x30, 0xc6, 0xef, 0xc1, 0xd3, 0xc0, 0xd2, 0x54, 0xf2, 0x38, 0x27, 0x6b, 0x62, 0xd0,
	0xb0, 0x64, 0xef, 0xca, 0x08, 0x44, 0x8f, 0xf4, 0x77, 0x53, 0xa4, 0x38, 0xc3, 0x36, 0x2c, 0x07,
	0xfb, 0x2f, 0x60, 0xff, 0x0c, 0x00, 0x6e, 0x0d, 0x88, 0xef, 0x74, 0x08, 0x51, 0xbf, 0xf4, 0xfb,
	0x24, 0x3f, 0xef, 0x98, 0x38, 0x84, 0x22, 0x0e, 0xa1, 0xb9, 0xdb, 0xad, 0x16, 0x98, 0x63, 0xbe,
	0xd3, 0x01, 0xc8, 0x3e, 0x6b, 0x3f, 0x2e, 0x92, 0x02, 0xf8, 0xc1, 0x50, 0x8c, 0xfb, 0x36, 0x29,
	0x4a, 0x28, 0x94, 0x0e, 0x50, 0x85, 0x89, 0x32, 0x38, 0x51, 0xef, 0xb7, 0xd9, 0x44, 0x12, 0x74,
	0x86, 0x77, 0x81, 0x46, 0xcb, 0xd1, 0xee, 0x23, 0xf4, 0x76, 0xb0, 0x71, 0x61, 0x9d, 0xa7, 0x55,
	0x61, 0xbe, 0x21, 0xdc, 0x7b, 0x52, 0xd3, 0x42, 0x39, 0xba, 0x40, 0xb2, 0xf3, 0x2d, 0xd8, 0x2e,
	0xf9, 0x46, 0x34, 0x05, 0xa6, 0xc5, 0x80, 0xb0, 0xd7, 0xad, 0x5e, 0xe3, 0xc2, 0x4d, 0xd7, 0xee,
	0xb4, 0x9c, 0xa7, 0x48, 0x9d, 0x16, 0x56, 0x1b, 0xed, 0x2d, 0x5c, 0x1c, 0xc0, 0x77, 0x16, 0x86,
	0xe5, 0xed, 0x28, 0x56, 0x0f, 0xe0, 0x3b, 0xda, 0xe4, 0x64, 0x5d, 0x58, 0xbf, 0xba, 0x39, 0x3d,
	0x9a, 0x02, 0xf0, 0x55, 0xe4, 0x68, 0x83, 0xe4, 0x5e, 0xb8, 0x6b, 0x96, 0xcd, 0xdd, 0xa0, 0x38,
	0x73, 0x17, 0xb6, 0xef, 0x16, 0x52, 0x7a, 0x06, 0xc4, 0xc9, 0xb1, 0x11, 0x3d, 0x9a, 0xaa, 0x69,
	0x42, 0x01, 0xbd, 0x40, 0xb2, 0x8b, 0xae, 0xd3, 0x94, 0x1e, 0x90, 0x45, 0x64, 0xd1, 0x38, 0x8d,
	0x3e, 0x24, 0x85, 0x65, 0xc3, 0xf7, 0xb7, 0x5c, 0xcf, 0x44, 0x0b, 0x2d, 0xce, 0x9c, 0x93, 0xc8,
	0x53, 0x8e, 0xef, 0x9e, 0xd3, 0x35, 0x2d, 0x64, 0xa5, 0x75, 0x92, 0x7d, 0xb9, 0xe5, 0x2e, 0xd4,
	0xd1, 0xa4, 0x8a, 0x33, 0xdf, 0x82, 0xd1, 0x05, 0x5b, 0xae, 0xbe, 0x6e, 0xec, 0x75, 0xab, 0x97,
	0x62, 0xa3, 0xe3, 0x64, 0x65, 0xce, 0xb9, 0x24, 0xbd, 0x43, 0x32, 0xcf, 0x0d, 0x67, 0xa3, 0x42,
	0x50, 0xc3, 0x05, 0xc0, 0x05, 0xdb, 0x70, 0x36, 0x92, 0x5b, 0x3e, 0xf4, 0x8b, 0x8c, 0x74, 0x9a,
	0x14, 0x66, 0x3b, 0x9e, 0xc7, 0x9c, 0xe6, 0x4e, 0xa5, 0x84, 0x42, 0x60, 0x23, 0x85, 0xa6, 0xa0,
	0xf5, 0x13, 0x0c, 0x05, 0xe8, 0xc7, 0x24, 0xff, 0x8a, 0xd9, 0x4d, 0xb7, 0xc5, 0x2a, 0xa3, 0xa1,
	0x6c, 0x7e, 0x8b, 0x93, 0xfa, 0x3e, 0xac, 0xe4, 0xa7, 0xf7, 0x49, 0xa9, 0xe1, 0xbc, 0xb1, 0x02,
	0x66, 0xce, 0xec, 0x34, 0xcc, 0xca, 0x18, 0xce, 0xe2, 0x89, 0xdd, 0x6e, 0x75, 0xcc, 0xe2, 0x64,
	0x7d, 0x6d, 0x47, 0xb7, 0x4c, 0x4d, 0xe5, 0xa2, 0xab, 0x64, 0x3c, 0x8e, 0xfc, 0x95, 0x71, 0xec,
	0xf6, 0xd6, 0x6e, 0xb7, 0x3a, 0x61, 0x84, 0x2d, 0xd2, 0x18, 0xce, 0xc4, 0xa0, 0x30, 0x32, 0xaa,
	0x84, 0x12, 0x18, 0x0b, 0x06, 0x6b, 0xf3, 0x9e, 0xb7, 0xd8, 0x69, 0x55, 0x26, 0x30, 0xf4, 0xc3,
	0xb1, 0xd8, 0x40, 0xd6, 0x99, 0xe7, 0xe9, 0x4e, 0xa7, 0xa5, 0xa9, 0x5c, 0xf4, 0x63, 0x92, 0x03,
	0x30, 0xec, 0xf8, 0x95, 0xf2, 0xb0, 0x9d, 0x1c, 0x23, 0x44, 0x1f, 0x19, 0x35, 0x21, 0x10, 0xdf,
	0xcb, 0x4f, 0x1c, 0xfd, 0x5e, 0x4e, 0x8f, 0x64, 0x2f, 0xff, 0x9b, 0x1c, 0xc9, 0xd5, 0xdb, 0xd6,
	0x97, 0x6c, 0xe7, 0x5d, 0x21, 0xd8, 0x53, 0x52, 0x78, 0x65, 0xd8, 0x36, 0x03, 0x69, 0xbe, 0x79,
	0x43, 0x28, 0x5b, 0xdc, 0x42, 0x5a, 0x5f, 0xe1, 0x90, 0x9f, 0xde, 0x21, 0xa4, 0xde, 0x6c, 0x32,
	0xdf, 0x87, 0x55, 0x44, 0xf8, 0xca, 0xce, 0x4c, 0x40, 0xb4, 0x67, 0x20, 0x55, 0x87, 0x59, 0xd1,
	0x14, 0x16, 0xba, 0x84, 0x63, 0x65, 0xbe, 0xff, 0x25, 0xdb, 0x11, 0x00, 0x75, 0x57, 0x8c, 0x15,
	0xf8, 0x5f, 0x33, 0xf0, 0xa5, 0x6a, 0xcc, 0x22, 0x1d, 0x37, 0xb8, 0xe2, 0x74, 0x6c, 0x5b, 0xa0,
	0xcb, 0x03, 0x31, 0x7a, 0xae, 0x83, 0x7e, 0x4e, 0x8a, 0xcb, 0x9d, 0x35, 0xdb, 0x6a, 0x82, 0x42,
	0x8e, 0x57, 0x35, 0x50, 0xd8, 0x46, 0xa2, 0x50, 0x18, 0xf3, 0xb0, 0x7b, 0x4f, 0x40, 0x43, 0x28,
	0x44, 0xaf, 0x91, 0x1c, 0x6e, 0x12, 0xa6, 0x00, 0xa9, 0x12, 0x78, 0x27, 0xe2, 0xb7, 0x65, 0x6a,
	0xa2, 0x89, 0x3e, 0x25, 0xf9, 0x46, 0xfb, 0xb9, 0xd5, 0xb2, 0x02, 0x01, 0x55, 0x57, 0xc0, 0xff,
	0xad, 0xb6, 0x6e, 0x03, 0x2d, 0xd1, 0xc5, 0xc3, 0xbb, 0xf7, 0xc0, 0x89, 0x85, 0x00, 0x7d, 0x04,
	0xb1, 0x51, 0xcb, 0xf0, 0x5e, 0x0b, 0xc4, 0x82, 0xe9, 0xcd, 0x79, 0x48, 0xe9, 0x1b, 0x09, 0x0b,
	0x6e, 0xf0, 0x1d, 0xee, 0x12, 0x88, 0x53, 0x6f, 0xe7, 0x3b, 0x7e, 0x1f, 0xdf, 0xf9, 0x3f, 0x1b,
	0x07, 0xff, 0x49, 0x2a, 0xb6, 0x21, 0x0e, 0x74, 0xa0, 0x3b, 0x4a, 0x36, 0x2b, 0xb6, 0x83, 0x41,
	0x1b, 0x25, 0x8f, 0x13, 0x7f, 0x35, 0x59, 0x4e, 0xed, 0x8f, 0xd3, 0xa4, 0xa0, 0xb9, 0x36, 0x6b,
	0x04, 0xac, 0x35, 0x70, 0x70, 0x8f, 0x63, 0x39, 0xd8, 0x35, 0x25, 0x07, 0x3b, 0x9b, 0xb0, 0xea,
	0x28, 0x98, 0xc5, 0xa8, 0x22, 0x32, 0xbb, 0xf4, 0x3e, 0x66, 0xc7, 0x37, 0x1d, 0x69, 0x76, 0x31,
	0xdb, 0xc9, 0x1c, 0xbd, 0xed, 0x64, 0x8f, 0xc4, 0x76, 0xfe, 0x20, 0x43, 0x0a, 0xf5, 0x4e, 0xb0,
	0x39, 0x74, 0x6d, 0x1e, 0x42, 0xa4, 0x64, 0x76, 0x6c, 0xb9, 0x3a, 0x97, 0x78, 0xa4, 0x04, 0x94,
	0x84, 0xf1, 0x3c, 0xc4, 0x19, 0xe6, 0xcc, 0xe1, 0x92, 0xa6, 0x0f, 0xba, 0xa4, 0xb7, 0x48, 0x7a,
	0xd5, 0x93, 0x61, 0xe2, 0x05, 0x4c, 0xb1, 0x3c, 0xbb, 0xef, 0x62, 0x02, 0x5f, 0xd2, 0x4c, 0xb3,
	0x87, 0x4c, 0xc6, 0x63, 0x06, 0x91, 0x3b, 0x7a, 0x83, 0xc8, 0x1f, 0x89, 0x41, 0xd8, 0xdc, 0x57,
	0xc1, 0x26, 0x06, 0xda, 0xc3, 0x35, 0x92, 0x43, 0x7f, 0x96, 0xdb, 0x30, 0x6e, 0x25, 0x9e, 0x6b,
	0x33, 0xdc, 0x4a, 0x78, 0x13, 0x30, 0xa1, 0x61, 0xc9, 0xdd, 0x16, 0x99, 0x8c, 0x4e, 0xb0, 0x89,
	0x4c, 0xbc, 0xa9, 0xf6, 0xe3, 0x11, 0x42, 0xe0, 0xcf, 0xba, 0xef, 0x5b, 0x1b, 0xce, 0x90, 0x02,
	0x4d, 0x3c, 0x75, 0xc7, 0xfa, 0x98, 0xd1, 0x6f, 0xcf, 0x96, 0x89, 0xfa, 0x54, 0x22, 0x51, 0x1f,
	0x5c, 0x51, 0x93, 0x49, 0xf9, 0x83, 0xf0, 0xa1, 0x38, 0x18, 0x5c, 0x54, 0x1e, 0xaa, 0x9f, 0x14,
	0x7f, 0xca, 0xf7, 0xa0, 0xca, 0xf5, 0xf7, 0x22, 0xfd, 0x9b, 0x33, 0x02, 0x63, 0xe0, 0x0c, 0xde,
	0xec, 0x0d, 0x9e, 0xc6, 0xe3, 0xc1, 0x93, 0x1a, 0x2b, 0xdd, 0x0b, 0xeb, 0x66, 0x8a, 0x03, 0x97,
	0x21, 0xc3, 0x92, 0xfc, 0xe0, 0xc8, 0x9a, 0xca, 0x44, 0x9f, 0x11, 0x2a, 0x7e, 0xaa, 0xce, 0xc8,
	0x7d, 0xf8, 0xec, 0x6e, 0xb7, 0x7a, 0x52, 0x8a, 0x2a, 0x4e, 0xa9, 0xf5, 0x11, 0xa1, 0x1f, 0x46,
	0x79, 0x04, 0x77, 0xe5, 0x92, 0x92, 0x47, 0x44, 0x39, 0x43, 0x14, 0x72, 0xe7, 0x0e, 0x1a, 0x72,
	0x7f, 0x4a, 0xca, 0x98, 0x48, 0x60, 0xd0, 0x2f, 0xcc, 0x84, 0x7b, 0x1b, 0xdd, 0xed, 0x56, 0xc7,
	0xad, 0xb0, 0x4d, 0xef, 0x58, 0xa6, 0xd6, 0xc3, 0x4b, 0xa7, 0x7b, 0x32, 0x0f, 0x1e, 0x2c, 0x9d,
	0xec, 0x93, 0x79, 0xf4, 0xe4, 0x17, 0x37, 0x94, 0x4c, 0x9a, 0x07, 0x4a, 0x63, 0xb1, 0x4c, 0x5a,
	0x49, 0x98, 0x2f, 0x92, 0x0c, 0xa4, 0x83, 0x22, 0x7f, 0xc3, 0xf2, 0x73, 0xdb, 0xf0, 0x7d, 0x0d,
	0xa9, 0xb4, 0x2a, 0x93, 0xce, 0x12, 0x0e, 0x1d, 0xab, 0x84, 0x0e, 0x10, 0x64, 0xe2, 0x59, 0x25,
	0xd9, 0xf9, 0x17, 0x90, 0x6f, 0xf3, 0x74, 0xac, 0x18, 0xe6, 0xdb, 0x1a, 0xa7, 0xd3, 0x5a, 0x98,
	0x01, 0x8f, 0x45, 0x05, 0x6c, 0x9e, 0xea, 0x86, 0xa9, 0xed, 0xbd, 0x78, 0xb2, 0x3d, 0x1e, 0x99,
	0x82, 0x9a, 0x6c, 0xc7, 0x33, 0xeb, 0x2b, 0x32, 0x75, 0x9d, 0x88, 0xd4, 0xf2, 0x1c, 0x55, 0x66,
	0xa6, 0x0f, 0x49, 0x76, 0x99, 0x79, 0x2d, 0xbf, 0x72, 0xea, 0x4a, 0xfa, 0x7a, 0xe9, 0xde, 0xa9,
	0x58, 0x05, 0x4a, 0x6c, 0x47, 0x7c, 0xc0, 0x6d, 0x60, 0xd3, 0x38, 0x37, 0x88, 0x81, 0xdf, 0xf9,
	0x95, 0xd3, 0xbd, 0x62, 0x32, 0xc2, 0xe0, 0x62, 0xe0, 0xb8, 0xbe, 0xc6, 0xb9, 0x61, 0x22, 0xea,
	0x66, 0xcb, 0x72, 0x2a, 0x67, 0xae, 0xa4, 0xae, 0x17, 0x38, 0x83, 0x01, 0x04, 0x8d, 0xd3, 0x61,
	0xa2, 0x31, 0x51, 0x3e, 0x1b, 0x4d, 0x34, 0x24, 0xca, 0x22, 0x2b, 0xbe, 0xae, 0x64, 0xc5, 0x15,
	0xe4, 0x18, 0x55, 0xb3, 0x62, 0x25, 0x05, 0x4e, 0xe4, 0x8e, 0xe7, 0xde, 0x2a, 0x77, 0x8c, 0x41,
	0xc8, 0xe5, 0xa3, 0xdf, 0x77, 0xaa, 0x47, 0xb2, 0xef, 0x6c, 0x93, 0x82, 0xc6, 0xfc, 0x36, 0xac,
	0x33, 0x9d, 0x94, 0xd6, 0x91, 0x1a, 0x6c, 0x1d, 0xd2, 0x24, 0x26, 0xa5, 0x49, 0x8c, 0x0c, 0x36,
	0x09, 0x69, 0x07, 0xa7, 0xa4, 0x1d, 0x00, 0xa0, 0x15, 0xc4, 0xe2, 0xd7, 0xd6, 0xc8, 0xc4, 0x0a,
	0xf3, 0x7d, 0xcb, 0x75, 0xf6, 0x0d, 0x84, 0x2e, 0xc6, 0x22, 0x9a, 0x82, 0x8c, 0x68, 0x44, 0xd8,
	0x72, 0x8e, 0x87, 0x2d, 0x1c, 0xb4, 0xf2, 0x22, 0x6c, 0xc1, 0x10, 0xa5, 0xf6, 0x2c, 0xec, 0x63,
	0xdf, 0x40, 0xf8, 0x62, 0x2c, 0x10, 0x4e, 0xf4, 0x51, 0xdb, 0xcb, 0x92, 0x92, 0xd0, 0x04, 0x30,
	0x71, 0x84, 0x78, 0x7f, 0xd8, 0xb3, 0x8b, 0x7e, 0xe0, 0x9b, 0x3d, 0x00, 0xf8, 0xaa, 0xf8, 0x99,
	0x1b, 0x8e, 0x9f, 0xd5, 0x78, 0x59, 0x6e, 0x08, 0x42, 0x16, 0x06, 0x20, 0x64, 0x02, 0xfd, 0x8a,
	0x6f, 0x83, 0x7e, 0x11, 0xaa, 0x92, 0x81, 0xa8, 0x1a, 0x22, 0x52, 0x69, 0x1f, 0x44, 0x1a, 0xdd,
	0x17, 0x91, 0xc6, 0x86, 0x22, 0x52, 0x08, 0xc5, 0xe3, 0x83, 0xa0, 0x58, 0xd9, 0x6e, 0x27, 0x86,
	0x6c, 0xb7, 0x9f, 0x48, 0x3f, 0xe3, 0x88, 0x7d, 0x21, 0xb6, 0xdc, 0x71, 0xd3, 0xee, 0x83, 0xc0,
	0x9f, 0x48, 0x8f, 0x3e, 0x3d, 0x50, 0x7a, 0x30, 0xec, 0xd7, 0xfe, 0x32, 0x15, 0x1a, 0x3d, 0x06,
	0x39, 0xe1, 0x58, 0x52, 0x5f, 0x6b, 0x2c, 0x23, 0x87, 0x18, 0x0b, 0xfd, 0x88, 0xe4, 0x2d, 0x5f,
	0x41, 0x11, 0x3e, 0xf3, 0x96, 0xaf, 0xf3, 0xe5, 0x93, 0x8d, 0xb5, 0x9f, 0x8e, 0x90, 0xd2, 0xac,
	0xd1, 0xdc, 0x64, 0xfb, 0x54, 0xb5, 0x0e, 0xe6, 0xa8, 0x37, 0x7a, 0x8a, 0x58, 0x63, 0xb1, 0x22,
	0xd6, 0xd7, 0xa9, 0x59, 0xdd, 0xec, 0xad, 0x59, 0x8d, 0xc7, 0x6b, 0x56, 0x6a, 0x41, 0xea, 0x66,
	0x6f, 0x41, 0x6a, 0x3c, 0x5e, 0x90, 0x3a, 0x70, 0xf1, 0xe9, 0xa3, 0x64, 0xf1, 0x69, 0x54, 0x2d,
	0x3e, 0x85, 0x85, 0xa6, 0xda, 0x0f, 0xd2, 0xa4, 0x38, 0x63, 0xbb, 0xcd, 0xd7, 0x78, 0xe0, 0x31,
	0x1e, 0x4d, 0x2c, 0x4e, 0xe8, 0x19, 0x8c, 0xfc, 0x67, 0x65, 0xae, 0xa0, 0x89, 0x5f, 0x40, 0x5f,
	0xd9, 0x69, 0xad, 0xb9, 0xe2, 0xb4, 0x5e, 0x13, 0xbf, 0x60, 0x53, 0x98, 0xdd, 0x34, 0x2c, 0x11,
	0xaa, 0x6a, 0xfc, 0x07, 0x3d, 0x4f, 0x0a, 0xd8, 0x05, 0x6c, 0xe3, 0x88, 0x4e, 0x5a, 0xf8, 0x9b,
	0x1f, 0x3a, 0xc1, 0x0f, 0x3c, 0xf1, 0xc9, 0x29, 0x87, 0x4e, 0x40, 0x7c, 0xc7, 0x87, 0x4e, 0xb2,
	0xdf, 0xf7, 0x21, 0x57, 0xfc, 0xb3, 0x0c, 0x21, 0xc2, 0xde, 0x86, 0x1d, 0x3d, 0xcd, 0x26, 0xb2,
	0xb7, 0x6f, 0x45, 0xd9, 0xdb, 0x95, 0xe4, 0xa1, 0xa9, 0xb4, 0x64, 0x67, 0xdd, 0xd5, 0x0d, 0xcb,
	0x54, 0x13, 0x3a, 0x75, 0xeb, 0x1d, 0x74, 0x46, 0xcf, 0xab, 0x02, 0x99, 0xaf, 0xb5, 0x41, 0x2d,
	0x91, 0xec, 0x2b, 0xf4, 0x99, 0x2c, 0xca, 0x9d, 0x51, 0xe5, 0xf8, 0xd3, 0xa2, 0xe0, 0x55, 0x10,
	0xdc, 0x82, 0xa9, 0xdd, 0xeb, 0x56, 0x4f, 0xc5, 0xce, 0x63, 0x90, 0x3a, 0x5d, 0xd3, 0xb8, 0x9e,
	0x78, 0x80, 0x77, 0xef, 0xe8, 0x03, 0xbc, 0xfb, 0x47, 0x62, 0x2c, 0xff, 0x58, 0x24, 0xa5, 0xba,
	0x69, 0x7a, 0xcc, 0xf7, 0x87, 0x5a, 0xcb, 0x72, 0x2f, 0x20, 0xde, 0xeb, 0x29, 0xf3, 0xf7, 0xb1,
	0x1b, 0x0b, 0xec, 0x45, 0xdf, 0xb2, 0x4c, 0xbd, 0x09, 0x76, 0xa3, 0x80, 0xe6, 0x67, 0x21, 0xf8,
	0x70, 0xc8, 0xfc, 0xa6, 0x02, 0x3e, 0x7b, 0xdd, 0x6a, 0xa5, 0x9f, 0xae, 0x0e, 0xda, 0x9e, 0x00,
	0xa6, 0x17, 0x0a, 0xea, 0xf2, 0xe2, 0xc0, 0xdd, 0xe4, 0xd1, 0xc1, 0xfe, 0x03, 0x8a, 0x90, 0xf9,
	0x19, 0xc9, 0xcd, 0xba, 0x96, 0xd3, 0x90, 0x71, 0xcf, 0x1d, 0x7e, 0xa5, 0xc6, 0x72, 0xde, 0x56,
	0x95, 0x10, 0xa7, 0x0f, 0x43, 0x48, 0xcb, 0x45, 0x75, 0x39, 0x1f, 0x29, 0xc9, 0xab, 0x39, 0x8f,
	0xa6, 0x6b, 0x21, 0xe2, 0x5d, 0x23, 0xb9, 0x2f, 0xcc, 0x65, 0x23, 0xd8, 0x44, 0xd8, 0x10, 0x1b,
	0xfe, 0xa6, 0xa9, 0xb7, 0x8d, 0x60, 0x53, 0x13, 0x4d, 0xf4, 0x21, 0x19, 0x0d, 0x57, 0xcb, 0x64,
	0xdb, 0x88, 0xc8, 0x22, 0x97, 0x31, 0x38, 0x5d, 0xc7, 0x11, 0x6a, 0x31, 0x36, 0x7a, 0x9f, 0x64,
	0x9f, 0x1b, 0x6b, 0xcc, 0x16, 0xa1, 0x12, 0x8c, 0x28, 0x6b, 0x03, 0xa1, 0xaf, 0xa3, 0x72, 0x5e,
	0xba, 0x48, 0xf2, 0x42, 0x89, 0x08, 0x99, 0x1e, 0x60, 0xad, 0x88, 0x93, 0xf6, 0xba, 0xd5, 0x0f,
	0xfb, 0xce, 0x08, 0x6f, 0x56, 0x4e, 0xf2, 0xa4, 0x12, 0x3a, 0x4f, 0x32, 0x2f, 0x58, 0xcb, 0x15,
	0x47, 0x98, 0xb0, 0x56, 0x99, 0x16, 0x6b, 0xb9, 0x6f, 0xaf, 0x09, 0xc5, 0xe3, 0x67, 0x2e, 0xa3,
	0x6f, 0x73, 0xe6, 0x82, 0x0f, 0xa5, 0x6c, 0x7b, 0x21, 0x04, 0x8d, 0x1d, 0x0c, 0x82, 0x3e, 0x24,
	0xf9, 0x19, 0xc3, 0x36, 0x20, 0x74, 0x85, 0xb8, 0x2d, 0xc5, 0x97, 0x68, 0x8d, 0x93, 0x34, 0xd9,
	0x46, 0x1f, 0x92, 0x0c, 0x02, 0xd5, 0x44, 0x9f, 0x5b, 0x24, 0xfc, 0x99, 0x50, 0x3f, 0x46, 0x8f,
	0xb8, 0xdd, 0x23, 0x3b, 0x7d, 0x42, 0xc6, 0x5e, 0xb8, 0x8e, 0x15, 0xb8, 0x9e, 0x72, 0x66, 0x99,
	0xe5, 0xe1, 0x77, 0x8b, 0x37, 0xe8, 0xa2, 0x62, 0x12, 0x67, 0x3c, 0x3e, 0x6f, 0x41, 0x24, 0xfb,
	0xa3, 0x71, 0x52, 0x40, 0x0f, 0x1c, 0x06, 0x63, 0x9a, 0x0c, 0x2b, 0x78, 0x1e, 0xf7, 0x09, 0xac,
	0x71, 0x13, 0x08, 0x7b, 0xdd, 0xea, 0x9d, 0x78, 0xc5, 0x3c, 0xb2, 0x46, 0x0e, 0x02, 0xb0, 0xf7,
	0x21, 0xab, 0xce, 0x7d, 0xb9, 0x26, 0x83, 0x92, 0xd5, 0x78, 0x08, 0x33, 0xf3, 0xed, 0x98, 0xbf,
	0x1f, 0x58, 0xab, 0xc4, 0x83, 0x44, 0xfd, 0x3c, 0x73, 0xc8, 0xfa, 0xf9, 0x27, 0x7c, 0x56, 0xc0,
	0xf2, 0x44, 0xf8, 0x78, 0x05, 0x6d, 0x03, 0x7a, 0x07, 0x17, 0xeb, 0x77, 0xce, 0x14, 0x4a, 0xd0,
	0x4f, 0xc9, 0xc4, 0x92, 0x67, 0x6d, 0x58, 0x8e, 0x61, 0xcf, 0xb1, 0xa6, 0xd5, 0x32, 0x38, 0xa8,
	0x65, 0x67, 0x4e, 0xed, 0x76, 0xab, 0x65, 0x57, 0x34, 0xe9, 0x26, 0x6f, 0xd3, 0x92, 0xcc, 0x80,
	0x57, 0xff, 0xdf, 0xb0, 0x2d, 0x53, 0x0a, 0xe7, 0x23, 0xbc, 0x7a, 0x03, 0xf4, 0x50, 0x32, 0xc6,
	0x06, 0x01, 0x75, 0xc3, 0xc7, 0x0a, 0x1d, 0x2f, 0xe2, 0x15, 0x78, 0x40, 0x0d, 0xf1, 0x3c, 0x12,
	0xb5, 0xb0, 0x19, 0x02, 0xea, 0x59, 0xc3, 0x99, 0x63, 0x6d, 0xd7, 0xb7, 0x02, 0xc4, 0xb7, 0x02,
	0x0f, 0xa8, 0x9b, 0x86, 0xa3, 0x9b, 0x9c, 0xac, 0x29, 0x2c, 0x98, 0x3c, 0x1a, 0xce, 0x2b, 0x2b,
	0xd8, 0x34, 0x3d, 0x63, 0x0b, 0xa1, 0xad, 0x20, 0x92, 0x47, 0xc3, 0xd1, 0xb7, 0x04, 0x5d, 0x53,
	0x99, 0x40, 0x66, 0x7e, 0xbb, 0x6d, 0xbb, 0x1e, 0xf3, 0x56, 0x3d, 0x5b, 0x20, 0x18, 0xca, 0x30,
	0x41, 0xd6, 0x3b, 0x9e, 0xad, 0xa9, 0x4c, 0x90, 0x2b, 0x36, 0x9a, 0xae, 0xa3, 0xe6, 0x8a, 0x56,
	0xd3, 0x75, 0x34, 0xa4, 0x02, 0xda, 0x37, 0xfc, 0xd5, 0x60, 0xdb, 0x45, 0x10, 0x2a, 0x70, 0x28,
	0xb1, 0x7c, 0xbd, 0x13, 0x6c, 0xbb, 0x9a, 0x68, 0x82, 0x68, 0xbe, 0xe1, 0xcf, 0xba, 0xb6, 0xcd,
	0x9a, 0x01, 0x42, 0x4e, 0x81, 0x47, 0xf3, 0x96, 0xaf, 0x37, 0x39, 0x55, 0x8b, 0x18, 0xe8, 0x77,
	0xc8, 0xc9, 0x59, 0xd7, 0x59, 0xb7, 0xbc, 0x96, 0xe5, 0x6c, 0xbc, 0xdc, 0xf4, 0x98, 0xbf, 0xe9,
	0xda, 0x26, 0x5e, 0x5e, 0xc8, 0x62, 0xa5, 0xfd, 0x54, 0x33, 0x6c, 0xd6, 0x03, 0xd9, 0xae, 0xf5,
	0x13, 0x02, 0x30, 0x9a, 0xeb, 0xf8, 0x41, 0xa4, 0x85, 0x46, 0x60, 0x64, 0x76, 0xfc, 0x40, 0x91,
	0x8f, 0x33, 0xc2, 0x54, 0x69, 0xec, 0xab, 0x0e, 0xf3, 0x03, 0x04, 0xfb, 0x93, 0xd1, 0xf4, 0x7a,
	0x9c, 0xac, 0x03, 0xe8, 0x6b, 0x2a, 0x13, 0x7d, 0x4c, 0x72, 0x5a, 0xbb, 0x09, 0x33, 0x7b, 0x2a,
	0xba, 0xa2, 0xe2, 0xb5, 0x9b, 0x7a, 0xef, 0x01, 0x93, 0x3c, 0xa4, 0x46, 0x76, 0x3a, 0x45, 0xc8,
	0x17, 0x26, 0x18, 0x2b, 0x02, 0xee, 0x69, 0x1c, 0x23, 0xf6, 0xb5, 0x69, 0x72, 0xff, 0xe2, 0xe9,
	0x54, 0xc4, 0x43, 0x67, 0x48, 0x59, 0xcc, 0x57, 0xbd, 0x05, 0x81, 0xc8, 0x0b, 0x51, 0x7f, 0x4c,
	0xcd, 0x9c, 0xd9, 0xed, 0x56, 0xa9, 0x98, 0x56, 0xdd, 0xc0, 0x46, 0x1d, 0x72, 0xc7, 0x1e, 0x7e,
	0x3a, 0x4b, 0xca, 0x2b, 0xb6, 0xbb, 0xb5, 0xc0, 0xd8, 0xaa, 0x63, 0x05, 0xcb, 0x9e, 0xd5, 0x64,
	0x58, 0x21, 0x4c, 0xf1, 0x8a, 0xba, 0x6f, 0xbb, 0x5b, 0xfa, 0x3a, 0x63, 0x7a, 0xc7, 0xb1, 0x02,
	0xbd, 0x0d, 0xcd, 0x5a, 0x8f, 0x00, 0x6d, 0x10, 0xfa, 0xc2, 0x32, 0x4d, 0x9b, 0xc5, 0xd4, 0x54,
	0x51, 0xcd, 0xb9, 0xdd, 0x6e, 0xf5, 0x74, 0x0b, 0x5b, 0x93, 0x8a, 0xfa, 0x08, 0xc1, 0x78, 0x16,
	0x0c, 0x3f, 0x88, 0x29, 0xba, 0x12, 0x8d, 0x67, 0xdd, 0xf0, 0x83, 0x9e, 0xf1, 0x24, 0x05, 0xc0,
	0xe5, 0x16, 0x18, 0xc3, 0x8a, 0x49, 0xe5, 0x2a, 0x0a, 0xa3, 0xcb, 0x81, 0x1c, 0x46, 0x6c, 0x5a,
	0xd8, 0x4c, 0x3f, 0x26, 0x63, 0x0b, 0x8c, 0x61, 0xd6, 0xc7, 0xf9, 0x6b, 0xc8, 0x8f, 0x75, 0x76,
	0xe0, 0xc7, 0xc4, 0x50, 0x48, 0xc5, 0x39, 0xe9, 0x2d, 0x52, 0x5c, 0x60, 0x4c, 0x64, 0x82, 0xdf,
	0x40, 0x78, 0x46, 0x67, 0x05, 0x31, 0x8f, 0xad, 0x43, 0x20, 0xa5, 0x45, 0x1c, 0xf4, 0x33, 0x64,
	0x17, 0xe8, 0xfa, 0x61, 0x74, 0x51, 0x1a, 0xd8, 0x07, 0x47, 0x54, 0x91, 0xcc, 0x71, 0x90, 0x2f,
	0x33, 0xc2, 0x31, 0x1e, 0xe7, 0x7e, 0x61, 0xf2, 0x80, 0x70, 0xd0, 0xfe, 0xb8, 0xd8, 0x1b, 0xe6,
	0x4f, 0xf5, 0x84, 0xf9, 0x97, 0xd5, 0x70, 0xad, 0x31, 0xf7, 0x5d, 0xbd, 0xde, 0x98, 0xd3, 0x67,
	0x1b, 0x73, 0x7a, 0x63, 0x71, 0x6e, 0xfe, 0xbb, 0xb1, 0x20, 0x7f, 0x3e, 0x0c, 0xaa, 0x79, 0x90,
	0x7f, 0x2b, 0x1e, 0x54, 0xef, 0xa7, 0x49, 0x86, 0xd4, 0x26, 0x29, 0xab, 0xf1, 0xec, 0x73, 0xc3,
	0x0f, 0x44, 0xed, 0xe4, 0x09, 0x78, 0x6d, 0x2c, 0xf4, 0xd5, 0x6d, 0xc3, 0x0f, 0xde, 0x42, 0x77,
	0x8f, 0xc6, 0xe3, 0x38, 0x0a, 0x8d, 0xe5, 0x1f, 0x8a, 0xb2, 0x7c, 0x00, 0x93, 0x3f, 0xd0, 0x52,
	0x9e, 0x63, 0xf9, 0xe0, 0x55, 0x58, 0x3e, 0x80, 0xe4, 0x20, 0xbd, 0x85, 0xab, 0x7a, 0x43, 0xbd,
	0x41, 0xa5, 0xd6, 0x0f, 0x78, 0xd0, 0x11, 0xcb, 0x99, 0xb8, 0x0e, 0xa1, 0xad, 0x1e, 0x1e, 0x0c,
	0x3f, 0x88, 0x8a, 0x11, 0x07, 0xd4, 0x56, 0x0f, 0xb5, 0x01, 0xc4, 0x64, 0x22, 0x6d, 0xcd, 0xc3,
	0x68, 0x03, 0x10, 0x8a, 0xf2, 0xb9, 0xec, 0x3e, 0xf9, 0x1c, 0xbf, 0x67, 0x21, 0xa0, 0xe7, 0x3e,
	0xc6, 0x19, 0x0b, 0xd6, 0x36, 0x33, 0x17, 0x18, 0x2f, 0x48, 0x15, 0x78, 0xe4, 0x03, 0x71, 0xc6,
	0x3a, 0xd0, 0x01, 0x95, 0x35, 0x95, 0x0b, 0x51, 0x58, 0x4a, 0xe4, 0x15, 0x14, 0x0e, 0xb9, 0xc3,
	0x66, 0xfa, 0x09, 0x19, 0x9f, 0x35, 0x9c, 0x65, 0xdb, 0x08, 0xd6, 0x5d, 0xaf, 0x05, 0x02, 0x3c,
	0x52, 0xc2, 0xc8, 0x0c, 0xba, 0x68, 0x8b, 0x26, 0x94, 0x4b, 0xf0, 0xc2, 0x36, 0xad, 0x8a, 0x16,
	0xb1, 0x2f, 0xdc, 0x3a, 0x63, 0x62, 0x2a, 0x53, 0x1c, 0xbc, 0xc9, 0xc1, 0xc0, 0xbb, 0xf4, 0x16,
	0xe0, 0x8d, 0xd3, 0xa7, 0x80, 0x77, 0x3c, 0xb4, 0x1b, 0x3d, 0x70, 0x68, 0x37, 0xf6, 0x36, 0xa1,
	0x5d, 0x98, 0x1a, 0x8f, 0x47, 0xa9, 0xf1, 0xf3, 0x3e, 0xa9, 0x31, 0x0f, 0x3c, 0x44, 0x6a, 0xfc,
	0x31, 0x19, 0x9b, 0x35, 0x9c, 0x45, 0xb6, 0x25, 0x13, 0xe4, 0x09, 0xec, 0x0a, 0x77, 0x40, 0xe8,
	0xca, 0x61, 0x5b, 0x32, 0x7f, 0xd5, 0xe2, 0x9c, 0x51, 0xf2, 0x79, 0xe2, 0x60, 0xc9, 0xa7, 0x1a,
	0x12, 0xd3, 0xe1, 0x21, 0xf1, 0x31, 0x8e, 0x01, 0x8e, 0xfd, 0x5d, 0x36, 0xac, 0x95, 0xd4, 0x7d,
	0x9f, 0x05, 0x43, 0x4a, 0x5b, 0x71, 0x24, 0x7b, 0x82, 0xd1, 0x27, 0x5b, 0xd7, 0x63, 0x68, 0xd6,
	0x53, 0x0c, 0x35, 0x40, 0x69, 0x7f, 0x34, 0x5b, 0x4e, 0xa0, 0x59, 0xa8, 0xd1, 0x38, 0x8c, 0xc6,
	0x7a, 0xa8, 0x31, 0x42, 0xb4, 0x50, 0x63, 0xf3, 0x30, 0x1a, 0xc1, 0x3b, 0x6b, 0x09, 0x54, 0x23,
	0x11, 0xaa, 0x85, 0x10, 0x56, 0x89, 0x2a, 0x40, 0x58, 0xca, 0x8a, 0x6a, 0x39, 0x54, 0xd4, 0x72,
	0xb0, 0x54, 0x25, 0x0a, 0x33, 0xb3, 0x51, 0x79, 0xa4, 0x80, 0x70, 0x72, 0x43, 0x29, 0x8f, 0xec,
	0x75, 0xab, 0xe7, 0xd5, 0xf5, 0xe6, 0x89, 0xde, 0xf5, 0xfb, 0x0f, 0x6e, 0xde, 0x9d, 0xba, 0x51,
	0x8b, 0x8a, 0x27, 0x31, 0xdb, 0x1d, 0x3f, 0x12, 0xdb, 0xfd, 0xa1, 0x6a, 0xbb, 0x13, 0x38, 0x84,
	0xd7, 0xbb, 0xdd, 0xea, 0x09, 0xf1, 0x24, 0xba, 0x6a, 0xc3, 0xa7, 0xfa, 0x0c, 0xe5, 0x57, 0x67,
	0xc2, 0xff, 0x92, 0x25, 0x25, 0xbe, 0x15, 0x0f, 0xb7, 0xe0, 0xfd, 0xf7, 0xe2, 0x83, 0x58, 0xef,
	0xfe, 0x7b, 0xf1, 0x41, 0x2c, 0x77, 0xff, 0xbd, 0xf8, 0x20, 0x56, 0x7b, 0xc8, 0xbd, 0x58, 0x31,
	0xcd, 0xdc, 0xa1, 0x4d, 0xf3, 0x73, 0x92, 0x5b, 0xf0, 0x18, 0xfb, 0x9e, 0xdc, 0x99, 0xaf, 0x43,
	0xdf, 0xeb, 0x48, 0xd9, 0x47, 0x85, 0x90, 0x3b, 0x06, 0x66, 0xb4, 0xea, 0xff, 0xca, 0x92, 0x93,
	0x8a, 0x55, 0xaf, 0x38, 0x46, 0xdb, 0xdf, 0x74, 0x8f, 0xad, 0xfb, 0xd7, 0xdd, 0xba, 0x7f, 0x94,
	0x22, 0x63, 0xb8, 0xa2, 0xa1, 0x7d, 0xf1, 0x37, 0xff, 0x7e, 0x0b, 0xef, 0xdf, 0xe1, 0x53, 0xbf,
	0x73, 0x2b, 0x8b, 0x0f, 0x80, 0xfe, 0x20, 0x45, 0x88, 0xb4, 0xaf, 0x70, 0x3f, 0x59, 0x87, 0x10,
	0xd2, 0x17, 0xd4, 0x77, 0x38, 0x16, 0xa5, 0xe7, 0xda, 0x5f, 0x64, 0xc9, 0xa8, 0x0c, 0x39, 0x21,
	0x9e, 0x3b, 0x36, 0x76, 0x08, 0x40, 0x78, 0x49, 0x0d, 0x8d, 0x3d, 0xc5, 0x03, 0x10, 0x5e, 0x77,
	0xd3, 0x44, 0x0b, 0xc4, 0xd9, 0xfc, 0xaf, 0x65, 0xe6, 0x7d, 0xe1, 0x76, 0x3c, 0x61, 0xdf, 0xfc,
	0x46, 0x27, 0x2f, 0xd1, 0xb5, 0x99, 0xa7, 0x6f, 0xba, 0x1d, 0x4f, 0x8b, 0x73, 0xd2, 0x47, 0x64,
	0x34, 0x24, 0xcc, 0x19, 0x3b, 0xc2, 0xaa, 0xb1, 0x80, 0xa9, 0x48, 0x9a, 0xc6, 0x8e, 0x16, 0xe3,
	0x3b, 0xc6, 0x68, 0xc4, 0xe8, 0xbf, 0x2a, 0x90, 0xcc, 0x8c, 0x65, 0xdb, 0x03, 0xed, 0x74, 0x29,
	0x61, 0xa7, 0x8f, 0x23, 0x3b, 0xbd, 0x99, 0xb4, 0x05, 0x4c, 0xad, 0x45, 0xbe, 0xa6, 0x07, 0xdb,
	0xfd, 0x4d, 0x75, 0x29, 0x61, 0xaa, 0x8f, 0x23, 0x53, 0x3d, 0xb8, 0xc2, 0x7a, 0xa8, 0x30, 0xb2,
	0xd6, 0xc7, 0x91, 0xb5, 0x1e, 0x5c, 0xe1, 0xd7, 0x40, 0xe7, 0xcf, 0x48, 0x01, 0x66, 0x12, 0x2b,
	0xd4, 0x79, 0xcc, 0xf9, 0x62, 0xb7, 0x21, 0x65, 0x1b, 0x4f, 0xe7, 0xd6, 0x2c, 0xdb, 0xe6, 0x45,
	0xeb, 0x50, 0x88, 0x7e, 0x44, 0xf2, 0x1a, 0xb3, 0x8d, 0x9d, 0x06, 0x7f, 0x51, 0x35, 0xc3, 0x2f,
	0xe0, 0x78, 0x40, 0xd2, 0x2d, 0x53, 0x93, 0x8d, 0xb4, 0x06, 0x7c, 0xeb, 0xb3, 0x81, 0x65, 0x8a,
	0xf7, 0x9d, 0xf9, 0x97, 0x31, 0x02, 0xce, 0x83, 0x0d, 0xf4, 0x21, 0x19, 0x9d, 0xdd, 0x34, 0x9c,
	0x0d, 0x26, 0x5c, 0xaf, 0x84, 0x5e, 0xc1, 0xab, 0x12, 0x48, 0x17, 0x95, 0x6f, 0x2d, 0xc6, 0x06,
	0x62, 0x1a, 0xf3, 0x3b, 0xb6, 0x28, 0x82, 0x63, 0x2e, 0x2e, 0xc4, 0x3c, 0xa4, 0x87, 0x62, 0x2a,
	0x1b, 0xbd, 0xa1, 0x16, 0x0c, 0xc6, 0xa2, 0x2b, 0x46, 0x58, 0x54, 0x1e, 0x52, 0x2c, 0x18, 0x3f,
	0x44, 0xb1, 0xe0, 0x73, 0x52, 0x6c, 0x38, 0x0e, 0xf3, 0x5e, 0x6e, 0x5b, 0x26, 0x1e, 0x9d, 0x8a,
	0x63, 0x61, 0x0b, 0x88, 0x7a, 0xb0, 0x8d, 0x0b, 0xdf, 0xe7, 0x58, 0x38, 0x14, 0xa2, 0x1f, 0x47,
	0x1f, 0xd5, 0x38, 0x11, 0x1d, 0x43, 0x44, 0x1f, 0xd5, 0xe8, 0xad, 0x06, 0xbc, 0x47, 0x5f, 0xd5,
	0x78, 0x1f, 0x40, 0xe3, 0x17, 0x94, 0x57, 0x7b, 0x5f, 0x6e, 0x1f, 0xc3, 0xc6, 0x61, 0x60, 0x23,
	0x76, 0x1d, 0xe4, 0x86, 0x72, 0xd5, 0x2d, 0x17, 0xdd, 0x29, 0xe4, 0x97, 0xd9, 0x9c, 0x4e, 0x6b,
	0xe0, 0xcd, 0xb7, 0xfc, 0x11, 0xdd, 0x7c, 0x9b, 0x22, 0x19, 0xf4, 0xbd, 0x42, 0x74, 0x15, 0xac,
	0x8f, 0xd7, 0x89, 0xcf, 0xb5, 0xa0, 0xc3, 0x2d, 0x90, 0xd2, 0x82, 0xe7, 0xb6, 0x64, 0x89, 0x81,
	0xdf, 0x4d, 0xf9, 0xc6, 0x6e, 0xb7, 0x3a, 0xba, 0xee, 0xb9, 0x2d, 0x3d, 0xba, 0x69, 0xd2, 0xe7,
	0x88, 0x5b, 0x11, 0x04, 0xd7, 0x7f, 0xe9, 0xc6, 0xaf, 0xaa, 0xa0, 0xeb, 0x07, 0xee, 0x50, 0x1d,
	0x91, 0x10, 0x8c, 0x5d, 0xb9, 0x9a, 0x72, 0x51, 0xb9, 0x9a, 0xd2, 0xe7, 0x1a, 0x1b, 0x16, 0x3b,
	0x2e, 0x91, 0xcc, 0x52, 0x27, 0x58, 0x44, 0x24, 0x14, 0x77, 0x98, 0xdd, 0x4e, 0xa0, 0x3b, 0x1a,
	0x92, 0x95, 0xd7, 0x1f, 0xc7, 0x0e, 0xf4, 0xfa, 0xe3, 0xe7, 0x61, 0x50, 0x34, 0x1e, 0x45, 0xe1,
	0x1c, 0x5b, 0xf7, 0x8b, 0xc2, 0x05, 0xe6, 0x7e, 0x18, 0xa1, 0x98, 0x72, 0x71, 0x58, 0xa0, 0x58,
	0x84, 0x58, 0xf3, 0xa4, 0x28, 0x4e, 0x60, 0x1b, 0x12, 0x2e, 0xbf, 0x09, 0x73, 0x26, 0x0f, 0x69,
	0x71, 0xe1, 0x4e, 0x2b, 0xe3, 0xbc, 0x7f, 0x6f, 0x3a, 0x7c, 0x7d, 0x3b, 0x94, 0xa4, 0x0f, 0xc4,
	0x5d, 0x97, 0x13, 0xbd, 0x97, 0xf2, 0x5e, 0x6e, 0x43, 0x4b, 0xdf, 0xab, 0x2e, 0xcf, 0x54, 0xac,
	0xa6, 0xd8, 0xf9, 0x8d, 0x1e, 0xac, 0x3e, 0x9b, 0x98, 0xa4, 0xf0, 0x6d, 0x44, 0x05, 0xb2, 0x1f,
	0x90, 0xcc, 0x8a, 0x65, 0x32, 0x3c, 0x65, 0xee, 0xe9, 0x1e, 0x5a, 0xa2, 0xee, 0x7d, 0xcb, 0x64,
	0x1a, 0x72, 0xd3, 0x2a, 0xc9, 0xf2, 0xdb, 0x53, 0xa7, 0xa2, 0xc5, 0xe3, 0xb7, 0xa6, 0x38, 0x9d,
	0x4e, 0x92, 0xc2, 0x52, 0x5b, 0x5c, 0x82, 0xbf, 0x10, 0x5d, 0xfe, 0x75, 0xdb, 0x58, 0xe6, 0xee,
	0x58, 0xa6, 0x16, 0xb6, 0xd3, 0x39, 0x92, 0x87, 0x5d, 0xcc, 0x08, 0x58, 0xe5, 0x22, 0x2e, 0xd9,
	0x24, 0xec, 0xce, 0x58, 0x12, 0xe7, 0x9f, 0x67, 0x19, 0x9a, 0x7d, 0x09, 0x51, 0xfa, 0x0c, 0x4f,
	0x5f, 0xf9, 0x2d, 0xdb, 0x4b, 0xa8, 0xe6, 0x5b, 0xf2, 0xf4, 0x55, 0xbe, 0xe3, 0x3d, 0x4c, 0x4f,
	0x28, 0x4c, 0x1f, 0x93, 0xf4, 0x02, 0x93, 0xc7, 0xd1, 0x1f, 0x02, 0x76, 0xad, 0xb3, 0xfd, 0x46,
	0x01, 0x12, 0xb4, 0x4e, 0x72, 0x0b, 0x8c, 0xd5, 0x9b, 0x81, 0x38, 0x83, 0xbe, 0x21, 0x37, 0x6a,
	0xa3, 0xb9, 0xaf, 0xe9, 0x71, 0x41, 0xba, 0x1c, 0x3f, 0x53, 0xe0, 0x47, 0xd0, 0xb7, 0x93, 0x67,
	0x0a, 0xfb, 0x28, 0x8b, 0x9d, 0x38, 0xc4, 0x02, 0x88, 0xab, 0x43, 0x03, 0x88, 0x9b, 0x6a, 0x00,
	0x51, 0x8b, 0x6e, 0x3e, 0x47, 0x01, 0x44, 0xe2, 0x68, 0xa1, 0xde, 0x6e, 0x7b, 0xee, 0x1b, 0x06,
	0xf8, 0x7a, 0x4d, 0xb9, 0x86, 0xcd, 0xa9, 0x88, 0xb0, 0x0a, 0x0b, 0xfd, 0x84, 0x8c, 0x2f, 0x32,
	0x66, 0x2a, 0x42, 0xdf, 0x88, 0xee, 0xc1, 0x38, 0x8c, 0x99, 0xba, 0x2a, 0x99, 0xe0, 0xa5, 0xab,
	0xa4, 0x84, 0x77, 0x85, 0xc4, 0x93, 0x7c, 0x13, 0x9f, 0xe4, 0x3e, 0x46, 0x08, 0x78, 0xf7, 0x87,
	0xef, 0x2f, 0xb5, 0xbe, 0xfb, 0x4b, 0xb0, 0xad, 0x87, 0x4c, 0x35, 0x4d, 0xd5, 0x03, 0x83, 0x6a,
	0xf8, 0xcf, 0x98, 0xc3, 0xc0, 0xd4, 0x20, 0x5e, 0xac, 0x5c, 0x8f, 0x8e, 0x80, 0x2c, 0x5f, 0xdf,
	0x10, 0x4d, 0x3a, 0x84, 0x95, 0x5a, 0x82, 0x97, 0x3e, 0x91, 0x27, 0x11, 0x37, 0x7a, 0x2f, 0xaa,
	0xbd, 0xdc, 0x1e, 0x76, 0x16, 0x01, 0x51, 0x24, 0xbf, 0x34, 0xc2, 0x4c, 0x98, 0x8a, 0xc9, 0xe8,
	0x56, 0x4f, 0x53, 0xd2, 0x71, 0x1e, 0x62, 0x6c, 0x74, 0x86, 0x94, 0x61, 0x5e, 0x62, 0xa2, 0x37,
	0x51, 0x14, 0xef, 0x5e, 0xe0, 0x2c, 0xc6, 0xe5, 0x7b, 0xf8, 0xdf, 0xbb, 0x03, 0xfd, 0x47, 0x47,
	0x12, 0x69, 0xfd, 0x79, 0x96, 0x14, 0x5e, 0x6e, 0xd7, 0x9b, 0x78, 0xc3, 0x6b, 0x50, 0xac, 0xb5,
	0x92, 0x88, 0xb5, 0xa6, 0xe3, 0xe7, 0x1a, 0x87, 0x8b, 0xb7, 0x56, 0x12, 0xf1, 0xd6, 0x74, 0xfc,
	0x68, 0xe3, 0x70, 0x31, 0xd7, 0x4a, 0x22, 0xe6, 0x9a, 0x8e, 0x9f, 0x6e, 0x1c, 0x2e, 0xee, 0x3a,
	0x13, 0xbe, 0x6b, 0x9c, 0x0b, 0xdf, 0x38, 0x58, 0x7d, 0xcb, 0x83, 0x8f, 0x1a, 0xe4, 0x3b, 0xeb,
	0xd1, 0x1e, 0x75, 0x1d, 0x8f, 0x39, 0x62, 0x34, 0xfa, 0x98, 0x10, 0x8d, 0xad, 0x0b, 0x47, 0xc1,
	0xe0, 0x65, 0xb0, 0x0f, 0x69, 0x0a, 0x2b, 0x9e, 0xaa, 0x34, 0xf9, 0x2b, 0x5d, 0x44, 0x9c, 0xaa,
	0xf0, 0x9f, 0x7c, 0xc8, 0x90, 0x3f, 0x61, 0x20, 0x92, 0xd5, 0xc4, 0x2f, 0x7a, 0x85, 0x94, 0xc0,
	0x11, 0x16, 0xd9, 0x76, 0x00, 0x00, 0x8d, 0xe7, 0x9a, 0x9a, 0x4a, 0x02, 0x9d, 0x72, 0xd7, 0x1f,
	0xe5, 0x3a, 0xfb, 0xa6, 0x26, 0x47, 0xe2, 0x30, 0xb5, 0xff, 0xc8, 0x93, 0x89, 0xb0, 0xf8, 0xc5,
	0x82, 0xc0, 0x72, 0x06, 0x7f, 0x70, 0xb1, 0x9a, 0x78, 0x2b, 0x21, 0x2f, 0xe2, 0xf9, 0xd0, 0x56,
	0xee, 0x86, 0x56, 0xcd, 0x0d, 0xf0, 0x5c, 0x94, 0x41, 0xf4, 0x7c, 0x88, 0x4d, 0xd8, 0xec, 0x54,
	0x08, 0xf6, 0x75, 0x9b, 0x7f, 0xbf, 0x40, 0x9c, 0x0a, 0x0b, 0xc8, 0x36, 0x75, 0xc3, 0xb6, 0x35,
	0x85, 0x87, 0x7e, 0x49, 0x4e, 0xca, 0x01, 0xcf, 0x1a, 0xb6, 0xbd, 0x66, 0x34, 0x5f, 0x47, 0xef,
	0x10, 0xe2, 0xed, 0x2c, 0x79, 0x98, 0xac, 0x37, 0x45, 0x3b, 0x5e, 0x00, 0xec, 0x27, 0x05, 0xca,
	0x5e, 0x7a, 0x86, 0xe3, 0xaf, 0x33, 0x4f, 0x55, 0x96, 0x8b, 0x94, 0x05, 0xa2, 0x39, 0xa1, 0xac,
	0x8f, 0x14, 0x7d, 0x4e, 0x4e, 0x36, 0xfc, 0x59, 0xd7, 0x09, 0x0c, 0xcb, 0x11, 0xc0, 0x08, 0x30,
	0x9a, 0xc7, 0x87, 0x3a, 0xbf, 0xdb, 0xad, 0x9e, 0xc1, 0xcb, 0x81, 0xd8, 0x2e, 0xc1, 0x14, 0xa1,
	0xb4, 0x9f, 0x18, 0xfd, 0x4d, 0x52, 0x49, 0x8e, 0x58, 0x63, 0x81, 0xb7, 0x03, 0x2a, 0xf9, 0xd5,
	0x72, 0xc8, 0x81, 0x2f, 0xf4, 0x3e, 0xac, 0x07, 0x5c, 0xa8, 0x77, 0xa0, 0x02, 0x50, 0x9e, 0x7c,
	0x82, 0x50, 0x79, 0x31, 0x52, 0xde, 0xfb, 0xf0, 0x8a, 0xf2, 0x41, 0x0a, 0xa8, 0x41, 0xce, 0x47,
	0xf7, 0x16, 0x7b, 0xd4, 0x13, 0x54, 0x7f, 0x75, 0xb7, 0x5b, 0xbd, 0xa4, 0xdc, 0x79, 0xec, 0xd3,
	0xc1, 0x10, 0x25, 0x90, 0x81, 0xe1, 0xdf, 0x0d, 0xe7, 0x8d, 0x78, 0x99, 0x1b, 0x33, 0x30, 0x2e,
	0x6c, 0x39, 0x6f, 0xb4, 0xb0, 0xf9, 0x38, 0xff, 0x47, 0x3f, 0xff, 0xd3, 0x2c, 0x39, 0x01, 0xf9,
	0xbf, 0xb4, 0x88, 0xff, 0xd7, 0x71, 0x87, 0x7c, 0xfb, 0x60, 0x5f, 0x4f, 0xaf, 0x26, 0x3c, 0x3d,
	0x2f, 0x3c, 0x3d, 0xf4, 0xeb, 0x6a, 0x62, 0xdb, 0xc8, 0x8b, 0x54, 0xfd, 0xeb, 0x56, 0xec, 0xa6,
	0x08, 0xc1, 0xa1, 0x2f, 0x03, 0xd2, 0x8b, 0x92, 0x33, 0xe2, 0xc5, 0x57, 0x40, 0xc5, 0xba, 0x71,
	0xb0, 0xad, 0x29, 0x3c, 0xf4, 0x11, 0x19, 0x95, 0xbf, 0xb0, 0x4c, 0xad, 0x14, 0x9b, 0x23, 0x19,
	0xac, 0x52, 0xc7, 0xf8, 0xe8, 0x7d, 0x52, 0x92, 0xbf, 0xe7, 0x8c, 0x1d, 0x71, 0x6c, 0x8e, 0x71,
	0x54, 0x24, 0x66, 0x1a, 0x3b, 0x9a, 0xca, 0x85, 0xdf, 0x39, 0x10, 0xc0, 0xb5, 0xcc, 0x3c, 0xdf,
	0x75, 0x84, 0x37, 0xf1, 0xaa, 0xb8, 0x84, 0xb4, 0x36, 0x36, 0x69, 0x09, 0xd6, 0x63, 0x4b, 0x45,
	0x4b, 0xfd, 0xef, 0x0c, 0x39, 0xad, 0x5a, 0xea, 0xab, 0x4d, 0x2b, 0x60, 0xb6, 0xe5, 0x07, 0xbf,
	0x86, 0xd6, 0xfa, 0x71, 0xe2, 0x92, 0x06, 0x2f, 0x5b, 0xf6, 0x2f, 0x7c, 0x88, 0x0f, 0xfc, 0x25,
	0xcb, 0x1e, 0xf9, 0xb7, 0x2e, 0x7b, 0x84, 0xb7, 0x97, 0x0a, 0xc7, 0x9f, 0xc6, 0x3d, 0xb8, 0xd9,
	0xfd, 0x7b, 0x8a, 0x8c, 0x4b, 0x93, 0x5b, 0x76, 0x6d, 0xab, 0xb9, 0x43, 0x67, 0x48, 0x5e, 0x84,
	0x44, 0x68, 0x74, 0x89, 0x17, 0x9f, 0x13, 0x51, 0x13, 0x4f, 0x7e, 0x7d, 0xfe, 0x43, 0x93, 0x82,
	0xf4, 0x53, 0x92, 0x45, 0x7c, 0x10, 0xaf, 0x4e, 0x5f, 0x52, 0x35, 0xf4, 0xe0, 0x31, 0x5f, 0x1c,
	0x84, 0x17, 0x8d, 0x8b, 0xd1, 0x45, 0x52, 0x0c, 0x1d, 0xa0, 0x92, 0x46, 0x1d, 0x57, 0x07, 0xe9,
	0x08, 0x19, 0xc5, 0x2b, 0xce, 0xf2, 0xa7, 0x16, 0xa9, 0xa8, 0xfd, 0x6d, 0x8a, 0x94, 0xa3, 0x1b,
	0xa4, 0xfc, 0x93, 0xdb, 0xf4, 0x49, 0xf8, 0x59, 0x6e, 0xfe, 0x9c, 0xa7, 0x92, 0x3d, 0x34, 0x9c,
	0x75, 0xb7, 0xdf, 0xc7, 0xba, 0xe9, 0x03, 0x92, 0x81, 0x76, 0x74, 0xbc, 0x52, 0xbf, 0x17, 0x3f,
	0xa1, 0x55, 0x7e, 0x06, 0xdc, 0x72, 0x34, 0xe4, 0x86, 0xec, 0x16, 0xcf, 0x82, 0xd1, 0x1d, 0x4b,
	0xf1, 0xc8, 0x5c, 0xb9, 0x7d, 0x20, 0x5e, 0xf2, 0x87, 0x3f, 0x35, 0x2e, 0x50, 0xfb, 0xc3, 0x14,
	0x19, 0xe5, 0x1c, 0x62, 0x00, 0x4f, 0x13, 0x43, 0xef, 0x33, 0x84, 0x81, 0x83, 0xff, 0x0e, 0xc9,
	0xc2, 0x70, 0xe4, 0x6b, 0xed, 0x17, 0xfb, 0x8f, 0x9e, 0x33, 0xf3, 0x34, 0x58, 0xbd, 0x8f, 0x2a,
	0x94, 0x71, 0x15, 0xb5, 0xdf, 0xcf, 0x93, 0xfc, 0x0b, 0xe6, 0xfb, 0xc6, 0x06, 0xfb, 0x35, 0xc4,
	0x29, 0xe5, 0x78, 0x2a, 0x3f, 0xe8, 0x78, 0xea, 0xae, 0x28, 0x27, 0xf2, 0x4f, 0x0e, 0x9e, 0x54,
	0x27, 0xeb, 0x85, 0xbf, 0xd1, 0xb7, 0x96, 0x28, 0xbe, 0x4a, 0x56, 0x1a, 0xf6, 0x55, 0x32, 0x5e,
	0xef, 0xc5, 0xaf, 0x92, 0x3d, 0x85, 0x44, 0xc9, 0x09, 0xc2, 0x44, 0x09, 0xdf, 0x86, 0xca, 0x37,
	0x39, 0x69, 0xaf, 0x5b, 0x3d, 0x11, 0xfb, 0x92, 0xea, 0x83, 0x27, 0xfc, 0x94, 0x07, 0x5b, 0xf1,
	0x03, 0x5b, 0xec, 0x2b, 0x88, 0x2f, 0xc7, 0x70, 0xc3, 0xe5, 0x1f, 0xd8, 0x62, 0x5f, 0x61, 0x24,
	0x29, 0x9a, 0xe8, 0x2d, 0x52, 0x7c, 0x61, 0x6c, 0x0b, 0xbe, 0xf1, 0xa8, 0xb0, 0xd4, 0x32, 0xb6,
	0x75, 0xc9, 0x1b, 0x71, 0xc4, 0x82, 0xcc, 0x89, 0xe1, 0x41, 0xe6, 0x97, 0x84, 0x2c, 0x77, 0xfc,
	0x4d, 0xf1, 0x76, 0xe0, 0xe9, 0xde, 0x8f, 0x44, 0x47, 0xad, 0x38, 0x53, 0xd8, 0x6d, 0xbb, 0xe3,
	0x6f, 0xca, 0xd7, 0x06, 0x15, 0x71, 0x79, 0xd8, 0xe5, 0xb0, 0x00, 0x5f, 0x7f, 0x51, 0x0e, 0xbb,
	0x1c, 0x36, 0xe0, 0x8b, 0x92, 0x82, 0xff, 0xf8, 0x9d, 0x0a, 0xc4, 0xf2, 0x7f, 0x4e, 0x93, 0xdc,
	0xa2, 0x1b, 0x58, 0xeb, 0x83, 0x3f, 0x22, 0x71, 0x8b, 0xa4, 0x5f, 0x6e, 0x07, 0xca, 0x87, 0x1d,
	0xd3, 0xc1, 0x76, 0xff, 0xb9, 0x05, 0xbe, 0xa8, 0x1e, 0x97, 0xee, 0xad, 0x25, 0xf0, 0x9e, 0xb0,
	0xb9, 0xcf, 0xee, 0xaa, 0x9c, 0x5c, 0x66, 0xf6, 0x3b, 0xb9, 0x54, 0x16, 0xf3, 0xfd, 0x28, 0x0f,
	0xbc, 0x07, 0x8b, 0x39, 0xf9, 0x7d, 0x52, 0x0c, 0xa3, 0x17, 0x7a, 0x82, 0x8c, 0xe1, 0x0f, 0x7d,
	0xd5, 0x79, 0xed, 0xb8, 0x5b, 0x4e, 0xf9, 0x03, 0x5a, 0x26, 0xa3, 0x9c, 0xc4, 0xaf, 0x3a, 0x95,
	0x53, 0x11, 0x85, 0xdf, 0xb9, 0x2e, 0x8f, 0x50, 0x4a, 0xc6, 0xa5, 0x98, 0xa0, 0xa5, 0x23, 0xae,
	0x39, 0x66, 0xb3, 0x80, 0x95, 0x33, 0xf4, 0xa4, 0xe4, 0x7a, 0x61, 0xf0, 0x72, 0x50, 0xf9, 0x17,
	0xf9, 0xc9, 0x1d, 0x52, 0x52, 0xbe, 0x2f, 0x4f, 0x2b, 0xe4, 0x14, 0xfe, 0xd4, 0xf9, 0x6f, 0x65,
	0x1c, 0x67, 0xc9, 0xc9, 0x58, 0x8b, 0xe8, 0x28, 0x45, 0x2f, 0x90, 0xb3, 0xb1, 0x86, 0x17, 0xae,
	0x69, 0xad, 0xef, 0x2c, 0x1b, 0xbe, 0x5f, 0x1e, 0xa1, 0xe7, 0xc9, 0x99, 0x3e, 0x8d, 0xf7, 0x16,
	0xea, 0xe5, 0xf4, 0xe4, 0x0f, 0x53, 0x64, 0x3c, 0xfe, 0x71, 0xf9, 0xa8, 0x93, 0xe4, 0x2c, 0x9c,
	0x22, 0xe5, 0x78, 0xc3, 0x52, 0xbb, 0x9c, 0x4a, 0xb2, 0x37, 0x1c, 0x7c, 0xb1, 0xb3, 0x3c, 0x92,
	0x6c, 0x58, 0xe9, 0xe0, 0x57, 0x4a, 0xca, 0xe9, 0xa4, 0x9e, 0x05, 0xc3, 0xb2, 0xcb, 0x99, 0xc9,
	0xef, 0xc8, 0xd7, 0x4e, 0xe4, 0x22, 0x44, 0xbf, 0xf4, 0x2f, 0xe6, 0xca, 0x1f, 0xd0, 0xd3, 0xe4,
	0x84, 0x42, 0x6a, 0xb4, 0xda, 0xae, 0x17, 0x94, 0x53, 0x30, 0xef, 0x0a, 0x79, 0x65, 0xc7, 0x2f,
	0x8f, 0x4c, 0x3e, 0x09, 0x3f, 0x6a, 0x10, 0x3e, 0x51, 0xf4, 0x53, 0x79, 0xa2, 0x3c, 0x49, 0x2f,
	0x3d, 0x9f, 0x2b, 0xa7, 0xe0, 0x8f, 0xc5, 0xf9, 0x57, 0xe5, 0x91, 0xc9, 0xbf, 0x4e, 0x45, 0xd7,
	0x35, 0x60, 0xa0, 0xf2, 0x6f, 0x45, 0xe8, 0x0c, 0xa1, 0x21, 0x95, 0x1f, 0xba, 0xe9, 0x0d, 0x87,
	0x4f, 0x44, 0x92, 0xbe, 0xd4, 0x09, 0xca, 0x23, 0xf4, 0x24, 0x99, 0x08, 0x1b, 0x16, 0x18, 0x4c,
	0x11, 0x9f, 0x84, 0x18, 0x11, 0x58, 0x33, 0xb0, 0x8e, 0x21, 0x55, 0x39, 0x08, 0x01, 0x91, 0x2c,
	0xbd, 0x48, 0x2a, 0x7d, 0x1b, 0x41, 0x34, 0x37, 0xf9, 0x3f, 0x29, 0x52, 0x52, 0x4a, 0x8e, 0xd0,
	0xab, 0xf8, 0xa9, 0x8c, 0x9d, 0x92, 0x71, 0x49, 0x5c, 0xe9, 0xac, 0xb5, 0xac, 0x80, 0xdb, 0x8e,
	0xa4, 0xc9, 0x1a, 0x88, 0x48, 0x1a, 0xf9, 0xd8, 0x65, 0xa3, 0x24, 0xe2, 0xd8, 0x25, 0xf1, 0x95,
	0x61, 0x05, 0x2b, 0xcc, 0x31, 0xcb, 0x45, 0x95, 0x15, 0x28, 0x96, 0xb3, 0x51, 0x26, 0x30, 0x59,
	0xa1, 0xf2, 0xb0, 0xd4, 0x52, 0x2e, 0xc1, 0x62, 0x46, 0xa3, 0x7b, 0xc6, 0x1c, 0x78, 0xb0, 0xf2,
	0xa8, 0xaa, 0x79, 0xc1, 0x72, 0x2c, 0x7f, 0x93, 0x99, 0xe5, 0x31, 0x70, 0xa3, 0x90, 0x0a, 0xc6,
	0x32, 0xae, 0xf6, 0x25, 0x0d, 0x6e, 0x62, 0xb2, 0x41, 0x48, 0x74, 0xea, 0x27, 0x1e, 0xd5, 0x32,
	0xd5, 0xc7, 0xe7, 0x62, 0x40, 0x93, 0xf1, 0x2c, 0x37, 0x20, 0x41, 0x14, 0xef, 0x91, 0x94, 0x47,
	0xc0, 0x18, 0xa3, 0xf3, 0x4b, 0xce, 0x91, 0xb0, 0x02, 0x54, 0xc5, 0x2d, 0xd1, 0x09, 0x98, 0xe7,
	0x18, 0x76, 0x39, 0xa5, 0x10, 0xe7, 0xb7, 0x05, 0x71, 0x64, 0xf2, 0x3f, 0x53, 0x24, 0x2f, 0xa2,
	0x17, 0x60, 0x10, 0x7f, 0x2a, 0xaa, 0x2e, 0x92, 0x8a, 0x24, 0xca, 0x61, 0xc9, 0xc9, 0x2a, 0xa7,
	0xe8, 0x25, 0x72, 0xae, 0xa7, 0x35, 0x9c, 0x9b, 0x91, 0xbe, 0xc2, 0xcb, 0x62, 0xfa, 0xd3, 0xb0,
	0xb6, 0xbd, 0xc2, 0x86, 0x65, 0x33, 0xb3, 0x9c, 0x51, 0x45, 0xc5, 0x93, 0x47, 0x8a, 0xb3, 0xaa,
	0xa8, 0x6c, 0x95, 0x7a, 0x73, 0x00, 0x29, 0x3d, 0xa2, 0x5c, 0x6d, 0x7e, 0xf2, 0xb7, 0xc9, 0x78,
	0x3c, 0x12, 0xa1, 0xe7, 0xc8, 0xe9, 0x38, 0x45, 0x5f, 0x75, 0x80, 0x50, 0xfe, 0x00, 0x14, 0x25,
	0x9a, 0xe0, 0x27, 0x74, 0x92, 0xea, 0xd3, 0x26, 0x31, 0x04, 0xc1, 0x25, 0xd1, 0x86, 0x96, 0x91,
	0x9e, 0xfc, 0x94, 0x94, 0x94, 0xcd, 0x92, 0x12, 0x92, 0x5b, 0x75, 0xd0, 0x40, 0x3f, 0x00, 0x4c,
	0x11, 0x4d, 0x42, 0x0d, 0xc2, 0x38, 0x27, 0x89, 0xd1, 0x8f, 0xcc, 0x2c, 0xfd, 0xd3, 0xcf, 0x2e,
	0xa7, 0x7e, 0xf2, 0xb3, 0xcb, 0xa9, 0x7f, 0xfb, 0xd9, 0xe5, 0xd4, 0x8f, 0x7e, 0x7e, 0xf9, 0x83,
	0x9f, 0xfc, 0xfc, 0xf2, 0x07, 0x3f, 0xfd, 0xf9, 0xe5, 0x0f, 0x7e, 0xe3, 0xa1, 0xfa, 0x1f, 0x19,
	0x59, 0xfe, 0x1b, 0xef, 0x8e, 0x08, 0xd5, 0xf1, 0x3f, 0x2e, 0xf2, 0x58, 0xfb, 0x0e, 0xdf, 0xb0,
	0x6f, 0x6d, 0xb8, 0x1b, 0xee, 0x74, 0x7b, 0x8d, 0xff, 0x5a, 0xcb, 0x61, 0xf3, 0xfd, 0xff, 0x0d,
	0x00, 0x00, 0xff, 0xff, 0x33, 0x7e, 0x4e, 0x12, 0x22, 0x69, 0x00, 0x00,
}

func (m *ErrInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserLoginLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserLoginLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserLoginLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UserAgent) > 0 {
		i -= len(m.UserAgent)
		copy(dAtA[i:], m.UserAgent)
		i = encodeVarintShared(dAtA, i, uint64(len(m.UserAgent)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintShared(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Uid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserActivationCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserActivationCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserActivationCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndTime != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x48
	}
	if m.BeginTime != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.BeginTime))
		i--
		dAtA[i] = 0x40
	}
	if m.OpTime != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.OpTime))
		i--
		dAtA[i] = 0x38
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OpName != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.OpName))
		i--
		dAtA[i] = 0x20
	}
	if m.RefUid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefUid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Status != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.LoginErrNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.LoginErrNum))
		i--
		dAtA[i] = 0x78
	}
	if len(m.ActivationCode) > 0 {
		i -= len(m.ActivationCode)
		copy(dAtA[i:], m.ActivationCode)
		i = encodeVarintShared(dAtA, i, uint64(len(m.ActivationCode)))
		i--
		dAtA[i] = 0x72
	}
	if m.InvitedById != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.InvitedById))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Welcome) > 0 {
		i -= len(m.Welcome)
		copy(dAtA[i:], m.Welcome)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Welcome)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.TwoFA) > 0 {
		i -= len(m.TwoFA)
		copy(dAtA[i:], m.TwoFA)
		i = encodeVarintShared(dAtA, i, uint64(len(m.TwoFA)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x42
	}
	if m.Nonce != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Mobile) > 0 {
		i -= len(m.Mobile)
		copy(dAtA[i:], m.Mobile)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Mobile)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CountryCode) > 0 {
		i -= len(m.CountryCode)
		copy(dAtA[i:], m.CountryCode)
		i = encodeVarintShared(dAtA, i, uint64(len(m.CountryCode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintShared(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccountId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApiKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApiKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Status != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Remark) > 0 {
		i -= len(m.Remark)
		copy(dAtA[i:], m.Remark)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Remark)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.IpLimit) > 0 {
		i -= len(m.IpLimit)
		copy(dAtA[i:], m.IpLimit)
		i = encodeVarintShared(dAtA, i, uint64(len(m.IpLimit)))
		i--
		dAtA[i] = 0x42
	}
	if m.UserId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintShared(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintShared(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.AccessType != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccessType))
		i--
		dAtA[i] = 0x20
	}
	if m.WalletId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.WalletId))
		i--
		dAtA[i] = 0x18
	}
	if m.AccountId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CountryCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountryCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountryCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x28
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Remark) > 0 {
		i -= len(m.Remark)
		copy(dAtA[i:], m.Remark)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Remark)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x38
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x18
	}
	if m.RoleId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RoleId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthAssign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthAssign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthAssign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.RoleId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RoleId))
		i--
		dAtA[i] = 0x20
	}
	if m.RefUid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefUid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.LoginErrNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.LoginErrNum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Admin {
		i--
		if m.Admin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Roles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Perms) > 0 {
		for iNdEx := len(m.Perms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Perms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.TwoFA) > 0 {
		i -= len(m.TwoFA)
		copy(dAtA[i:], m.TwoFA)
		i = encodeVarintShared(dAtA, i, uint64(len(m.TwoFA)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CountryCode) > 0 {
		i -= len(m.CountryCode)
		copy(dAtA[i:], m.CountryCode)
		i = encodeVarintShared(dAtA, i, uint64(len(m.CountryCode)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Mobile) > 0 {
		i -= len(m.Mobile)
		copy(dAtA[i:], m.Mobile)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Mobile)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.EMail) > 0 {
		i -= len(m.EMail)
		copy(dAtA[i:], m.EMail)
		i = encodeVarintShared(dAtA, i, uint64(len(m.EMail)))
		i--
		dAtA[i] = 0x62
	}
	if m.Nonce != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Pass) > 0 {
		i -= len(m.Pass)
		copy(dAtA[i:], m.Pass)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Pass)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintShared(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ActivationCode) > 0 {
		i -= len(m.ActivationCode)
		copy(dAtA[i:], m.ActivationCode)
		i = encodeVarintShared(dAtA, i, uint64(len(m.ActivationCode)))
		i--
		dAtA[i] = 0x42
	}
	if m.InvitationRefUid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.InvitationRefUid))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Welcome) > 0 {
		i -= len(m.Welcome)
		copy(dAtA[i:], m.Welcome)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Welcome)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AccountDescription) > 0 {
		i -= len(m.AccountDescription)
		copy(dAtA[i:], m.AccountDescription)
		i = encodeVarintShared(dAtA, i, uint64(len(m.AccountDescription)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintShared(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccountId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RespPerm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespPerm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RespPerm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Admin {
		i--
		if m.Admin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Roles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Perms) > 0 {
		for iNdEx := len(m.Perms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Perms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SessionAuthItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionAuthItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionAuthItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionRoleItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionRoleItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionRoleItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Perms) > 0 {
		for iNdEx := len(m.Perms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Perms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Roles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Welcome) > 0 {
		i -= len(m.Welcome)
		copy(dAtA[i:], m.Welcome)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Welcome)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.TwoFA) > 0 {
		i -= len(m.TwoFA)
		copy(dAtA[i:], m.TwoFA)
		i = encodeVarintShared(dAtA, i, uint64(len(m.TwoFA)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x62
	}
	if m.Admin {
		i--
		if m.Admin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Mobile) > 0 {
		i -= len(m.Mobile)
		copy(dAtA[i:], m.Mobile)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Mobile)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CountryCode) > 0 {
		i -= len(m.CountryCode)
		copy(dAtA[i:], m.CountryCode)
		i = encodeVarintShared(dAtA, i, uint64(len(m.CountryCode)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.EMail) > 0 {
		i -= len(m.EMail)
		copy(dAtA[i:], m.EMail)
		i = encodeVarintShared(dAtA, i, uint64(len(m.EMail)))
		i--
		dAtA[i] = 0x42
	}
	if m.Nonce != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x38
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintShared(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x32
	}
	if m.InvitationRefUid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.InvitationRefUid))
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintShared(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccountId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsAdmin {
		i--
		if m.IsAdmin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Perms) > 0 {
		for iNdEx := len(m.Perms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Perms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Roles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CacheApiKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheApiKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheApiKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IpLimit) > 0 {
		i -= len(m.IpLimit)
		copy(dAtA[i:], m.IpLimit)
		i = encodeVarintShared(dAtA, i, uint64(len(m.IpLimit)))
		i--
		dAtA[i] = 0x42
	}
	if m.UserId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintShared(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintShared(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.AccessType != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccessType))
		i--
		dAtA[i] = 0x20
	}
	if m.WalletId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.WalletId))
		i--
		dAtA[i] = 0x18
	}
	if m.AccountId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x38
	}
	if m.BlockTime != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x30
	}
	if m.BlockNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalletInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.WType != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.WType))
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.MonitorStatus != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.MonitorStatus))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Type != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x78
	}
	if m.Balance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i--
		dAtA[i] = 0x71
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x68
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintShared(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x4a
	}
	if m.AddressIndex != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AddressIndex))
		i--
		dAtA[i] = 0x40
	}
	if len(m.HdPath) > 0 {
		i -= len(m.HdPath)
		copy(dAtA[i:], m.HdPath)
		i = encodeVarintShared(dAtA, i, uint64(len(m.HdPath)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x32
	}
	if m.CoinId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CoinId))
		i--
		dAtA[i] = 0x28
	}
	if m.WalletId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.WalletId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.AccountId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CoinInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if len(m.FeeSymbol) > 0 {
		i -= len(m.FeeSymbol)
		copy(dAtA[i:], m.FeeSymbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.FeeSymbol)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.FeeRefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.FeeRefCid))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.FeeLimitCount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FeeLimitCount))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x91
	}
	if m.FeeCount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FeeCount))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x89
	}
	if m.FastFeeUnitPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FastFeeUnitPrice))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x81
	}
	if m.MiddleFeeUnitPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MiddleFeeUnitPrice))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf9
	}
	if m.SlowFeeUnitPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SlowFeeUnitPrice))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf1
	}
	if m.CollectAmountMin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CollectAmountMin))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb1
	}
	if m.HdCoinType != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.HdCoinType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.RpcUrl) > 0 {
		i -= len(m.RpcUrl)
		copy(dAtA[i:], m.RpcUrl)
		i = encodeVarintShared(dAtA, i, uint64(len(m.RpcUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RequestMemo {
		i--
		if m.RequestMemo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.DustThreshold != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.DustThreshold))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ConfirmingThreshold != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.ConfirmingThreshold))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.IsCollect {
		i--
		if m.IsCollect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.IsUtxo {
		i--
		if m.IsUtxo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ExplorerUrl) > 0 {
		i -= len(m.ExplorerUrl)
		copy(dAtA[i:], m.ExplorerUrl)
		i = encodeVarintShared(dAtA, i, uint64(len(m.ExplorerUrl)))
		i--
		dAtA[i] = 0x5a
	}
	if m.CanWithdraw {
		i--
		if m.CanWithdraw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.CanDeposit {
		i--
		if m.CanDeposit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ValidDecimal != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.ValidDecimal))
		i--
		dAtA[i] = 0x38
	}
	if m.OriginalDecimal != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.OriginalDecimal))
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinAddr) > 0 {
		i -= len(m.CoinAddr)
		copy(dAtA[i:], m.CoinAddr)
		i = encodeVarintShared(dAtA, i, uint64(len(m.CoinAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalletHdIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletHdIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletHdIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.AddressIndexLast != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AddressIndexLast))
		i--
		dAtA[i] = 0x20
	}
	if m.CoinId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CoinId))
		i--
		dAtA[i] = 0x18
	}
	if m.AccountId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalletCoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletCoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletCoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.CanNewAddress {
		i--
		if m.CanNewAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x72
	}
	if m.CanWithdraw {
		i--
		if m.CanWithdraw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.CanDeposit {
		i--
		if m.CanDeposit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.FeeSymbol) > 0 {
		i -= len(m.FeeSymbol)
		copy(dAtA[i:], m.FeeSymbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.FeeSymbol)))
		i--
		dAtA[i] = 0x5a
	}
	if m.FeeRefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.FeeRefCid))
		i--
		dAtA[i] = 0x50
	}
	if m.PlatformFee != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PlatformFee))))
		i--
		dAtA[i] = 0x49
	}
	if m.CanPlatformFee {
		i--
		if m.CanPlatformFee {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.FixedFee != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FixedFee))))
		i--
		dAtA[i] = 0x39
	}
	if m.CanFixedFee {
		i--
		if m.CanFixedFee {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x78
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x70
	}
	if m.Balance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalletAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Freeze != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Freeze))))
		i--
		dAtA[i] = 0x39
	}
	if m.Balance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalletAssetSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletAssetSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletAssetSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnapshotAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.SnapshotAt))
		i--
		dAtA[i] = 0x70
	}
	if m.AssetUpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.AssetUpdateAt))
		i--
		dAtA[i] = 0x40
	}
	if m.Freeze != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Freeze))))
		i--
		dAtA[i] = 0x39
	}
	if m.Balance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.AmountPerDay != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AmountPerDay))))
		i--
		dAtA[i] = 0x39
	}
	if m.AmountPerHour != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AmountPerHour))))
		i--
		dAtA[i] = 0x31
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x29
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Bill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.InnerTxid) > 0 {
		i -= len(m.InnerTxid)
		copy(dAtA[i:], m.InnerTxid)
		i = encodeVarintShared(dAtA, i, uint64(len(m.InnerTxid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.FeeSymbol) > 0 {
		i -= len(m.FeeSymbol)
		copy(dAtA[i:], m.FeeSymbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.FeeSymbol)))
		i--
		dAtA[i] = 0x72
	}
	if m.FeeRefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.FeeRefCid))
		i--
		dAtA[i] = 0x68
	}
	if m.ResultAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ResultAmount))))
		i--
		dAtA[i] = 0x61
	}
	if m.ChangeAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ChangeAmount))))
		i--
		dAtA[i] = 0x59
	}
	if m.RefCtid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCtid))
		i--
		dAtA[i] = 0x48
	}
	if m.RelayId != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RelayId))
		i--
		dAtA[i] = 0x40
	}
	if m.BillType != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.BillType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CoinTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.NeedConfirmedNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.NeedConfirmedNum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.ConfirmedNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.ConfirmedNum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.IsGenerateBill {
		i--
		if m.IsGenerateBill {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.ChainRefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.ChainRefCid))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.NeedApproveNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.NeedApproveNum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.ApproveNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.ApproveNum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if len(m.FeeSymbol) > 0 {
		i -= len(m.FeeSymbol)
		copy(dAtA[i:], m.FeeSymbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.FeeSymbol)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.FeeRefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.FeeRefCid))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.PlatformFee != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PlatformFee))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x81
	}
	if m.FeeAct != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FeeAct))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf9
	}
	if m.Fee != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fee))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf1
	}
	if m.FeeLimit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FeeLimit))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe9
	}
	if m.FeeRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FeeRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe1
	}
	if m.OpRefUid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.OpRefUid))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.Index != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Side != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Side))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.InnerTxid) > 0 {
		i -= len(m.InnerTxid)
		copy(dAtA[i:], m.InnerTxid)
		i = encodeVarintShared(dAtA, i, uint64(len(m.InnerTxid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Type != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintShared(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x7a
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x71
	}
	if len(m.Remark) > 0 {
		i -= len(m.Remark)
		copy(dAtA[i:], m.Remark)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Remark)))
		i--
		dAtA[i] = 0x6a
	}
	if m.OutN != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.OutN))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintShared(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintShared(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0x42
	}
	if m.BlockTime != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x38
	}
	if m.BlockNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TxAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if len(m.RefInnerTxid) > 0 {
		i -= len(m.RefInnerTxid)
		copy(dAtA[i:], m.RefInnerTxid)
		i = encodeVarintShared(dAtA, i, uint64(len(m.RefInnerTxid)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.NeedNextAct {
		i--
		if m.NeedNextAct {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x62
	}
	if m.Result != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ActName) > 0 {
		i -= len(m.ActName)
		copy(dAtA[i:], m.ActName)
		i = encodeVarintShared(dAtA, i, uint64(len(m.ActName)))
		i--
		dAtA[i] = 0x52
	}
	if m.RefTxState != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefTxState))
		i--
		dAtA[i] = 0x48
	}
	if m.RefUid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefUid))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.RetryInv != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RetryInv))
		i--
		dAtA[i] = 0x58
	}
	if m.ConfirmingCallbackRetryNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.ConfirmingCallbackRetryNum))
		i--
		dAtA[i] = 0x50
	}
	if m.TransferCallbackRetryNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.TransferCallbackRetryNum))
		i--
		dAtA[i] = 0x48
	}
	if m.WithdrawCallbackRetryNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.WithdrawCallbackRetryNum))
		i--
		dAtA[i] = 0x40
	}
	if m.IsContainConfirmNum {
		i--
		if m.IsContainConfirmNum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.TransferCallbackUrl) > 0 {
		i -= len(m.TransferCallbackUrl)
		copy(dAtA[i:], m.TransferCallbackUrl)
		i = encodeVarintShared(dAtA, i, uint64(len(m.TransferCallbackUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.WithdrawCallbackUrl) > 0 {
		i -= len(m.WithdrawCallbackUrl)
		copy(dAtA[i:], m.WithdrawCallbackUrl)
		i = encodeVarintShared(dAtA, i, uint64(len(m.WithdrawCallbackUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ApproveAll {
		i--
		if m.ApproveAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CoinWithdrawQuota) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinWithdrawQuota) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinWithdrawQuota) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ApprovedPerson != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.ApprovedPerson))
		i--
		dAtA[i] = 0x48
	}
	if m.QuotaPerDay != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QuotaPerDay))))
		i--
		dAtA[i] = 0x41
	}
	if m.QuotaPerHour != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QuotaPerHour))))
		i--
		dAtA[i] = 0x39
	}
	if m.QuotaPerTx != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QuotaPerTx))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CoinWithdrawWhitelist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinWithdrawWhitelist) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinWithdrawWhitelist) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Whitelist) > 0 {
		for iNdEx := len(m.Whitelist) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Whitelist[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Quota) > 0 {
		for iNdEx := len(m.Quota) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Quota[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Setting != nil {
		{
			size, err := m.Setting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShared(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WalletCoinDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletCoinDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletCoinDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asset != nil {
		{
			size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShared(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Coin != nil {
		{
			size, err := m.Coin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShared(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Detail != nil {
		{
			size, err := m.Detail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShared(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WalletDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShared(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Detail != nil {
		{
			size, err := m.Detail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShared(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if len(m.Commnet) > 0 {
		i -= len(m.Commnet)
		copy(dAtA[i:], m.Commnet)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Commnet)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.PushStatus != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.PushStatus))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.RetryInv != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RetryInv))
		i--
		dAtA[i] = 0x78
	}
	if m.MaxReqNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.MaxReqNum))
		i--
		dAtA[i] = 0x70
	}
	if m.ReqNum != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.ReqNum))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Type != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x50
	}
	if m.RefCtid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCtid))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefCid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefCid))
		i--
		dAtA[i] = 0x20
	}
	if m.RefWid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefWid))
		i--
		dAtA[i] = 0x18
	}
	if m.RefAid != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.RefAid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Notify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.CreateAt != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Txt) > 0 {
		i -= len(m.Txt)
		copy(dAtA[i:], m.Txt)
		i = encodeVarintShared(dAtA, i, uint64(len(m.Txt)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShared(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintShared(dAtA []byte, offset int, v uint64) int {
	offset -= sovShared(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ErrInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.Code != 0 {
		n += 1 + sovShared(uint64(m.Code))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	return n
}

func (m *UserLoginLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.Uid != 0 {
		n += 1 + sovShared(uint64(m.Uid))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	return n
}

func (m *AccountInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovShared(uint64(m.State))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *UserActivationCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefUid != 0 {
		n += 1 + sovShared(uint64(m.RefUid))
	}
	if m.OpName != 0 {
		n += 1 + sovShared(uint64(m.OpName))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovShared(uint64(m.State))
	}
	if m.OpTime != 0 {
		n += 1 + sovShared(uint64(m.OpTime))
	}
	if m.BeginTime != 0 {
		n += 1 + sovShared(uint64(m.BeginTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovShared(uint64(m.EndTime))
	}
	return n
}

func (m *UserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.AccountId != 0 {
		n += 1 + sovShared(uint64(m.AccountId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Mobile)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovShared(uint64(m.Nonce))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.TwoFA)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Welcome)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.InvitedById != 0 {
		n += 1 + sovShared(uint64(m.InvitedById))
	}
	l = len(m.ActivationCode)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.LoginErrNum != 0 {
		n += 1 + sovShared(uint64(m.LoginErrNum))
	}
	if m.Status != 0 {
		n += 2 + sovShared(uint64(m.Status))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *ApiKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.AccountId != 0 {
		n += 1 + sovShared(uint64(m.AccountId))
	}
	if m.WalletId != 0 {
		n += 1 + sovShared(uint64(m.WalletId))
	}
	if m.AccessType != 0 {
		n += 1 + sovShared(uint64(m.AccessType))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovShared(uint64(m.UserId))
	}
	l = len(m.IpLimit)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovShared(uint64(m.Status))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *CountryCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	return n
}

func (m *RoleItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *AuthItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *RoleAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RoleId != 0 {
		n += 1 + sovShared(uint64(m.RoleId))
	}
	if m.AuthId != 0 {
		n += 1 + sovShared(uint64(m.AuthId))
	}
	return n
}

func (m *AuthAssign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefUid != 0 {
		n += 1 + sovShared(uint64(m.RefUid))
	}
	if m.RoleId != 0 {
		n += 1 + sovShared(uint64(m.RoleId))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	return n
}

func (m *UserData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.AccountId != 0 {
		n += 1 + sovShared(uint64(m.AccountId))
	}
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.AccountDescription)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Welcome)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovShared(uint64(m.Status))
	}
	if m.InvitationRefUid != 0 {
		n += 1 + sovShared(uint64(m.InvitationRefUid))
	}
	l = len(m.ActivationCode)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Pass)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovShared(uint64(m.Nonce))
	}
	l = len(m.EMail)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Mobile)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.TwoFA)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if len(m.Perms) > 0 {
		for _, e := range m.Perms {
			l = e.Size()
			n += 2 + l + sovShared(uint64(l))
		}
	}
	if len(m.Roles) > 0 {
		for _, e := range m.Roles {
			l = e.Size()
			n += 2 + l + sovShared(uint64(l))
		}
	}
	if m.Admin {
		n += 3
	}
	l = len(m.Lang)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.LoginErrNum != 0 {
		n += 2 + sovShared(uint64(m.LoginErrNum))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *RespPerm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Perms) > 0 {
		for _, e := range m.Perms {
			l = e.Size()
			n += 1 + l + sovShared(uint64(l))
		}
	}
	if len(m.Roles) > 0 {
		for _, e := range m.Roles {
			l = e.Size()
			n += 1 + l + sovShared(uint64(l))
		}
	}
	if m.Admin {
		n += 2
	}
	return n
}

func (m *SessionAuthItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	return n
}

func (m *SessionRoleItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	return n
}

func (m *SessionUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.AccountId != 0 {
		n += 1 + sovShared(uint64(m.AccountId))
	}
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovShared(uint64(m.State))
	}
	if m.InvitationRefUid != 0 {
		n += 1 + sovShared(uint64(m.InvitationRefUid))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovShared(uint64(m.Nonce))
	}
	l = len(m.EMail)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Mobile)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Admin {
		n += 2
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.TwoFA)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Welcome)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, e := range m.Roles {
			l = e.Size()
			n += 2 + l + sovShared(uint64(l))
		}
	}
	if len(m.Perms) > 0 {
		for _, e := range m.Perms {
			l = e.Size()
			n += 2 + l + sovShared(uint64(l))
		}
	}
	return n
}

func (m *SessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, e := range m.Roles {
			l = e.Size()
			n += 1 + l + sovShared(uint64(l))
		}
	}
	if len(m.Perms) > 0 {
		for _, e := range m.Perms {
			l = e.Size()
			n += 1 + l + sovShared(uint64(l))
		}
	}
	if m.IsAdmin {
		n += 2
	}
	return n
}

func (m *CacheApiKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.AccountId != 0 {
		n += 1 + sovShared(uint64(m.AccountId))
	}
	if m.WalletId != 0 {
		n += 1 + sovShared(uint64(m.WalletId))
	}
	if m.AccessType != 0 {
		n += 1 + sovShared(uint64(m.AccessType))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovShared(uint64(m.UserId))
	}
	l = len(m.IpLimit)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	return n
}

func (m *BlockInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sovShared(uint64(m.BlockNum))
	}
	if m.BlockTime != 0 {
		n += 1 + sovShared(uint64(m.BlockTime))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *WalletInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovShared(uint64(m.State))
	}
	if m.WType != 0 {
		n += 1 + sovShared(uint64(m.WType))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *AddressInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.AccountId != 0 {
		n += 1 + sovShared(uint64(m.AccountId))
	}
	if m.UserId != 0 {
		n += 1 + sovShared(uint64(m.UserId))
	}
	if m.WalletId != 0 {
		n += 1 + sovShared(uint64(m.WalletId))
	}
	if m.CoinId != 0 {
		n += 1 + sovShared(uint64(m.CoinId))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.HdPath)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.AddressIndex != 0 {
		n += 1 + sovShared(uint64(m.AddressIndex))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovShared(uint64(m.State))
	}
	if m.Balance != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 1 + sovShared(uint64(m.Type))
	}
	if m.MonitorStatus != 0 {
		n += 2 + sovShared(uint64(m.MonitorStatus))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *CoinInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.CoinAddr)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.OriginalDecimal != 0 {
		n += 1 + sovShared(uint64(m.OriginalDecimal))
	}
	if m.ValidDecimal != 0 {
		n += 1 + sovShared(uint64(m.ValidDecimal))
	}
	if m.IsActive {
		n += 2
	}
	if m.CanDeposit {
		n += 2
	}
	if m.CanWithdraw {
		n += 2
	}
	l = len(m.ExplorerUrl)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.IsUtxo {
		n += 2
	}
	if m.IsCollect {
		n += 2
	}
	if m.ConfirmingThreshold != 0 {
		n += 2 + sovShared(uint64(m.ConfirmingThreshold))
	}
	if m.DustThreshold != 0 {
		n += 2 + sovShared(uint64(m.DustThreshold))
	}
	if m.RequestMemo {
		n += 3
	}
	l = len(m.RpcUrl)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.HdCoinType != 0 {
		n += 2 + sovShared(uint64(m.HdCoinType))
	}
	if m.CollectAmountMin != 0 {
		n += 10
	}
	if m.SlowFeeUnitPrice != 0 {
		n += 10
	}
	if m.MiddleFeeUnitPrice != 0 {
		n += 10
	}
	if m.FastFeeUnitPrice != 0 {
		n += 10
	}
	if m.FeeCount != 0 {
		n += 10
	}
	if m.FeeLimitCount != 0 {
		n += 10
	}
	if m.FeeRefCid != 0 {
		n += 2 + sovShared(uint64(m.FeeRefCid))
	}
	l = len(m.FeeSymbol)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *WalletHdIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.AccountId != 0 {
		n += 1 + sovShared(uint64(m.AccountId))
	}
	if m.CoinId != 0 {
		n += 1 + sovShared(uint64(m.CoinId))
	}
	if m.AddressIndexLast != 0 {
		n += 1 + sovShared(uint64(m.AddressIndexLast))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *WalletCoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.CanFixedFee {
		n += 2
	}
	if m.FixedFee != 0 {
		n += 9
	}
	if m.CanPlatformFee {
		n += 2
	}
	if m.PlatformFee != 0 {
		n += 9
	}
	if m.FeeRefCid != 0 {
		n += 1 + sovShared(uint64(m.FeeRefCid))
	}
	l = len(m.FeeSymbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.CanDeposit {
		n += 2
	}
	if m.CanWithdraw {
		n += 2
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.CanNewAddress {
		n += 2
	}
	if m.State != 0 {
		n += 2 + sovShared(uint64(m.State))
	}
	if m.IsActive {
		n += 3
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *AddressAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Balance != 0 {
		n += 9
	}
	if m.CreateAt != 0 {
		n += 1 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *WalletAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Balance != 0 {
		n += 9
	}
	if m.Freeze != 0 {
		n += 9
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *WalletAssetSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Balance != 0 {
		n += 9
	}
	if m.Freeze != 0 {
		n += 9
	}
	if m.AssetUpdateAt != 0 {
		n += 1 + sovShared(uint64(m.AssetUpdateAt))
	}
	if m.SnapshotAt != 0 {
		n += 1 + sovShared(uint64(m.SnapshotAt))
	}
	return n
}

func (m *WithdrawStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.AmountPerHour != 0 {
		n += 9
	}
	if m.AmountPerDay != 0 {
		n += 9
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *Bill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.BillType != 0 {
		n += 1 + sovShared(uint64(m.BillType))
	}
	if m.RelayId != 0 {
		n += 1 + sovShared(uint64(m.RelayId))
	}
	if m.RefCtid != 0 {
		n += 1 + sovShared(uint64(m.RefCtid))
	}
	if m.ChangeAmount != 0 {
		n += 9
	}
	if m.ResultAmount != 0 {
		n += 9
	}
	if m.FeeRefCid != 0 {
		n += 1 + sovShared(uint64(m.FeeRefCid))
	}
	l = len(m.FeeSymbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.InnerTxid)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *CoinTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sovShared(uint64(m.BlockNum))
	}
	if m.BlockTime != 0 {
		n += 1 + sovShared(uint64(m.BlockTime))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.OutN != 0 {
		n += 1 + sovShared(uint64(m.OutN))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Amount != 0 {
		n += 9
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.Type != 0 {
		n += 2 + sovShared(uint64(m.Type))
	}
	l = len(m.InnerTxid)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.Side != 0 {
		n += 2 + sovShared(uint64(m.Side))
	}
	if m.Index != 0 {
		n += 2 + sovShared(uint64(m.Index))
	}
	if m.OpRefUid != 0 {
		n += 2 + sovShared(uint64(m.OpRefUid))
	}
	if m.FeeRate != 0 {
		n += 10
	}
	if m.FeeLimit != 0 {
		n += 10
	}
	if m.Fee != 0 {
		n += 10
	}
	if m.FeeAct != 0 {
		n += 10
	}
	if m.PlatformFee != 0 {
		n += 10
	}
	if m.FeeRefCid != 0 {
		n += 2 + sovShared(uint64(m.FeeRefCid))
	}
	l = len(m.FeeSymbol)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.ApproveNum != 0 {
		n += 2 + sovShared(uint64(m.ApproveNum))
	}
	if m.NeedApproveNum != 0 {
		n += 2 + sovShared(uint64(m.NeedApproveNum))
	}
	if m.ChainRefCid != 0 {
		n += 2 + sovShared(uint64(m.ChainRefCid))
	}
	if m.IsGenerateBill {
		n += 3
	}
	if m.State != 0 {
		n += 2 + sovShared(uint64(m.State))
	}
	if m.ConfirmedNum != 0 {
		n += 2 + sovShared(uint64(m.ConfirmedNum))
	}
	if m.NeedConfirmedNum != 0 {
		n += 2 + sovShared(uint64(m.NeedConfirmedNum))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *TxAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.RefUid != 0 {
		n += 1 + sovShared(uint64(m.RefUid))
	}
	if m.RefTxState != 0 {
		n += 1 + sovShared(uint64(m.RefTxState))
	}
	l = len(m.ActName)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovShared(uint64(m.Result))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.NeedNextAct {
		n += 2
	}
	l = len(m.RefInnerTxid)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	return n
}

func (m *WithdrawSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.ApproveAll {
		n += 2
	}
	l = len(m.WithdrawCallbackUrl)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.TransferCallbackUrl)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.IsContainConfirmNum {
		n += 2
	}
	if m.WithdrawCallbackRetryNum != 0 {
		n += 1 + sovShared(uint64(m.WithdrawCallbackRetryNum))
	}
	if m.TransferCallbackRetryNum != 0 {
		n += 1 + sovShared(uint64(m.TransferCallbackRetryNum))
	}
	if m.ConfirmingCallbackRetryNum != 0 {
		n += 1 + sovShared(uint64(m.ConfirmingCallbackRetryNum))
	}
	if m.RetryInv != 0 {
		n += 1 + sovShared(uint64(m.RetryInv))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *CoinWithdrawQuota) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.QuotaPerTx != 0 {
		n += 9
	}
	if m.QuotaPerHour != 0 {
		n += 9
	}
	if m.QuotaPerDay != 0 {
		n += 9
	}
	if m.ApprovedPerson != 0 {
		n += 1 + sovShared(uint64(m.ApprovedPerson))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *CoinWithdrawWhitelist) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovShared(uint64(m.State))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *WithdrawPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Setting != nil {
		l = m.Setting.Size()
		n += 1 + l + sovShared(uint64(l))
	}
	if len(m.Quota) > 0 {
		for _, e := range m.Quota {
			l = e.Size()
			n += 1 + l + sovShared(uint64(l))
		}
	}
	if len(m.Whitelist) > 0 {
		for _, e := range m.Whitelist {
			l = e.Size()
			n += 1 + l + sovShared(uint64(l))
		}
	}
	return n
}

func (m *WalletCoinDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Coin != nil {
		l = m.Coin.Size()
		n += 1 + l + sovShared(uint64(l))
	}
	if m.Asset != nil {
		l = m.Asset.Size()
		n += 1 + l + sovShared(uint64(l))
	}
	return n
}

func (m *WalletDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovShared(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovShared(uint64(l))
		}
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	if m.RefAid != 0 {
		n += 1 + sovShared(uint64(m.RefAid))
	}
	if m.RefWid != 0 {
		n += 1 + sovShared(uint64(m.RefWid))
	}
	if m.RefCid != 0 {
		n += 1 + sovShared(uint64(m.RefCid))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.RefCtid != 0 {
		n += 1 + sovShared(uint64(m.RefCtid))
	}
	if m.Type != 0 {
		n += 1 + sovShared(uint64(m.Type))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.ReqNum != 0 {
		n += 1 + sovShared(uint64(m.ReqNum))
	}
	if m.MaxReqNum != 0 {
		n += 1 + sovShared(uint64(m.MaxReqNum))
	}
	if m.RetryInv != 0 {
		n += 1 + sovShared(uint64(m.RetryInv))
	}
	if m.PushStatus != 0 {
		n += 2 + sovShared(uint64(m.PushStatus))
	}
	l = len(m.Commnet)
	if l > 0 {
		n += 2 + l + sovShared(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func (m *Notify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShared(uint64(m.Id))
	}
	l = len(m.Txt)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovShared(uint64(m.State))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovShared(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 2 + sovShared(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 2 + sovShared(uint64(m.UpdateAt))
	}
	return n
}

func sovShared(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShared(x uint64) (n int) {
	return sovShared(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ErrInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserLoginLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserLoginLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserLoginLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserActivationCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserActivationCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserActivationCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefUid", wireType)
			}
			m.RefUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpName", wireType)
			}
			m.OpName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpName |= ACodeOpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ACodeStateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpTime", wireType)
			}
			m.OpTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTime", wireType)
			}
			m.BeginTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mobile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mobile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwoFA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TwoFA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Welcome", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Welcome = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitedById", wireType)
			}
			m.InvitedById = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvitedById |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginErrNum", wireType)
			}
			m.LoginErrNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginErrNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApiKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
			}
			m.WalletId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalletId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessType", wireType)
			}
			m.AccessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountryCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountryCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountryCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			m.RoleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthAssign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthAssign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthAssign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefUid", wireType)
			}
			m.RefUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			m.RoleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Welcome", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Welcome = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitationRefUid", wireType)
			}
			m.InvitationRefUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvitationRefUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EMail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EMail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mobile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mobile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwoFA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TwoFA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Perms = append(m.Perms, &AuthItem{})
			if err := m.Perms[len(m.Perms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, &RoleItem{})
			if err := m.Roles[len(m.Roles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginErrNum", wireType)
			}
			m.LoginErrNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginErrNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RespPerm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RespPerm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RespPerm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Perms = append(m.Perms, &AuthItem{})
			if err := m.Perms[len(m.Perms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, &RoleItem{})
			if err := m.Roles[len(m.Roles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionAuthItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionAuthItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionAuthItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionRoleItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionRoleItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionRoleItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitationRefUid", wireType)
			}
			m.InvitationRefUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvitationRefUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EMail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EMail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mobile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mobile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwoFA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TwoFA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Welcome", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Welcome = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, &SessionRoleItem{})
			if err := m.Roles[len(m.Roles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Perms = append(m.Perms, &SessionAuthItem{})
			if err := m.Perms[len(m.Perms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, &SessionRoleItem{})
			if err := m.Roles[len(m.Roles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Perms = append(m.Perms, &SessionAuthItem{})
			if err := m.Perms[len(m.Perms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdmin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdmin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheApiKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheApiKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheApiKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
			}
			m.WalletId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalletId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessType", wireType)
			}
			m.AccessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WType", wireType)
			}
			m.WType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WType |= WalletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
			}
			m.WalletId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalletId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinId", wireType)
			}
			m.CoinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HdPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HdPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressIndex", wireType)
			}
			m.AddressIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddressIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AddressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorStatus", wireType)
			}
			m.MonitorStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonitorStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalDecimal", wireType)
			}
			m.OriginalDecimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginalDecimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidDecimal", wireType)
			}
			m.ValidDecimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidDecimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeposit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDeposit = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanWithdraw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanWithdraw = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplorerUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExplorerUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUtxo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUtxo = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCollect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCollect = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmingThreshold", wireType)
			}
			m.ConfirmingThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmingThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DustThreshold", wireType)
			}
			m.DustThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DustThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMemo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestMemo = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HdCoinType", wireType)
			}
			m.HdCoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HdCoinType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectAmountMin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CollectAmountMin = float64(math.Float64frombits(v))
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowFeeUnitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SlowFeeUnitPrice = float64(math.Float64frombits(v))
		case 31:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiddleFeeUnitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MiddleFeeUnitPrice = float64(math.Float64frombits(v))
		case 32:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastFeeUnitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FastFeeUnitPrice = float64(math.Float64frombits(v))
		case 33:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FeeCount = float64(math.Float64frombits(v))
		case 34:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeLimitCount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FeeLimitCount = float64(math.Float64frombits(v))
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRefCid", wireType)
			}
			m.FeeRefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeRefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletHdIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletHdIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletHdIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinId", wireType)
			}
			m.CoinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressIndexLast", wireType)
			}
			m.AddressIndexLast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddressIndexLast |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletCoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletCoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletCoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanFixedFee", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanFixedFee = bool(v != 0)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FixedFee = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPlatformFee", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPlatformFee = bool(v != 0)
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PlatformFee = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRefCid", wireType)
			}
			m.FeeRefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeRefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeposit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDeposit = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanWithdraw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanWithdraw = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanNewAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanNewAddress = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Freeze", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Freeze = float64(math.Float64frombits(v))
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletAssetSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletAssetSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletAssetSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Freeze", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Freeze = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetUpdateAt", wireType)
			}
			m.AssetUpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetUpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotAt", wireType)
			}
			m.SnapshotAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountPerHour", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AmountPerHour = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountPerDay", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AmountPerDay = float64(math.Float64frombits(v))
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillType", wireType)
			}
			m.BillType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BillType |= BillType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayId", wireType)
			}
			m.RelayId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCtid", wireType)
			}
			m.RefCtid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCtid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ChangeAmount = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ResultAmount = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRefCid", wireType)
			}
			m.FeeRefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeRefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerTxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InnerTxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutN", wireType)
			}
			m.OutN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutN |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TxTypeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerTxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InnerTxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= TxSideType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpRefUid", wireType)
			}
			m.OpRefUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpRefUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FeeRate = float64(math.Float64frombits(v))
		case 29:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeLimit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FeeLimit = float64(math.Float64frombits(v))
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fee = float64(math.Float64frombits(v))
		case 31:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeAct", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FeeAct = float64(math.Float64frombits(v))
		case 32:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PlatformFee = float64(math.Float64frombits(v))
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRefCid", wireType)
			}
			m.FeeRefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeRefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproveNum", wireType)
			}
			m.ApproveNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproveNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedApproveNum", wireType)
			}
			m.NeedApproveNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedApproveNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainRefCid", wireType)
			}
			m.ChainRefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainRefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGenerateBill", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGenerateBill = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TxStateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmedNum", wireType)
			}
			m.ConfirmedNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmedNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedConfirmedNum", wireType)
			}
			m.NeedConfirmedNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedConfirmedNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefUid", wireType)
			}
			m.RefUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefTxState", wireType)
			}
			m.RefTxState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefTxState |= TxStateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedNextAct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedNextAct = bool(v != 0)
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefInnerTxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefInnerTxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproveAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApproveAll = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawCallbackUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawCallbackUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferCallbackUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferCallbackUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsContainConfirmNum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsContainConfirmNum = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawCallbackRetryNum", wireType)
			}
			m.WithdrawCallbackRetryNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithdrawCallbackRetryNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferCallbackRetryNum", wireType)
			}
			m.TransferCallbackRetryNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferCallbackRetryNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmingCallbackRetryNum", wireType)
			}
			m.ConfirmingCallbackRetryNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmingCallbackRetryNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryInv", wireType)
			}
			m.RetryInv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryInv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinWithdrawQuota) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinWithdrawQuota: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinWithdrawQuota: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuotaPerTx", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QuotaPerTx = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuotaPerHour", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QuotaPerHour = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuotaPerDay", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QuotaPerDay = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedPerson", wireType)
			}
			m.ApprovedPerson = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApprovedPerson |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinWithdrawWhitelist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinWithdrawWhitelist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinWithdrawWhitelist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Setting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Setting == nil {
				m.Setting = &WithdrawSetting{}
			}
			if err := m.Setting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quota", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quota = append(m.Quota, &CoinWithdrawQuota{})
			if err := m.Quota[len(m.Quota)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Whitelist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Whitelist = append(m.Whitelist, &CoinWithdrawWhitelist{})
			if err := m.Whitelist[len(m.Whitelist)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletCoinDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletCoinDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletCoinDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &CoinInfo{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coin == nil {
				m.Coin = &WalletCoin{}
			}
			if err := m.Coin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset == nil {
				m.Asset = &WalletAsset{}
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &WalletInfo{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, &WalletCoinDetail{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAid", wireType)
			}
			m.RefAid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefWid", wireType)
			}
			m.RefWid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefWid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCid", wireType)
			}
			m.RefCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCtid", wireType)
			}
			m.RefCtid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCtid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqNum", wireType)
			}
			m.ReqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReqNum", wireType)
			}
			m.MaxReqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReqNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryInv", wireType)
			}
			m.RetryInv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryInv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushStatus", wireType)
			}
			m.PushStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushStatus |= PushStatusType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShared
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= NotifyState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShared
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShared
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShared
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= bitbucket_org_biiigle_biiigle_wa001_dams_src_lib_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShared(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthShared
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShared(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShared
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShared
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShared
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShared
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShared
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShared
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShared        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShared          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShared = fmt.Errorf("proto: unexpected end of group")
)
